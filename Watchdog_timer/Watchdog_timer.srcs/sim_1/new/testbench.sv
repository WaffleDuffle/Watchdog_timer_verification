`ifndef UVM_PKG_SV
`define UVM_PKG_SV

`ifndef UVM_MACROS_SVH
`define UVM_MACROS_SVH

`ifdef MODEL_TECH
`ifndef QUESTA
`define QUESTA
`endif
`endif

`ifndef UVM_USE_STRING_QUEUE_STREAMING_PACK
  `define UVM_STRING_QUEUE_STREAMING_PACK(q) uvm_pkg::m_uvm_string_queue_join(q)
`endif

`ifndef QUESTA
`define uvm_typename(X) $typename(X)
`else
`define uvm_typename(X) $typename(X,39)
`endif

`ifdef INCA
  `define UVM_USE_PROCESS_CONTAINER
`endif

`define uvm_delay(TIME) #(TIME);

`ifndef UVM_VERSION_DEFINES_SVH
`define UVM_VERSION_DEFINES_SVH

`define UVM_MAJOR_REV 1

`define UVM_MINOR_REV 2

`define UVM_NAME UVM


`ifdef UVM_FIX_REV
 `define UVM_VERSION_STRING `"`UVM_NAME``-```UVM_MAJOR_REV``.```UVM_MINOR_REV`UVM_FIX_REV`"
`else
 `define UVM_VERSION_STRING `"`UVM_NAME``-```UVM_MAJOR_REV``.```UVM_MINOR_REV```"
`endif

`define UVM_MAJOR_REV_1


`define UVM_MINOR_REV_2


`define UVM_VERSION_1_2

`define UVM_MAJOR_VERSION_1_2

`define UVM_POST_VERSION_1_1

`endif 

`ifndef UVM_GLOBAL_DEFINES_SVH
`define UVM_GLOBAL_DEFINES_SVH


`ifndef UVM_MAX_STREAMBITS
 `define UVM_MAX_STREAMBITS 4096
`endif



`ifndef UVM_PACKER_MAX_BYTES
 `define UVM_PACKER_MAX_BYTES `UVM_MAX_STREAMBITS
`endif


`define UVM_DEFAULT_TIMEOUT 9200s

`endif 

`ifndef UVM_MESSAGE_DEFINES_SVH
`define UVM_MESSAGE_DEFINES_SVH

`ifndef UVM_LINE_WIDTH
  `define UVM_LINE_WIDTH 120
`endif 

`ifndef UVM_NUM_LINES
  `define UVM_NUM_LINES 120
`endif

`ifdef UVM_REPORT_DISABLE_FILE_LINE
`define UVM_REPORT_DISABLE_FILE
`define UVM_REPORT_DISABLE_LINE
`endif

`ifdef UVM_REPORT_DISABLE_FILE
`define uvm_file ""
`else
`define uvm_file `__FILE__
`endif

`ifdef UVM_REPORT_DISABLE_LINE
`define uvm_line 0
`else
`define uvm_line `__LINE__
`endif


`define uvm_info(ID, MSG, VERBOSITY) \
   begin \
     if (uvm_report_enabled(VERBOSITY,UVM_INFO,ID)) \
       uvm_report_info (ID, MSG, VERBOSITY, `uvm_file, `uvm_line, "", 1); \
   end



`define uvm_warning(ID, MSG) \
   begin \
     if (uvm_report_enabled(UVM_NONE,UVM_WARNING,ID)) \
       uvm_report_warning (ID, MSG, UVM_NONE, `uvm_file, `uvm_line, "", 1); \
   end



`define uvm_error(ID, MSG) \
   begin \
     if (uvm_report_enabled(UVM_NONE,UVM_ERROR,ID)) \
       uvm_report_error (ID, MSG, UVM_NONE, `uvm_file, `uvm_line, "", 1); \
   end



`define uvm_fatal(ID, MSG) \
   begin \
     if (uvm_report_enabled(UVM_NONE,UVM_FATAL,ID)) \
       uvm_report_fatal (ID, MSG, UVM_NONE, `uvm_file, `uvm_line, "", 1); \
   end




`define uvm_info_context(ID, MSG, VERBOSITY, RO) \
   begin \
     if (RO.uvm_report_enabled(VERBOSITY,UVM_INFO,ID)) \
       RO.uvm_report_info (ID, MSG, VERBOSITY, `uvm_file, `uvm_line, "", 1); \
   end



`define uvm_warning_context(ID, MSG, RO) \
   begin \
     if (RO.uvm_report_enabled(UVM_NONE,UVM_WARNING,ID)) \
       RO.uvm_report_warning (ID, MSG, UVM_NONE, `uvm_file, `uvm_line, "", 1); \
   end



`define uvm_error_context(ID, MSG, RO) \
   begin \
     if (RO.uvm_report_enabled(UVM_NONE,UVM_ERROR,ID)) \
       RO.uvm_report_error (ID, MSG, UVM_NONE, `uvm_file, `uvm_line, "", 1); \
   end



`define uvm_fatal_context(ID, MSG, RO) \
   begin \
     if (RO.uvm_report_enabled(UVM_NONE,UVM_FATAL,ID)) \
       RO.uvm_report_fatal (ID, MSG, UVM_NONE, `uvm_file, `uvm_line, "", 1); \
   end



`define uvm_message_begin(SEVERITY, ID, MSG, VERBOSITY, FILE, LINE, RM) \
   begin \
     if (uvm_report_enabled(VERBOSITY,SEVERITY,ID)) begin \
       uvm_report_message __uvm_msg; \
       if (RM == null) RM = uvm_report_message::new_report_message(); \
       __uvm_msg = RM; \
       __uvm_msg.set_report_message(SEVERITY, ID, MSG, VERBOSITY, FILE, LINE, "");



`define uvm_message_end \
       uvm_process_report_message(__uvm_msg); \
     end \
   end


`define uvm_message_context_begin(SEVERITY, ID, MSG, VERBOSITY, FILE, LINE, RO, RM) \
   begin \
     uvm_report_object __report_object; \
     __report_object = RO; \
     if (__report_object.uvm_report_enabled(VERBOSITY,SEVERITY,ID)) begin \
       uvm_report_message __uvm_msg; \
       if (RM == null) RM = uvm_report_message::new_report_message(); \
       __uvm_msg = RM; \
       __uvm_msg.set_report_message(SEVERITY, ID, MSG, VERBOSITY, FILE, LINE, "");



`define uvm_message_context_end \
       __report_object.uvm_process_report_message(__uvm_msg); \
     end \
   end


`define uvm_info_begin(ID, MSG, VERBOSITY, RM = __uvm_msg) \
   `uvm_message_begin(UVM_INFO, ID, MSG, VERBOSITY, `uvm_file, `uvm_line, RM)

`define uvm_info_end \
   `uvm_message_end


`define uvm_warning_begin(ID, MSG, RM = __uvm_msg) \
   `uvm_message_begin(UVM_WARNING, ID, MSG, UVM_NONE, `uvm_file, `uvm_line, RM)

`define uvm_warning_end \
   `uvm_message_end


`define uvm_error_begin(ID, MSG, RM = __uvm_msg) \
   `uvm_message_begin(UVM_ERROR, ID, MSG, UVM_NONE, `uvm_file, `uvm_line, RM)


`define uvm_error_end \
   `uvm_message_end


`define uvm_fatal_begin(ID, MSG, RM = __uvm_msg) \
   `uvm_message_begin(UVM_FATAL, ID, MSG, UVM_NONE, `uvm_file, `uvm_line, RM)

`define uvm_fatal_end \
   `uvm_message_end


`define uvm_info_context_begin(ID, MSG, VERBOSITY, RO, RM = __uvm_msg) \
   `uvm_message_context_begin(UVM_INFO, ID, MSG, VERBOSITY, `uvm_file, `uvm_line, RO, RM)


`define uvm_info_context_end \
   `uvm_message_context_end

 
`define uvm_warning_context_begin(ID, MSG, RO, RM = __uvm_msg) \
   `uvm_message_context_begin(UVM_WARNING, ID, MSG, UVM_NONE, `uvm_file, `uvm_line, RO, RM)



`define uvm_warning_context_end \
   `uvm_message_context_end


`define uvm_error_context_begin(ID, MSG, RO, RM = __uvm_msg) \
   `uvm_message_context_begin(UVM_ERROR, ID, MSG, UVM_NONE, `uvm_file, `uvm_line, RO, RM)

`define uvm_error_context_end \
   `uvm_message_context_end


`define uvm_fatal_context_begin(ID, MSG, RO, RM = __uvm_msg) \
   `uvm_message_context_begin(UVM_FATAL, ID, MSG, UVM_NONE, `uvm_file, `uvm_line, RO, RM)

`define uvm_fatal_context_end \
   `uvm_message_context_end


`define uvm_message_add_tag(NAME, VALUE, ACTION=(UVM_LOG|UVM_RM_RECORD)) \
    __uvm_msg.add_string(NAME, VALUE, ACTION);

`define uvm_message_add_int(VAR, RADIX, LABEL="", ACTION=(UVM_LOG|UVM_RM_RECORD)) \
    if (LABEL == "") \
      __uvm_msg.add_int(`"VAR`", VAR, $bits(VAR), RADIX, ACTION); \
    else \
      __uvm_msg.add_int(LABEL, VAR, $bits(VAR), RADIX, ACTION);


`define uvm_message_add_string(VAR, LABEL="", ACTION=(UVM_LOG|UVM_RM_RECORD)) \
    if (LABEL == "") \
      __uvm_msg.add_string(`"VAR`", VAR, ACTION); \
    else \
      __uvm_msg.add_string(LABEL, VAR, ACTION);

`define uvm_message_add_object(VAR, LABEL="", ACTION=(UVM_LOG|UVM_RM_RECORD)) \
    if (LABEL == "") \
      __uvm_msg.add_object(`"VAR`", VAR, ACTION); \
    else \
      __uvm_msg.add_object(LABEL, VAR, ACTION);


`endif 


`ifndef UVM_PHASE_DEFINES_SVH
`define UVM_PHASE_DEFINES_SVH


`define m_uvm_task_phase(PHASE,COMP,PREFIX) \
        class PREFIX``PHASE``_phase extends uvm_task_phase; \
          virtual task exec_task(uvm_component comp, uvm_phase phase); \
            COMP comp_; \
            if ($cast(comp_,comp)) \
              comp_.``PHASE``_phase(phase); \
          endtask \
          local static PREFIX``PHASE``_phase m_inst; \
          static const string type_name = `"PREFIX``PHASE``_phase`"; \
          static function PREFIX``PHASE``_phase get(); \
            if(m_inst == null) begin \
              m_inst = new; \
            end \
            return m_inst; \
          endfunction \
          protected function new(string name=`"PHASE`"); \
            super.new(name); \
          endfunction \
          virtual function string get_type_name(); \
            return type_name; \
          endfunction \
        endclass \

`define m_uvm_topdown_phase(PHASE,COMP,PREFIX) \
        class PREFIX``PHASE``_phase extends uvm_topdown_phase; \
          virtual function void exec_func(uvm_component comp, uvm_phase phase); \
            COMP comp_; \
            if ($cast(comp_,comp)) \
              comp_.``PHASE``_phase(phase); \
          endfunction \
          local static PREFIX``PHASE``_phase m_inst; \
          static const string type_name = `"PREFIX``PHASE``_phase`"; \
          static function PREFIX``PHASE``_phase get(); \
            if(m_inst == null) begin \
              m_inst = new(); \
            end \
            return m_inst; \
          endfunction \
          protected function new(string name=`"PHASE`"); \
            super.new(name); \
          endfunction \
          virtual function string get_type_name(); \
            return type_name; \
          endfunction \
        endclass \

`define m_uvm_bottomup_phase(PHASE,COMP,PREFIX) \
        class PREFIX``PHASE``_phase extends uvm_bottomup_phase; \
          virtual function void exec_func(uvm_component comp, uvm_phase phase); \
            COMP comp_; \
            if ($cast(comp_,comp)) \
              comp_.``PHASE``_phase(phase); \
          endfunction \
          static PREFIX``PHASE``_phase m_inst; \
          static const string type_name = `"PREFIX``PHASE``_phase`"; \
          static function PREFIX``PHASE``_phase get(); \
            if(m_inst == null) begin \
              m_inst = new(); \
            end \
            return m_inst; \
          endfunction \
          protected function new(string name=`"PHASE`"); \
            super.new(name); \
          endfunction \
          virtual function string get_type_name(); \
            return type_name; \
          endfunction \
        endclass \

`define uvm_builtin_task_phase(PHASE) \
        `m_uvm_task_phase(PHASE,uvm_component,uvm_)

`define uvm_builtin_topdown_phase(PHASE) \
        `m_uvm_topdown_phase(PHASE,uvm_component,uvm_)

`define uvm_builtin_bottomup_phase(PHASE) \
        `m_uvm_bottomup_phase(PHASE,uvm_component,uvm_)


`define uvm_user_task_phase(PHASE,COMP,PREFIX) \
        `m_uvm_task_phase(PHASE,COMP,PREFIX)

`define uvm_user_topdown_phase(PHASE,COMP,PREFIX) \
        `m_uvm_topdown_phase(PHASE,COMP,PREFIX)

`define uvm_user_bottomup_phase(PHASE,COMP,PREFIX) \
        `m_uvm_bottomup_phase(PHASE,COMP,PREFIX)

`endif



`ifndef UVM_OBJECT_DEFINES_SVH
`define UVM_OBJECT_DEFINES_SVH

`ifdef UVM_EMPTY_MACROS

`define uvm_field_utils_begin(T) 
`define uvm_field_utils_end 
`define uvm_object_utils(T) 
`define uvm_object_param_utils(T) 
`define uvm_object_utils_begin(T) 
`define uvm_object_param_utils_begin(T) 
`define uvm_object_utils_end
`define uvm_component_utils(T)
`define uvm_component_param_utils(T)
`define uvm_component_utils_begin(T)
`define uvm_component_param_utils_begin(T)
`define uvm_component_utils_end
`define uvm_field_int(ARG,FLAG)
`define uvm_field_real(ARG,FLAG)
`define uvm_field_enum(T,ARG,FLAG)
`define uvm_field_object(ARG,FLAG)
`define uvm_field_event(ARG,FLAG)
`define uvm_field_string(ARG,FLAG)
`define uvm_field_array_enum(ARG,FLAG)
`define uvm_field_array_int(ARG,FLAG)
`define uvm_field_sarray_int(ARG,FLAG)
`define uvm_field_sarray_enum(ARG,FLAG)
`define uvm_field_array_object(ARG,FLAG)
`define uvm_field_sarray_object(ARG,FLAG)
`define uvm_field_array_string(ARG,FLAG)
`define uvm_field_sarray_string(ARG,FLAG)
`define uvm_field_queue_enum(ARG,FLAG)
`define uvm_field_queue_int(ARG,FLAG)
`define uvm_field_queue_object(ARG,FLAG)
`define uvm_field_queue_string(ARG,FLAG)
`define uvm_field_aa_int_string(ARG, FLAG)
`define uvm_field_aa_string_string(ARG, FLAG)
`define uvm_field_aa_object_string(ARG, FLAG)
`define uvm_field_aa_int_int(ARG, FLAG)
`define uvm_field_aa_int_int(ARG, FLAG)
`define uvm_field_aa_int_int_unsigned(ARG, FLAG)
`define uvm_field_aa_int_integer(ARG, FLAG)
`define uvm_field_aa_int_integer_unsigned(ARG, FLAG)
`define uvm_field_aa_int_byte(ARG, FLAG)
`define uvm_field_aa_int_byte_unsigned(ARG, FLAG)
`define uvm_field_aa_int_shortint(ARG, FLAG)
`define uvm_field_aa_int_shortint_unsigned(ARG, FLAG)
`define uvm_field_aa_int_longint(ARG, FLAG)
`define uvm_field_aa_int_longint_unsigned(ARG, FLAG)
`define uvm_field_aa_int_key(KEY, ARG, FLAG)
`define uvm_field_aa_string_int(ARG, FLAG)
`define uvm_field_aa_object_int(ARG, FLAG)

`else


`ifdef UVM_NO_DEPRECATED 
  `define UVM_NO_REGISTERED_CONVERTER
`endif



`define uvm_field_utils_begin(T) \
   function void __m_uvm_field_automation (uvm_object tmp_data__, \
                                     int what__, \
                                     string str__); \
   begin \
     T local_data__;  \
     typedef T ___local_type____; \
     string string_aa_key;  \
     uvm_object __current_scopes[$]; \
     if(what__ inside {UVM_SETINT,UVM_SETSTR,UVM_SETOBJ}) begin \
        if(__m_uvm_status_container.m_do_cycle_check(this)) begin \
            return; \
        end \
        else \
            __current_scopes=__m_uvm_status_container.m_uvm_cycle_scopes; \
     end \
     super.__m_uvm_field_automation(tmp_data__, what__, str__); \
     if(tmp_data__ != null) \
       if(!$cast(local_data__, tmp_data__)) return;

`define uvm_field_utils_end \
     if(what__ inside {UVM_SETINT,UVM_SETSTR,UVM_SETOBJ}) begin \
        void'(__current_scopes.pop_back()); \
        __m_uvm_status_container.m_uvm_cycle_scopes = __current_scopes; \
     end \
     end \
endfunction \


`define uvm_object_utils(T) \
  `uvm_object_utils_begin(T) \
  `uvm_object_utils_end

`define uvm_object_param_utils(T) \
  `uvm_object_param_utils_begin(T) \
  `uvm_object_utils_end

`define uvm_object_utils_begin(T) \
   `m_uvm_object_registry_internal(T,T)  \
   `m_uvm_object_create_func(T) \
   `m_uvm_get_type_name_func(T) \
   `uvm_field_utils_begin(T) 

`define uvm_object_param_utils_begin(T) \
   `m_uvm_object_registry_param(T)  \
   `m_uvm_object_create_func(T) \
   `uvm_field_utils_begin(T) 
       
`define uvm_object_utils_end \
     end \
   endfunction \


`define uvm_component_utils(T) \
   `m_uvm_component_registry_internal(T,T) \
   `m_uvm_get_type_name_func(T) \

`define uvm_component_param_utils(T) \
   `m_uvm_component_registry_param(T) \

   
`define uvm_component_utils_begin(T) \
   `uvm_component_utils(T) \
   `uvm_field_utils_begin(T) 

`define uvm_component_param_utils_begin(T) \
   `uvm_component_param_utils(T) \
   `uvm_field_utils_begin(T) 

`define uvm_component_utils_end \
     end \
   endfunction



`define uvm_object_registry(T,S) \
   typedef uvm_object_registry#(T,S) type_id; \
   static function type_id get_type(); \
     return type_id::get(); \
   endfunction \
   virtual function uvm_object_wrapper get_object_type(); \
     return type_id::get(); \
   endfunction 



`define uvm_component_registry(T,S) \
   typedef uvm_component_registry #(T,S) type_id; \
   static function type_id get_type(); \
     return type_id::get(); \
   endfunction \
   virtual function uvm_object_wrapper get_object_type(); \
     return type_id::get(); \
   endfunction 



`define uvm_new_func \
  function new (string name, uvm_component parent); \
    super.new(name, parent); \
  endfunction




`define m_uvm_object_create_func(T) \
   function uvm_object create (string name=""); \
     T tmp; \
`ifdef UVM_OBJECT_DO_NOT_NEED_CONSTRUCTOR \
     tmp = new(); \
     if (name!="") \
       tmp.set_name(name); \
`else \
     if (name=="") tmp = new(); \
     else tmp = new(name); \
`endif \
     return tmp; \
   endfunction



`define m_uvm_get_type_name_func(T) \
   const static string type_name = `"T`"; \
   virtual function string get_type_name (); \
     return type_name; \
   endfunction 



`define m_uvm_object_registry_internal(T,S) \
   typedef uvm_object_registry#(T,`"S`") type_id; \
   static function type_id get_type(); \
     return type_id::get(); \
   endfunction \
   virtual function uvm_object_wrapper get_object_type(); \
     return type_id::get(); \
   endfunction 



`define m_uvm_object_registry_param(T) \
   typedef uvm_object_registry #(T) type_id; \
   static function type_id get_type(); \
     return type_id::get(); \
   endfunction \
   virtual function uvm_object_wrapper get_object_type(); \
     return type_id::get(); \
   endfunction 



`define m_uvm_component_registry_internal(T,S) \
   typedef uvm_component_registry #(T,`"S`") type_id; \
   static function type_id get_type(); \
     return type_id::get(); \
   endfunction \
   virtual function uvm_object_wrapper get_object_type(); \
     return type_id::get(); \
   endfunction



`define m_uvm_component_registry_param(T) \
   typedef uvm_component_registry #(T) type_id; \
   static function type_id get_type(); \
     return type_id::get(); \
   endfunction \
   virtual function uvm_object_wrapper get_object_type(); \
     return type_id::get(); \
   endfunction


`define uvm_field_int(ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        begin \
          __m_uvm_status_container.do_field_check(`"ARG`", this); \
        end \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) ARG = local_data__.ARG; \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(ARG !== local_data__.ARG) begin \
               void'(__m_uvm_status_container.comparer.compare_field(`"ARG`", ARG, local_data__.ARG, $bits(ARG))); \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          if($bits(ARG) <= 64) __m_uvm_status_container.packer.pack_field_int(ARG, $bits(ARG)); \
          else __m_uvm_status_container.packer.pack_field(ARG, $bits(ARG)); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          if($bits(ARG) <= 64) ARG =  __m_uvm_status_container.packer.unpack_field_int($bits(ARG)); \
          else ARG = __m_uvm_status_container.packer.unpack_field($bits(ARG)); \
        end \
      UVM_RECORD: \
        `m_uvm_record_int(ARG, FLAG) \
      UVM_PRINT: \
        `m_uvm_print_int(ARG, FLAG) \
      UVM_SETINT: \
        begin \
          bit matched; \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          matched = uvm_is_match(str__, __m_uvm_status_container.scope.get()); \
          if(matched) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
              ARG = uvm_object::__m_uvm_status_container.bitstream; \
              uvm_object::__m_uvm_status_container.status = 1; \
            end \
          end \
          __m_uvm_status_container.scope.unset_arg(`"ARG`"); \
        end \
    endcase \
  end



`define uvm_field_object(ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) begin \
            if((FLAG)&UVM_REFERENCE || local_data__.ARG == null) ARG = local_data__.ARG; \
            else begin \
              uvm_object l_obj; \
              if(local_data__.ARG.get_name() == "") local_data__.ARG.set_name(`"ARG`"); \
              l_obj = local_data__.ARG.clone(); \
              if(l_obj == null) begin \
                `uvm_fatal("FAILCLN", $sformatf("Failure to clone %s.ARG, thus the variable will remain null.", local_data__.get_name())); \
              end \
              else begin \
                $cast(ARG, l_obj); \
                ARG.set_name(local_data__.ARG.get_name()); \
              end \
            end \
          end \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            void'(__m_uvm_status_container.comparer.compare_object(`"ARG`", ARG, local_data__.ARG)); \
            if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          if(((FLAG)&UVM_NOPACK) == 0 && ((FLAG)&UVM_REFERENCE) == 0) \
            __m_uvm_status_container.packer.pack_object(ARG); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          if(((FLAG)&UVM_NOPACK) == 0 && ((FLAG)&UVM_REFERENCE) == 0) \
            __m_uvm_status_container.packer.unpack_object(ARG); \
        end \
      UVM_RECORD: \
        `m_uvm_record_object(ARG,FLAG) \
      UVM_PRINT: \
        begin \
          if(!((FLAG)&UVM_NOPRINT)) begin \
            if(((FLAG)&UVM_REFERENCE) != 0) \
              __m_uvm_status_container.printer.print_object_header(`"ARG`", ARG); \
            else \
              __m_uvm_status_container.printer.print_object(`"ARG`", ARG); \
          end \
        end \
      UVM_SETINT: \
        begin \
          if((ARG != null) && (((FLAG)&UVM_READONLY)==0) && (((FLAG)&UVM_REFERENCE)==0)) begin \
            __m_uvm_status_container.scope.down(`"ARG`"); \
            ARG.__m_uvm_field_automation(null, UVM_SETINT, str__); \
            __m_uvm_status_container.scope.up(); \
          end \
        end \
      UVM_SETSTR: \
        begin \
          if((ARG != null) && (((FLAG)&UVM_READONLY)==0) && (((FLAG)&UVM_REFERENCE)==0)) begin \
            __m_uvm_status_container.scope.down(`"ARG`"); \
            ARG.__m_uvm_field_automation(null, UVM_SETSTR, str__); \
            __m_uvm_status_container.scope.up(); \
          end \
        end \
      UVM_SETOBJ: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_object()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
              if($cast(ARG,uvm_object::__m_uvm_status_container.object)) \
                uvm_object::__m_uvm_status_container.status = 1; \
            end \
          end \
          else if(ARG!=null && ((FLAG)&UVM_READONLY) == 0) begin \
            int cnt; \
            for(cnt=0; cnt<str__.len(); ++cnt) begin \
              if(str__[cnt] == "." || str__[cnt] == "*") break; \
            end \
            if(cnt!=str__.len()) begin \
              __m_uvm_status_container.scope.down(`"ARG`"); \
              ARG.__m_uvm_field_automation(null, UVM_SETOBJ, str__); \
              __m_uvm_status_container.scope.up(); \
            end \
          end \
        end \
    endcase \
  end



`define uvm_field_string(ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) ARG = local_data__.ARG; \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(ARG != local_data__.ARG) begin \
               void'(__m_uvm_status_container.comparer.compare_string(`"ARG`", ARG, local_data__.ARG)); \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          __m_uvm_status_container.packer.pack_string(ARG); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          ARG = __m_uvm_status_container.packer.unpack_string(); \
        end \
      UVM_RECORD: \
        `m_uvm_record_string(ARG, ARG, FLAG) \
      UVM_PRINT: \
        if(!((FLAG)&UVM_NOPRINT)) begin \
          __m_uvm_status_container.printer.print_string(`"ARG`", ARG); \
        end \
      UVM_SETSTR: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_str()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
              ARG = uvm_object::__m_uvm_status_container.stringv; \
              __m_uvm_status_container.status = 1; \
            end \
          end \
      end \
    endcase \
  end



`define uvm_field_enum(T,ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) ARG = local_data__.ARG; \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(ARG !== local_data__.ARG) begin \
               __m_uvm_status_container.scope.set_arg(`"ARG`"); \
               $swrite(__m_uvm_status_container.stringv, "lhs = %0s : rhs = %0s", \
                 ARG.name(), local_data__.ARG.name()); \
               __m_uvm_status_container.comparer.print_msg(__m_uvm_status_container.stringv); \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          __m_uvm_status_container.packer.pack_field(ARG, $bits(ARG)); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          ARG =  T'(__m_uvm_status_container.packer.unpack_field_int($bits(ARG))); \
        end \
      UVM_RECORD: \
        `m_uvm_record_string(ARG, ARG.name(), FLAG) \
      UVM_PRINT: \
        if(!((FLAG)&UVM_NOPRINT)) begin \
          __m_uvm_status_container.printer.print_generic(`"ARG`", `"T`", $bits(ARG), ARG.name()); \
        end \
      UVM_SETINT: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
              ARG = T'(uvm_object::__m_uvm_status_container.bitstream); \
              __m_uvm_status_container.status = 1; \
            end \
          end \
        end \
      UVM_SETSTR: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_str()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
              void'(uvm_enum_wrapper#(T)::from_name(uvm_object::__m_uvm_status_container.stringv, ARG)); \
              __m_uvm_status_container.status = 1; \
            end \
          end \
      end \
    endcase \
  end



`define uvm_field_real(ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) ARG = local_data__.ARG; \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(ARG != local_data__.ARG) begin \
               void'(__m_uvm_status_container.comparer.compare_field_real(`"ARG`", ARG, local_data__.ARG)); \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          __m_uvm_status_container.packer.pack_field_int($realtobits(ARG), 64); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          ARG = $bitstoreal(__m_uvm_status_container.packer.unpack_field_int(64)); \
        end \
      UVM_RECORD: \
        if(!((FLAG)&UVM_NORECORD)) begin \
          __m_uvm_status_container.recorder.record_field_real(`"ARG`", ARG); \
        end \
      UVM_PRINT: \
        if(!((FLAG)&UVM_NOPRINT)) begin \
          __m_uvm_status_container.printer.print_real(`"ARG`", ARG); \
        end \
      UVM_SETINT: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
              ARG = $bitstoreal(uvm_object::__m_uvm_status_container.bitstream); \
              __m_uvm_status_container.status = 1; \
            end \
          end \
      end \
    endcase \
  end



`define uvm_field_event(ARG,FLAG) \
  begin \
    case (what__) \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) ARG = local_data__.ARG; \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(ARG != local_data__.ARG) begin \
               __m_uvm_status_container.scope.down(`"ARG`"); \
               __m_uvm_status_container.comparer.print_msg(""); \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
        end \
      UVM_RECORD: \
        begin \
        end \
      UVM_PRINT: \
        if(!((FLAG)&UVM_NOPRINT)) begin \
          __m_uvm_status_container.printer.print_generic(`"ARG`", "event", -1, ""); \
        end \
      UVM_SETINT: \
        begin \
        end \
    endcase \
  end




`define uvm_field_sarray_int(ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) ARG = local_data__.ARG; \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(ARG !== local_data__.ARG) begin \
               if(__m_uvm_status_container.comparer.show_max == 1) begin \
                 __m_uvm_status_container.scope.set_arg(`"ARG`"); \
                 __m_uvm_status_container.comparer.print_msg(""); \
               end \
               else if(__m_uvm_status_container.comparer.show_max) begin \
                 foreach(ARG[i]) begin \
                   if(ARG[i] !== local_data__.ARG[i]) begin \
                     __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
                     void'(__m_uvm_status_container.comparer.compare_field("", ARG[i], local_data__.ARG[i], $bits(ARG[i]))); \
                   end \
                 end \
               end \
               else if ((__m_uvm_status_container.comparer.physical&&((FLAG)&UVM_PHYSICAL)) || \
                        (__m_uvm_status_container.comparer.abstract&&((FLAG)&UVM_ABSTRACT)) || \
                        (!((FLAG)&UVM_PHYSICAL) && !((FLAG)&UVM_ABSTRACT)) ) \
                 __m_uvm_status_container.comparer.result++; \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          foreach(ARG[i])  \
            if($bits(ARG[i]) <= 64) __m_uvm_status_container.packer.pack_field_int(ARG[i], $bits(ARG[i])); \
            else __m_uvm_status_container.packer.pack_field(ARG[i], $bits(ARG[i])); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          foreach(ARG[i]) \
            if($bits(ARG[i]) <= 64) ARG[i] = __m_uvm_status_container.packer.unpack_field_int($bits(ARG[i])); \
            else ARG[i] = __m_uvm_status_container.packer.unpack_field($bits(ARG[i])); \
        end \
      UVM_RECORD: \
        `m_uvm_record_qda_int(ARG, FLAG, $size(ARG))  \
      UVM_PRINT: \
        if(!((FLAG)&UVM_NOPRINT)) begin \
          if(((FLAG)&UVM_NOPRINT) == 0) begin \
             `uvm_print_sarray_int3(ARG, uvm_radix_enum'((FLAG)&(UVM_RADIX)), \
                                   __m_uvm_status_container.printer) \
          end \
        end \
      UVM_SETINT: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              uvm_report_warning("RDONLY", $sformatf("%s: static arrays cannot be resized via configuraton.",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
          end \
          else if(!((FLAG)&UVM_READONLY)) begin \
            foreach(ARG[i]) begin \
              __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
              if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                ARG[i] =  uvm_object::__m_uvm_status_container.bitstream; \
                __m_uvm_status_container.status = 1; \
              end \
            end \
          end \
        end \
    endcase \
  end



`define uvm_field_sarray_object(ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) begin \
            if(((FLAG)&UVM_REFERENCE)) \
              ARG = local_data__.ARG; \
            else \
              foreach(ARG[i]) begin \
                if(ARG[i] != null && local_data__.ARG[i] != null) \
                  ARG[i].copy(local_data__.ARG[i]); \
                else if(ARG[i] == null && local_data__.ARG[i] != null) \
                  $cast(ARG[i], local_data__.ARG[i].clone()); \
                else \
                  ARG[i] = null; \
              end \
          end \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(((FLAG)&UVM_REFERENCE) && (__m_uvm_status_container.comparer.show_max <= 1) && (ARG !== local_data__.ARG) ) begin \
               if(__m_uvm_status_container.comparer.show_max == 1) begin \
                 __m_uvm_status_container.scope.set_arg(`"ARG`"); \
                 __m_uvm_status_container.comparer.print_msg(""); \
               end \
               else if ((__m_uvm_status_container.comparer.physical&&((FLAG)&UVM_PHYSICAL)) || \
                        (__m_uvm_status_container.comparer.abstract&&((FLAG)&UVM_ABSTRACT)) || \
                        (!((FLAG)&UVM_PHYSICAL) && !((FLAG)&UVM_ABSTRACT)) ) \
                 __m_uvm_status_container.comparer.result++; \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
            else begin \
              string s; \
              foreach(ARG[i]) begin \
                if(ARG[i] != null && local_data__.ARG[i] != null) begin \
                  $swrite(s,`"ARG[%0d]`",i); \
                  void'(__m_uvm_status_container.comparer.compare_object(s, ARG[i], local_data__.ARG[i])); \
                end \
                if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
              end \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          foreach(ARG[i])  \
            __m_uvm_status_container.packer.pack_object(ARG[i]); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          foreach(ARG[i]) \
            __m_uvm_status_container.packer.unpack_object(ARG[i]); \
        end \
      UVM_RECORD: \
        `m_uvm_record_qda_object(ARG,FLAG,$size(ARG)) \
      UVM_PRINT: \
        begin \
          if(((FLAG)&UVM_NOPRINT) == 0) begin \
             `uvm_print_sarray_object3(ARG, __m_uvm_status_container.printer, FLAG) \
          end \
        end \
      UVM_SETINT: \
        begin \
          string s; \
          if(!((FLAG)&UVM_READONLY)) begin \
            foreach(ARG[i]) begin \
              $swrite(s,`"ARG[%0d]`",i); \
              __m_uvm_status_container.scope.set_arg(s); \
              if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_object()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                if($cast(ARG[i],uvm_object::__m_uvm_status_container.object)) \
                  uvm_object::__m_uvm_status_container.status = 1; \
              end \
              else if(ARG[i]!=null && !((FLAG)&UVM_REFERENCE)) begin \
                int cnt; \
                for(cnt=0; cnt<str__.len(); ++cnt) begin \
                  if(str__[cnt] == "." || str__[cnt] == "*") break; \
                end \
                if(cnt!=str__.len()) begin \
                  __m_uvm_status_container.scope.down(s); \
                  ARG[i].__m_uvm_field_automation(null, UVM_SETINT, str__); \
                  __m_uvm_status_container.scope.up(); \
                end \
              end \
            end \
          end \
        end \
      UVM_SETSTR: \
        begin \
          string s; \
          if(!((FLAG)&UVM_READONLY)) begin \
            foreach(ARG[i]) begin \
              $swrite(s,`"ARG[%0d]`",i); \
              __m_uvm_status_container.scope.set_arg(s); \
              if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_object()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                if($cast(ARG[i],uvm_object::__m_uvm_status_container.object)) \
                  uvm_object::__m_uvm_status_container.status = 1; \
              end \
              else if(ARG[i]!=null && !((FLAG)&UVM_REFERENCE)) begin \
                int cnt; \
                for(cnt=0; cnt<str__.len(); ++cnt) begin \
                  if(str__[cnt] == "." || str__[cnt] == "*") break; \
                end \
                if(cnt!=str__.len()) begin \
                  __m_uvm_status_container.scope.down(s); \
                  ARG[i].__m_uvm_field_automation(null, UVM_SETSTR, str__); \
                  __m_uvm_status_container.scope.up(); \
                end \
              end \
            end \
          end \
        end \
      UVM_SETOBJ: \
        begin \
          string s; \
          if(!((FLAG)&UVM_READONLY)) begin \
            foreach(ARG[i]) begin \
              $swrite(s,`"ARG[%0d]`",i); \
              __m_uvm_status_container.scope.set_arg(s); \
              if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_object()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                if($cast(ARG[i],uvm_object::__m_uvm_status_container.object)) \
                  uvm_object::__m_uvm_status_container.status = 1; \
              end \
              else if(ARG[i]!=null && !((FLAG)&UVM_REFERENCE)) begin \
                int cnt; \
                for(cnt=0; cnt<str__.len(); ++cnt) begin \
                  if(str__[cnt] == "." || str__[cnt] == "*") break; \
                end \
                if(cnt!=str__.len()) begin \
                  __m_uvm_status_container.scope.down(s); \
                  ARG[i].__m_uvm_field_automation(null, UVM_SETOBJ, str__); \
                  __m_uvm_status_container.scope.up(); \
                end \
              end \
            end \
          end \
        end \
    endcase \
  end



`define uvm_field_sarray_string(ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) ARG = local_data__.ARG; \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(ARG != local_data__.ARG) begin \
               if(__m_uvm_status_container.comparer.show_max == 1) begin \
                 __m_uvm_status_container.scope.set_arg(`"ARG`"); \
                 __m_uvm_status_container.comparer.print_msg(""); \
               end \
               else if(__m_uvm_status_container.comparer.show_max) begin \
                 foreach(ARG[i]) begin \
                   if(ARG[i] != local_data__.ARG[i]) begin \
                     __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
                     void'(__m_uvm_status_container.comparer.compare_string("", ARG[i], local_data__.ARG[i])); \
                   end \
                 end \
               end \
               else if ((__m_uvm_status_container.comparer.physical&&((FLAG)&UVM_PHYSICAL)) || \
                        (__m_uvm_status_container.comparer.abstract&&((FLAG)&UVM_ABSTRACT)) || \
                        (!((FLAG)&UVM_PHYSICAL) && !((FLAG)&UVM_ABSTRACT)) ) \
                 __m_uvm_status_container.comparer.result++; \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          foreach(ARG[i])  \
            __m_uvm_status_container.packer.pack_string(ARG[i]); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          foreach(ARG[i]) \
            ARG[i] = __m_uvm_status_container.packer.unpack_string(); \
        end \
      UVM_RECORD: \
        begin \
          int sz; foreach(ARG[i]) sz=i; \
          `m_uvm_record_qda_string(ARG, FLAG, sz) \
        end \
      UVM_PRINT: \
        begin \
          if(((FLAG)&UVM_NOPRINT) == 0) begin \
             `uvm_print_sarray_string2(ARG, __m_uvm_status_container.printer) \
          end \
        end \
      UVM_SETSTR: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              uvm_report_warning("RDONLY", {__m_uvm_status_container.get_full_scope_arg(), \
              ": static arrays cannot be resized via configuraton."}, UVM_NONE); \
            end \
          end \
          else if(!((FLAG)&UVM_READONLY)) begin \
            foreach(ARG[i]) begin \
              __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
              if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                ARG[i] =  uvm_object::__m_uvm_status_container.stringv; \
                __m_uvm_status_container.status = 1; \
              end \
            end \
          end \
        end \
    endcase \
  end



`define uvm_field_sarray_enum(T,ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) ARG = local_data__.ARG; \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(ARG !== local_data__.ARG) begin \
               if(__m_uvm_status_container.comparer.show_max == 1) begin \
                 __m_uvm_status_container.scope.set_arg(`"ARG`"); \
                 __m_uvm_status_container.comparer.print_msg(""); \
               end \
               else if(__m_uvm_status_container.comparer.show_max) begin \
                 foreach(ARG[i]) begin \
                   if(ARG[i] !== local_data__.ARG[i]) begin \
                     __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
                     $swrite(__m_uvm_status_container.stringv, "lhs = %0s : rhs = %0s", \
                       ARG[i].name(), local_data__.ARG[i].name()); \
                     __m_uvm_status_container.comparer.print_msg(__m_uvm_status_container.stringv); \
                     if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
                   end \
                 end \
               end \
               else if ((__m_uvm_status_container.comparer.physical&&((FLAG)&UVM_PHYSICAL)) || \
                        (__m_uvm_status_container.comparer.abstract&&((FLAG)&UVM_ABSTRACT)) || \
                        (!((FLAG)&UVM_PHYSICAL) && !((FLAG)&UVM_ABSTRACT)) ) \
                 __m_uvm_status_container.comparer.result++; \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          foreach(ARG[i])  \
            __m_uvm_status_container.packer.pack_field_int(int'(ARG[i]), $bits(ARG[i])); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          foreach(ARG[i]) \
            ARG[i] = T'(__m_uvm_status_container.packer.unpack_field_int($bits(ARG[i]))); \
        end \
      UVM_RECORD: \
        `m_uvm_record_qda_enum(ARG, FLAG, $size(ARG)) \
      UVM_PRINT: \
        begin \
          if(((FLAG)&UVM_NOPRINT) == 0) begin \
             `uvm_print_qda_enum(ARG, __m_uvm_status_container.printer, array, T) \
          end \
        end \
      UVM_SETINT: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              uvm_report_warning("RDONLY", $sformatf("%s: static arrays cannot be resized via configuraton.",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
          end \
          else if(!((FLAG)&UVM_READONLY)) begin \
            foreach(ARG[i]) begin \
              __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
              if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                ARG[i] =  T'(uvm_object::__m_uvm_status_container.bitstream); \
                __m_uvm_status_container.status = 1; \
              end \
            end \
          end \
        end \
      UVM_SETSTR: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              uvm_report_warning("RDONLY", {__m_uvm_status_container.get_full_scope_arg(), \
              ": static arrays cannot be resized via configuraton."}, UVM_NONE); \
            end \
          end \
          else if(!((FLAG)&UVM_READONLY)) begin \
            foreach(ARG[i]) begin \
              __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
              if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
	              T t__;  \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                void'(uvm_enum_wrapper#(T)::from_name(uvm_object::__m_uvm_status_container.stringv, t__)); ARG[i]=t__;\
                __m_uvm_status_container.status = 1; \
              end \
            end \
          end \
        end \
    endcase \
  end





`define M_UVM_QUEUE_RESIZE(ARG,VAL) \
  while(ARG.size()<sz) ARG.push_back(VAL); \
  while(ARG.size()>sz) void'(ARG.pop_front()); \



`define M_UVM_ARRAY_RESIZE(ARG,VAL) \
  ARG = new[sz](ARG); \



`define M_UVM_SARRAY_RESIZE(ARG,VAL) \



`define M_UVM_FIELD_QDA_INT(TYPE,ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if (local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) ARG = local_data__.ARG; \
        end \
      UVM_COMPARE: \
        begin \
          if (local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(ARG !== local_data__.ARG) begin \
               if(__m_uvm_status_container.comparer.show_max == 1) begin \
                 __m_uvm_status_container.scope.set_arg(`"ARG`"); \
                 __m_uvm_status_container.comparer.print_msg(""); \
               end \
               else if(__m_uvm_status_container.comparer.show_max) begin \
                  if(ARG.size() != local_data__.ARG.size()) begin \
                    void'(__m_uvm_status_container.comparer.compare_field(`"ARG``.size`", ARG.size(), local_data__.ARG.size(), 32)); \
                  end \
                 else begin \
                   foreach(ARG[i]) begin \
                     if(ARG[i] !== local_data__.ARG[i]) begin \
                       __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
                       void'(__m_uvm_status_container.comparer.compare_field("", ARG[i], local_data__.ARG[i], $bits(ARG[i]))); \
                     end \
                   end \
                 end \
               end \
               else if ((__m_uvm_status_container.comparer.physical&&((FLAG)&UVM_PHYSICAL)) || \
                        (__m_uvm_status_container.comparer.abstract&&((FLAG)&UVM_ABSTRACT)) || \
                        (!((FLAG)&UVM_PHYSICAL) && !((FLAG)&UVM_ABSTRACT)) ) \
                 __m_uvm_status_container.comparer.result++; \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
           if(__m_uvm_status_container.packer.use_metadata) __m_uvm_status_container.packer.pack_field_int(ARG.size(), 32); \
          foreach(ARG[i])  \
            if($bits(ARG[i]) <= 64) __m_uvm_status_container.packer.pack_field_int(ARG[i], $bits(ARG[i])); \
            else __m_uvm_status_container.packer.pack_field(ARG[i], $bits(ARG[i])); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
           int sz = ARG.size(); \
           if(__m_uvm_status_container.packer.use_metadata) sz = __m_uvm_status_container.packer.unpack_field_int(32); \
          if(sz != ARG.size()) begin \
          `M_UVM_``TYPE``_RESIZE (ARG,0) \
          end \
          foreach(ARG[i]) \
            if($bits(ARG[i]) <= 64) ARG[i] = __m_uvm_status_container.packer.unpack_field_int($bits(ARG[i])); \
            else ARG[i] = __m_uvm_status_container.packer.unpack_field($bits(ARG[i])); \
        end \
      UVM_RECORD: \
        `m_uvm_record_qda_int(ARG, FLAG, ARG.size()) \
      UVM_PRINT: \
        begin \
          if(((FLAG)&UVM_NOPRINT) == 0) begin \
             `uvm_print_array_int3(ARG, uvm_radix_enum'((FLAG)&(UVM_RADIX)), \
                                   __m_uvm_status_container.printer) \
          end \
        end \
      UVM_SETINT: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
             else begin \
               int sz =  uvm_object::__m_uvm_status_container.bitstream; \
               if (__m_uvm_status_container.print_matches) \
              uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
               if(ARG.size() !=  sz) begin \
                 `M_UVM_``TYPE``_RESIZE(ARG,0) \
               end \
               __m_uvm_status_container.status = 1; \
             end \
          end \
          else if(!((FLAG)&UVM_READONLY)) begin \
            bit wildcard_index__; \
            int index__; \
            index__ = uvm_get_array_index_int(str__, wildcard_index__); \
            if(uvm_is_array(str__)  && (index__ != -1)) begin\
              if(wildcard_index__) begin \
                for(index__=0; index__<ARG.size(); ++index__) begin \
                  if(uvm_is_match(str__, {__m_uvm_status_container.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
                    if (__m_uvm_status_container.print_matches) \
                      uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg(), $sformatf("[%0d]",index__)}, UVM_LOW); \
                    ARG[index__] = uvm_object::__m_uvm_status_container.bitstream; \
                    __m_uvm_status_container.status = 1; \
                  end \
                end \
              end \
              else if(uvm_is_match(str__, {__m_uvm_status_container.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
                if(index__+1 > ARG.size()) begin \
                  int sz = index__; \
                  int tmp__; \
                  `M_UVM_``TYPE``_RESIZE(ARG,tmp__) \
                end \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                ARG[index__] =  uvm_object::__m_uvm_status_container.bitstream; \
                __m_uvm_status_container.status = 1; \
              end \
            end \
          end \
        end \
    endcase \
  end



`define uvm_field_array_int(ARG,FLAG) \
   `M_UVM_FIELD_QDA_INT(ARRAY,ARG,FLAG) 



`define uvm_field_array_object(ARG,FLAG) \
  `M_UVM_FIELD_QDA_OBJECT(ARRAY,ARG,FLAG)

`define M_UVM_FIELD_QDA_OBJECT(TYPE,ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) begin \
            if(((FLAG)&UVM_REFERENCE)) \
              ARG = local_data__.ARG; \
            else begin \
              int sz = local_data__.ARG.size(); \
              `M_UVM_``TYPE``_RESIZE(ARG,null) \
              foreach(ARG[i]) begin \
                if(ARG[i] != null && local_data__.ARG[i] != null) \
                  ARG[i].copy(local_data__.ARG[i]); \
                else if(ARG[i] == null && local_data__.ARG[i] != null) \
                  $cast(ARG[i], local_data__.ARG[i].clone()); \
                else \
                  ARG[i] = null; \
              end \
            end \
          end \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(((FLAG)&UVM_REFERENCE) && (__m_uvm_status_container.comparer.show_max <= 1) && (ARG !== local_data__.ARG) ) begin \
               if(__m_uvm_status_container.comparer.show_max == 1) begin \
                 __m_uvm_status_container.scope.set_arg(`"ARG`"); \
                 __m_uvm_status_container.comparer.print_msg(""); \
               end \
               else if ((__m_uvm_status_container.comparer.physical&&((FLAG)&UVM_PHYSICAL)) || \
                        (__m_uvm_status_container.comparer.abstract&&((FLAG)&UVM_ABSTRACT)) || \
                        (!((FLAG)&UVM_PHYSICAL) && !((FLAG)&UVM_ABSTRACT)) ) \
                 __m_uvm_status_container.comparer.result++; \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
            else begin \
              string s; \
              if(ARG.size() != local_data__.ARG.size()) begin \
                __m_uvm_status_container.scope.set_arg(`"ARG`"); \
                __m_uvm_status_container.comparer.print_msg($sformatf("size mismatch: lhs: %0d  rhs: %0d", ARG.size(), local_data__.ARG.size())); \
              	if(__m_uvm_status_container.comparer.show_max == 1) return; \
              end \
              for(int i=0; i<ARG.size() && i<local_data__.ARG.size(); ++i) begin \
                if(ARG[i] != null && local_data__.ARG[i] != null) begin \
                  $swrite(s,`"ARG[%0d]`",i); \
                  void'(__m_uvm_status_container.comparer.compare_object(s, ARG[i], local_data__.ARG[i])); \
                end \
                if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
              end \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          if(__m_uvm_status_container.packer.use_metadata) __m_uvm_status_container.packer.pack_field_int(ARG.size(), 32); \
          foreach(ARG[i])  \
            __m_uvm_status_container.packer.pack_object(ARG[i]); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          int sz = ARG.size(); \
          if(__m_uvm_status_container.packer.use_metadata) sz = __m_uvm_status_container.packer.unpack_field_int(32); \
          if(sz != ARG.size()) begin \
            `M_UVM_``TYPE``_RESIZE(ARG,null) \
          end \
          foreach(ARG[i]) \
            __m_uvm_status_container.packer.unpack_object(ARG[i]); \
        end \
      UVM_RECORD: \
        `m_uvm_record_qda_object(ARG,FLAG,ARG.size()) \
      UVM_PRINT: \
        begin \
          if(((FLAG)&UVM_NOPRINT) == 0) begin \
             `uvm_print_array_object3(ARG, __m_uvm_status_container.printer,FLAG) \
          end \
        end \
      UVM_SETINT: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              int sz =  uvm_object::__m_uvm_status_container.bitstream; \
              if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
              if(ARG.size() !=  sz) begin \
                `M_UVM_``TYPE``_RESIZE(ARG,null) \
              end \
              __m_uvm_status_container.status = 1; \
            end \
          end \
          else if(!((FLAG)&UVM_READONLY)) begin \
            foreach(ARG[i]) begin \
              string s; \
              $swrite(s,`"ARG[%0d]`",i); \
              __m_uvm_status_container.scope.set_arg(s); \
              if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
		 uvm_report_warning("STRMTC", {"set_int()", ": Match ignored for string ", str__, ". Cannot set object to int value."}); \
              end \
              else if(ARG[i]!=null && !((FLAG)&UVM_REFERENCE)) begin \
                int cnt; \
                for(cnt=0; cnt<str__.len(); ++cnt) begin \
                  if(str__[cnt] == "." || str__[cnt] == "*") break; \
                end \
                if(cnt!=str__.len()) begin \
                  __m_uvm_status_container.scope.down(s); \
                  ARG[i].__m_uvm_field_automation(null, UVM_SETINT, str__); \
                  __m_uvm_status_container.scope.up(); \
                end \
              end \
            end \
          end \
        end \
      UVM_SETSTR: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
                  uvm_report_warning("STRMTC", {"set_str()", ": Match ignored for string ", str__, ". Cannot set array of objects to string value."}); \
            end \
          end \
          else if(!((FLAG)&UVM_READONLY)) begin \
            foreach(ARG[i]) begin \
              string s; \
              $swrite(s,`"ARG[%0d]`",i); \
              __m_uvm_status_container.scope.set_arg(s); \
              if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
                  uvm_report_warning("STRMTC", {"set_str()", ": Match ignored for string ", str__, ". Cannot set object to string value."}); \
              end \
              else if(ARG[i]!=null && !((FLAG)&UVM_REFERENCE)) begin \
                int cnt; \
                for(cnt=0; cnt<str__.len(); ++cnt) begin \
                  if(str__[cnt] == "." || str__[cnt] == "*") break; \
                end \
                if(cnt!=str__.len()) begin \
                  __m_uvm_status_container.scope.down(s); \
                  ARG[i].__m_uvm_field_automation(null, UVM_SETSTR, str__); \
                  __m_uvm_status_container.scope.up(); \
                end \
              end \
            end \
          end \
        end \
      UVM_SETOBJ: \
        begin \
          string s; \
          if(!((FLAG)&UVM_READONLY)) begin \
            bit wildcard_index__; \
            int index__; \
            __m_uvm_status_container.scope.set_arg(`"ARG`"); \
            index__ = uvm_get_array_index_int(str__, wildcard_index__); \
            if(uvm_is_array(str__)  && (index__ != -1)) begin\
              if(wildcard_index__) begin \
                for(index__=0; index__<ARG.size(); ++index__) begin \
                  if(uvm_is_match(str__, {__m_uvm_status_container.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
                    if (__m_uvm_status_container.print_matches) \
                      uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg(), $sformatf("[%0d]",index__)}, UVM_LOW); \
                    $cast(ARG[index__], uvm_object::__m_uvm_status_container.object); \
                    __m_uvm_status_container.status = 1; \
                  end \
                end \
              end \
              else if(uvm_is_match(str__, {__m_uvm_status_container.get_full_scope_arg(),$sformatf("[%0d]", index__)})) begin \
                if(index__+1 > ARG.size()) begin \
                  int sz = index__+1; \
                  `M_UVM_``TYPE``_RESIZE(ARG,null) \
                end \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                $cast(ARG[index__],  uvm_object::__m_uvm_status_container.object); \
                __m_uvm_status_container.status = 1; \
              end \
            end \
            else if(!((FLAG)&UVM_REFERENCE)) begin \
              int cnt; \
              foreach(ARG[i]) begin \
                if (ARG[i]!=null) begin \
                  string s; \
                  $swrite(s,`"ARG[%0d]`",i); \
                for(cnt=0; cnt<str__.len(); ++cnt) begin \
                  if(str__[cnt] == "." || str__[cnt] == "*") break; \
                end \
                if(cnt!=str__.len()) begin \
                  __m_uvm_status_container.scope.down(s); \
                  ARG[i].__m_uvm_field_automation(null, UVM_SETOBJ, str__); \
                  __m_uvm_status_container.scope.up(); \
                end \
              end \
            end \
          end \
        end \
        end \
    endcase \
  end 



`define uvm_field_array_string(ARG,FLAG) \
  `M_UVM_FIELD_QDA_STRING(ARRAY,ARG,FLAG)

`define M_UVM_FIELD_QDA_STRING(TYPE,ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOPY)) ARG = local_data__.ARG; \
        end \
      UVM_COMPARE: \
        begin \
          if(local_data__ == null) return; \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(ARG != local_data__.ARG) begin \
               if(__m_uvm_status_container.comparer.show_max == 1) begin \
                 __m_uvm_status_container.scope.set_arg(`"ARG`"); \
                 __m_uvm_status_container.comparer.print_msg(""); \
               end \
               else if(__m_uvm_status_container.comparer.show_max) begin \
                 if(ARG.size() != local_data__.ARG.size()) begin \
                   void'(__m_uvm_status_container.comparer.compare_field(`"ARG``.size`", ARG.size(), local_data__.ARG.size(), 32)); \
                 end \
                 else begin \
                   foreach(ARG[i]) begin \
                     if(ARG[i] != local_data__.ARG[i]) begin \
                       __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
                       void'(__m_uvm_status_container.comparer.compare_string("", ARG[i], local_data__.ARG[i])); \
                     end \
                   end \
                 end \
               end \
               else if ((__m_uvm_status_container.comparer.physical&&((FLAG)&UVM_PHYSICAL)) || \
                        (__m_uvm_status_container.comparer.abstract&&((FLAG)&UVM_ABSTRACT)) || \
                        (!((FLAG)&UVM_PHYSICAL) && !((FLAG)&UVM_ABSTRACT)) ) \
                 __m_uvm_status_container.comparer.result++; \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          if(__m_uvm_status_container.packer.use_metadata) __m_uvm_status_container.packer.pack_field_int(ARG.size(), 32); \
          foreach(ARG[i])  \
            __m_uvm_status_container.packer.pack_string(ARG[i]); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          int sz = ARG.size(); \
          if(__m_uvm_status_container.packer.use_metadata) sz = __m_uvm_status_container.packer.unpack_field_int(32); \
          if(sz != ARG.size()) begin \
            `M_UVM_``TYPE``_RESIZE(ARG,"") \
          end \
          foreach(ARG[i]) \
            ARG[i] = __m_uvm_status_container.packer.unpack_string(); \
        end \
      UVM_RECORD: \
        `m_uvm_record_qda_string(ARG,FLAG,ARG.size()) \
      UVM_PRINT: \
        begin \
          if(((FLAG)&UVM_NOPRINT) == 0) begin \
             `uvm_print_array_string2(ARG, __m_uvm_status_container.printer) \
          end \
        end \
      UVM_SETINT: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              int sz =  uvm_object::__m_uvm_status_container.bitstream; \
              if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
              if(ARG.size() !=  sz) begin \
                `M_UVM_``TYPE``_RESIZE(ARG,"") \
              end \
              __m_uvm_status_container.status = 1; \
            end \
          end \
        end \
      UVM_SETSTR: \
        begin \
          if(!((FLAG)&UVM_READONLY)) begin \
            bit wildcard_index__; \
            int index__; \
            __m_uvm_status_container.scope.set_arg(`"ARG`"); \
            index__ = uvm_get_array_index_int(str__, wildcard_index__); \
            if(uvm_is_array(str__)  && (index__ != -1)) begin\
              if(wildcard_index__) begin \
                for(index__=0; index__<ARG.size(); ++index__) begin \
                  if(uvm_is_match(str__, {__m_uvm_status_container.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
                    if (__m_uvm_status_container.print_matches) \
                      uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg(), $sformatf("[%0d]",index__)}, UVM_LOW); \
                    ARG[index__] = uvm_object::__m_uvm_status_container.stringv; \
                    __m_uvm_status_container.status = 1; \
                  end \
                end \
              end \
              else if(uvm_is_match(str__, {__m_uvm_status_container.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
                if(index__+1 > ARG.size()) begin \
                  int sz = index__; \
                  string tmp__; \
                  `M_UVM_``TYPE``_RESIZE(ARG,tmp__) \
                end \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                ARG[index__] =  uvm_object::__m_uvm_status_container.stringv; \
                __m_uvm_status_container.status = 1; \
              end \
            end \
          end \
        end \
    endcase \
  end




`define uvm_field_array_enum(T,ARG,FLAG) \
  `M_FIELD_QDA_ENUM(ARRAY,T,ARG,FLAG) 

`define M_FIELD_QDA_ENUM(TYPE,T,ARG,FLAG) \
  begin \
    case (what__) \
      UVM_CHECK_FIELDS: \
        __m_uvm_status_container.do_field_check(`"ARG`", this); \
      UVM_COPY: \
        begin \
          if(!((FLAG)&UVM_NOCOPY)) ARG = local_data__.ARG; \
        end \
      UVM_COMPARE: \
        begin \
          if(!((FLAG)&UVM_NOCOMPARE)) begin \
            if(ARG !== local_data__.ARG) begin \
               if(__m_uvm_status_container.comparer.show_max == 1) begin \
                 __m_uvm_status_container.scope.set_arg(`"ARG`"); \
                 __m_uvm_status_container.comparer.print_msg(""); \
               end \
               else if(__m_uvm_status_container.comparer.show_max) begin \
                 if(ARG.size() != local_data__.ARG.size()) begin \
                   void'(__m_uvm_status_container.comparer.compare_field(`"ARG``.size`", ARG.size(), local_data__.ARG.size(), 32)); \
                 end \
                 else begin \
                   foreach(ARG[i]) begin \
                     if(ARG[i] !== local_data__.ARG[i]) begin \
                       __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
                       $swrite(__m_uvm_status_container.stringv, "lhs = %0s : rhs = %0s", \
                         ARG[i].name(), local_data__.ARG[i].name()); \
                       __m_uvm_status_container.comparer.print_msg(__m_uvm_status_container.stringv); \
                       if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
                     end \
                   end \
                 end \
               end \
               else if ((__m_uvm_status_container.comparer.physical&&((FLAG)&UVM_PHYSICAL)) || \
                        (__m_uvm_status_container.comparer.abstract&&((FLAG)&UVM_ABSTRACT)) || \
                        (!((FLAG)&UVM_PHYSICAL) && !((FLAG)&UVM_ABSTRACT)) ) \
                 __m_uvm_status_container.comparer.result++; \
               if(__m_uvm_status_container.comparer.result && (__m_uvm_status_container.comparer.show_max <= __m_uvm_status_container.comparer.result)) return; \
            end \
          end \
        end \
      UVM_PACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          if(__m_uvm_status_container.packer.use_metadata) __m_uvm_status_container.packer.pack_field_int(ARG.size(), 32); \
          foreach(ARG[i])  \
            __m_uvm_status_container.packer.pack_field_int(int'(ARG[i]), $bits(ARG[i])); \
        end \
      UVM_UNPACK: \
        if(!((FLAG)&UVM_NOPACK)) begin \
          int sz = ARG.size(); \
          if(__m_uvm_status_container.packer.use_metadata) sz = __m_uvm_status_container.packer.unpack_field_int(32); \
          if(sz != ARG.size()) begin \
            T tmp__; \
            `M_UVM_``TYPE``_RESIZE(ARG,tmp__) \
          end \
          foreach(ARG[i]) \
            ARG[i] = T'(__m_uvm_status_container.packer.unpack_field_int($bits(ARG[i]))); \
        end \
      UVM_RECORD: \
        `m_uvm_record_qda_enum(ARG,FLAG,ARG.size()) \
      UVM_PRINT: \
        begin \
          if(((FLAG)&UVM_NOPRINT) == 0) begin \
             `uvm_print_qda_enum(ARG, __m_uvm_status_container.printer, array, T) \
          end \
        end \
      UVM_SETINT: \
        begin \
          __m_uvm_status_container.scope.set_arg(`"ARG`"); \
          if(uvm_is_match(str__, __m_uvm_status_container.scope.get())) begin \
            if((FLAG)&UVM_READONLY) begin \
              uvm_report_warning("RDONLY", $sformatf("Readonly argument match %s is ignored",  \
                 __m_uvm_status_container.get_full_scope_arg()), UVM_NONE); \
            end \
            else begin \
              int sz =  uvm_object::__m_uvm_status_container.bitstream; \
              if (__m_uvm_status_container.print_matches) \
              uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
              if(ARG.size() !=  sz) begin \
                T tmp__; \
                `M_UVM_``TYPE``_RESIZE(ARG,tmp__) \
              end \
              __m_uvm_status_container.status = 1; \
            end \
          end \
          else if(!((FLAG)&UVM_READONLY)) begin \
            bit wildcard_index__; \
            int index__; \
            index__ = uvm_get_array_index_int(str__, wildcard_index__); \
            if(uvm_is_array(str__)  && (index__ != -1)) begin\
              if(wildcard_index__) begin \
                for(index__=0; index__<ARG.size(); ++index__) begin \
                  if(uvm_is_match(str__, {__m_uvm_status_container.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
                    if (__m_uvm_status_container.print_matches) \
                      uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg(), $sformatf("[%0d]",index__)}, UVM_LOW); \
                    ARG[index__] = T'(uvm_object::__m_uvm_status_container.bitstream); \
                    __m_uvm_status_container.status = 1; \
                  end \
                end \
              end \
              else if(uvm_is_match(str__, {__m_uvm_status_container.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
                if(index__+1 > ARG.size()) begin \
                  int sz = index__; \
                  T tmp__; \
                  `M_UVM_``TYPE``_RESIZE(ARG,tmp__) \
                end \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                ARG[index__] =  T'(uvm_object::__m_uvm_status_container.bitstream); \
                __m_uvm_status_container.status = 1; \
              end \
            end \
          end \
        end \
      UVM_SETSTR: \
        begin \
          if(!((FLAG)&UVM_READONLY)) begin \
            bit wildcard_index__; \
            int index__; \
            __m_uvm_status_container.scope.set_arg(`"ARG`"); \
            index__ = uvm_get_array_index_int(str__, wildcard_index__); \
            if(uvm_is_array(str__)  && (index__ != -1)) begin\
              if(wildcard_index__) begin \
                for(index__=0; index__<ARG.size(); ++index__) begin \
                  if(uvm_is_match(str__, {__m_uvm_status_container.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
	                  T t__; \
                    if (__m_uvm_status_container.print_matches) \
                      uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg(), $sformatf("[%0d]",index__)}, UVM_LOW); \
                    void'(uvm_enum_wrapper#(T)::from_name(uvm_object::__m_uvm_status_container.stringv, t__)); ARG[index__]=t__; \
                    __m_uvm_status_container.status = 1; \
                  end \
                end \
              end \
              else if(uvm_is_match(str__, {__m_uvm_status_container.scope.get_arg(),$sformatf("[%0d]", index__)})) begin \
	            T t__; \
                if(index__+1 > ARG.size()) begin \
                  int sz = index__; \
                  T tmp__; \
                  `M_UVM_``TYPE``_RESIZE(ARG,tmp__) \
                end \
                if (__m_uvm_status_container.print_matches) \
                  uvm_report_info("STRMTC", {"set_int()", ": Matched string ", str__, " to field ", __m_uvm_status_container.get_full_scope_arg()}, UVM_LOW); \
                void'(uvm_enum_wrapper#(T)::from_name(uvm_object::__m_uvm_status_container.stringv, t__)); ARG[index__]=t__; \
                __m_uvm_status_container.status = 1; \
              end \
            end \
          end \
        end \
    endcase \
  end




`define uvm_field_queue_int(ARG,FLAG) \
  `M_UVM_FIELD_QDA_INT(QUEUE,ARG,FLAG)


`define uvm_field_queue_object(ARG,FLAG) \
  `M_UVM_FIELD_QDA_OBJECT(QUEUE,ARG,FLAG)



`define uvm_field_queue_string(ARG,FLAG) \
  `M_UVM_FIELD_QDA_STRING(QUEUE,ARG,FLAG)



`define uvm_field_queue_enum(T,ARG,FLAG) \
  `M_FIELD_QDA_ENUM(QUEUE,T,ARG,FLAG)




`define uvm_field_aa_int_string(ARG, FLAG) \
  begin \
  if(what__==UVM_CHECK_FIELDS) __m_uvm_status_container.do_field_check(`"ARG`", this); \
  `M_UVM_FIELD_DATA_AA_int_string(ARG,FLAG) \
  `M_UVM_FIELD_SET_AA_TYPE(string, INT, ARG, __m_uvm_status_container.bitstream, FLAG)  \
  end



`define uvm_field_aa_object_string(ARG, FLAG) \
  begin \
  if(what__==UVM_CHECK_FIELDS) __m_uvm_status_container.do_field_check(`"ARG`", this); \
  `M_UVM_FIELD_DATA_AA_object_string(ARG,FLAG) \
  `M_UVM_FIELD_SET_AA_OBJECT_TYPE(string, ARG, FLAG)  \
  end



`define uvm_field_aa_string_string(ARG, FLAG) \
  begin \
  if(what__==UVM_CHECK_FIELDS) __m_uvm_status_container.do_field_check(`"ARG`", this); \
  `M_UVM_FIELD_DATA_AA_string_string(ARG,FLAG) \
  `M_UVM_FIELD_SET_AA_TYPE(string, STR, ARG, __m_uvm_status_container.stringv, FLAG)  \
  end




`define uvm_field_aa_object_int(ARG, FLAG) \
  begin \
  if(what__==UVM_CHECK_FIELDS) __m_uvm_status_container.do_field_check(`"ARG`", this); \
  `M_UVM_FIELD_DATA_AA_object_int(ARG,FLAG) \
  `M_UVM_FIELD_SET_AA_OBJECT_TYPE(int, ARG, FLAG)  \
  end



`define uvm_field_aa_int_int(ARG, FLAG) \
  `uvm_field_aa_int_key(int, ARG, FLAG) \



`define uvm_field_aa_int_int_unsigned(ARG, FLAG) \
  `uvm_field_aa_int_key(int unsigned, ARG, FLAG)



`define uvm_field_aa_int_integer(ARG, FLAG) \
  `uvm_field_aa_int_key(integer, ARG, FLAG)



`define uvm_field_aa_int_integer_unsigned(ARG, FLAG) \
  `uvm_field_aa_int_key(integer unsigned, ARG, FLAG)



`define uvm_field_aa_int_byte(ARG, FLAG) \
  `uvm_field_aa_int_key(byte, ARG, FLAG)



`define uvm_field_aa_int_byte_unsigned(ARG, FLAG) \
  `uvm_field_aa_int_key(byte unsigned, ARG, FLAG)



`define uvm_field_aa_int_shortint(ARG, FLAG) \
  `uvm_field_aa_int_key(shortint, ARG, FLAG)



`define uvm_field_aa_int_shortint_unsigned(ARG, FLAG) \
  `uvm_field_aa_int_key(shortint unsigned, ARG, FLAG)



`define uvm_field_aa_int_longint(ARG, FLAG) \
  `uvm_field_aa_int_key(longint, ARG, FLAG)



`define uvm_field_aa_int_longint_unsigned(ARG, FLAG) \
  `uvm_field_aa_int_key(longint unsigned, ARG, FLAG)



`define uvm_field_aa_int_key(KEY, ARG, FLAG) \
  begin \
  if(what__==UVM_CHECK_FIELDS) __m_uvm_status_container.do_field_check(`"ARG`", this); \
  `M_UVM_FIELD_DATA_AA_int_key(KEY,ARG,FLAG) \
  `M_UVM_FIELD_SET_AA_INT_TYPE(KEY, INT, ARG, __m_uvm_status_container.bitstream, FLAG)  \
  end



`define uvm_field_aa_int_enumkey(KEY, ARG, FLAG) \
  begin \
  if(what__==UVM_CHECK_FIELDS) __m_uvm_status_container.do_field_check(`"ARG`", this); \
  `M_UVM_FIELD_DATA_AA_enum_key(KEY,ARG,FLAG) \
  `M_UVM_FIELD_SET_AA_INT_ENUMTYPE(KEY, INT, ARG, __m_uvm_status_container.bitstream, FLAG)  \
  end



`define m_uvm_print_int(ARG,FLAG) \
  if(!((FLAG)&UVM_NOPRINT)) begin \
     if ($bits(ARG) > 64) \
      __m_uvm_status_container.printer.print_field(`"ARG`", ARG,  $bits(ARG), uvm_radix_enum'((FLAG)&(UVM_RADIX))); \
     else \
      __m_uvm_status_container.printer.print_field_int(`"ARG`", ARG,  $bits(ARG), uvm_radix_enum'((FLAG)&(UVM_RADIX))); \
  end




`define m_uvm_record_int(ARG,FLAG) \
  if(!((FLAG)&UVM_NORECORD)) begin \
    if ($bits(ARG) > 64) \
      __m_uvm_status_container.recorder.record_field(`"ARG`", ARG,  $bits(ARG), uvm_radix_enum'((FLAG)&(UVM_RADIX))); \
    else \
      __m_uvm_status_container.recorder.record_field_int(`"ARG`", ARG,  $bits(ARG), uvm_radix_enum'((FLAG)&(UVM_RADIX))); \
  end



      

`define m_uvm_record_string(ARG,STR,FLAG) \
  if(!((FLAG)&UVM_NORECORD)) begin \
    __m_uvm_status_container.recorder.record_string(`"ARG`", STR); \
  end





`define m_uvm_record_object(ARG,FLAG) \
  if(!((FLAG)&UVM_NORECORD)) begin \
    __m_uvm_status_container.recorder.record_object(`"ARG`", ARG); \
  end



`define m_uvm_record_qda_int(ARG, FLAG, SZ) \
  begin \
    if(!((FLAG)&UVM_NORECORD)) begin \
      int sz__ = SZ; \
      if(sz__ == 0) begin \
        __m_uvm_status_container.recorder.record_field_int(`"ARG`", 0, 32, UVM_DEC); \
      end \
      else if(sz__ < 10) begin \
        foreach(ARG[i]) begin \
           __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
           if ($bits(ARG[i]) > 64) \
             __m_uvm_status_container.recorder.record_field(__m_uvm_status_container.scope.get(), ARG[i], $bits(ARG[i]), uvm_radix_enum'((FLAG)&UVM_RADIX)); \
           else \
             __m_uvm_status_container.recorder.record_field_int(__m_uvm_status_container.scope.get(), ARG[i], $bits(ARG[i]), uvm_radix_enum'((FLAG)&UVM_RADIX)); \
        end \
      end \
      else begin \
        for(int i=0; i<5; ++i) begin \
           __m_uvm_status_container.scope.set_arg_element(`"ARG`", i); \
           if ($bits(ARG[i]) > 64) \
             __m_uvm_status_container.recorder.record_field(__m_uvm_status_container.scope.get(), ARG[i], $bits(ARG[i]), uvm_radix_enum'((FLAG)&UVM_RADIX)); \
           else \
             __m_uvm_status_container.recorder.record_field_int(__m_uvm_status_container.scope.get(), ARG[i], $bits(ARG[i]), uvm_radix_enum'((FLAG)&UVM_RADIX)); \
        end \
        for(int i=sz__-5; i<sz__; ++i) begin \
           __m_uvm_status_container.scope.set_arg_element(`"ARG`", i); \
           if ($bits(ARG[i]) > 64) \
             __m_uvm_status_container.recorder.record_field(__m_uvm_status_container.scope.get(), ARG[i], $bits(ARG[i]), uvm_radix_enum'((FLAG)&UVM_RADIX)); \
           else \
             __m_uvm_status_container.recorder.record_field_int(__m_uvm_status_container.scope.get(), ARG[i], $bits(ARG[i]), uvm_radix_enum'((FLAG)&UVM_RADIX)); \
        end \
      end \
    end \
  end



`define m_uvm_record_qda_enum(ARG, FLAG, SZ) \
  begin \
    if(!((FLAG)&UVM_NORECORD) && (__m_uvm_status_container.recorder != null)) begin \
      int sz__ = SZ; \
      if(sz__ == 0) begin \
        __m_uvm_status_container.recorder.record_field_int(`"ARG``.size`", 0, 32, UVM_DEC); \
      end \
      else if(sz__ < 10) begin \
        foreach(ARG[i]) begin \
           __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
           __m_uvm_status_container.recorder.record_string(__m_uvm_status_container.scope.get(), ARG[i].name()); \
        end \
      end \
      else begin \
        for(int i=0; i<5; ++i) begin \
           __m_uvm_status_container.scope.set_arg_element(`"ARG`", i); \
           __m_uvm_status_container.recorder.record_string(__m_uvm_status_container.scope.get(), ARG[i].name()); \
        end \
        for(int i=sz__-5; i<sz__; ++i) begin \
           __m_uvm_status_container.scope.set_arg_element(`"ARG`", i); \
           __m_uvm_status_container.recorder.record_string(__m_uvm_status_container.scope.get(), ARG[i].name()); \
        end \
      end \
    end \
  end



`define m_uvm_record_qda_object(ARG, FLAG, SZ) \
  begin \
    if(!((FLAG)&UVM_NORECORD)) begin \
      int sz__ = SZ; \
      string s; \
      if(sz__ == 0 ) begin \
        __m_uvm_status_container.recorder.record_field_int(`"ARG``.size`", 0, 32, UVM_DEC); \
      end \
      if(sz__ < 10) begin \
        foreach(ARG[i]) begin \
           $swrite(s,`"ARG[%0d]`", i); \
           __m_uvm_status_container.recorder.record_object(s, ARG[i]); \
        end \
      end \
      else begin \
        for(int i=0; i<5; ++i) begin \
           $swrite(s,`"ARG[%0d]`", i); \
           __m_uvm_status_container.recorder.record_object(s, ARG[i]); \
        end \
        for(int i=sz__-5; i<sz__; ++i) begin \
           $swrite(s,`"ARG[%0d]`", i); \
           __m_uvm_status_container.recorder.record_object(s, ARG[i]); \
        end \
      end \
    end \
  end



`define m_uvm_record_qda_string(ARG, FLAG, SZ) \
  begin \
    int sz__ = SZ; \
    if(!((FLAG)&UVM_NORECORD)) begin \
      if(sz__ == 0) begin \
        __m_uvm_status_container.recorder.record_field_int(`"ARG``.size`", 0, 32, UVM_DEC); \
      end \
      else if(sz__ < 10) begin \
        foreach(ARG[i]) begin \
           __m_uvm_status_container.scope.set_arg_element(`"ARG`",i); \
           __m_uvm_status_container.recorder.record_string(__m_uvm_status_container.scope.get(), ARG[i]); \
        end \
      end \
      else begin \
        for(int i=0; i<5; ++i) begin \
           __m_uvm_status_container.scope.set_arg_element(`"ARG`", i); \
           __m_uvm_status_container.recorder.record_string(__m_uvm_status_container.scope.get(), ARG[i]); \
        end \
        for(int i=sz__-5; i<sz__; ++i) begin \
           __m_uvm_status_container.scope.set_arg_element(`"ARG`", i); \
           __m_uvm_status_container.recorder.record_string(__m_uvm_status_container.scope.get(), ARG[i]); \
        end \
      end \
    end \
  end



`define M_UVM_FIELD_DATA_AA_generic(TYPE, KEY, ARG, FLAG) \
  begin \
    begin \
      case (what__) \
        UVM_COMPARE: \
           begin \
            if(!((FLAG)&UVM_NOCOMPARE) && (tmp_data__ != null) ) \
            begin \
              $cast(local_data__, tmp_data__); \
              if(ARG.num() != local_data__.ARG.num()) begin \
                 int s1__, s2__; \
                 __m_uvm_status_container.stringv = ""; \
                 s1__ = ARG.num(); s2__ = local_data__.ARG.num(); \
                 $swrite(__m_uvm_status_container.stringv, "lhs size = %0d : rhs size = %0d", \
                    s1__, s2__);\
                 __m_uvm_status_container.comparer.print_msg(__m_uvm_status_container.stringv); \
              end \
              string_aa_key = ""; \
              while(ARG.next(string_aa_key)) begin \
                string s; \
                __m_uvm_status_container.scope.set_arg({"[",string_aa_key,"]"}); \
                s = {`"ARG[`",string_aa_key,"]"}; \
                if($bits(ARG[string_aa_key]) <= 64) \
                  void'(__m_uvm_status_container.comparer.compare_field_int(s, ARG[string_aa_key], local_data__.ARG[string_aa_key], $bits(ARG[string_aa_key]), uvm_radix_enum'((FLAG)&UVM_RADIX))); \
                else \
                  void'(__m_uvm_status_container.comparer.compare_field(s, ARG[string_aa_key], local_data__.ARG[string_aa_key], $bits(ARG[string_aa_key]), uvm_radix_enum'((FLAG)&UVM_RADIX))); \
                __m_uvm_status_container.scope.unset_arg(string_aa_key); \
              end \
            end \
           end \
        UVM_COPY: \
          begin \
            if(!((FLAG)&UVM_NOCOPY) && (tmp_data__ != null) ) \
            begin \
              $cast(local_data__, tmp_data__); \
              ARG.delete(); \
              string_aa_key = ""; \
              while(local_data__.ARG.next(string_aa_key)) \
                ARG[string_aa_key] = local_data__.ARG[string_aa_key]; \
            end \
          end \
        UVM_PRINT: \
          if(!((FLAG)&UVM_NOPRINT)) begin \
            `uvm_print_aa_``KEY``_``TYPE``3(ARG, uvm_radix_enum'((FLAG)&(UVM_RADIX)), \
                                            __m_uvm_status_container.printer) \
          end \
      endcase \
    end \
  end



`define M_UVM_FIELD_DATA_AA_int_string(ARG, FLAG) \
  `M_UVM_FIELD_DATA_AA_generic(int, string, ARG, FLAG)



`define M_UVM_FIELD_DATA_AA_int_key(KEY, ARG, FLAG) \
  begin \
    begin \
      KEY aa_key; \
      case (what__) \
        UVM_COMPARE: \
           begin \
            if(!((FLAG)&UVM_NOCOMPARE) && (tmp_data__ != null) ) \
            begin \
              $cast(local_data__, tmp_data__); \
              if(ARG.num() != local_data__.ARG.num()) begin \
                 int s1__, s2__; \
                 __m_uvm_status_container.stringv = ""; \
                 s1__ = ARG.num(); s2__ = local_data__.ARG.num(); \
                 $swrite(__m_uvm_status_container.stringv, "lhs size = %0d : rhs size = %0d", \
                    s1__, s2__);\
                 __m_uvm_status_container.comparer.print_msg(__m_uvm_status_container.stringv); \
              end \
              foreach(ARG[_aa_key]) begin \
                  string s; \
                  $swrite(string_aa_key, "%0d", _aa_key); \
                  __m_uvm_status_container.scope.set_arg({"[",string_aa_key,"]"}); \
                  s = {`"ARG[`",string_aa_key,"]"}; \
                  if($bits(ARG[_aa_key]) <= 64) \
                    void'(__m_uvm_status_container.comparer.compare_field_int(s, ARG[_aa_key], local_data__.ARG[_aa_key], $bits(ARG[_aa_key]), uvm_radix_enum'((FLAG)&UVM_RADIX))); \
                  else \
                    void'(__m_uvm_status_container.comparer.compare_field(s, ARG[_aa_key], local_data__.ARG[_aa_key], $bits(ARG[_aa_key]), uvm_radix_enum'((FLAG)&UVM_RADIX))); \
                  __m_uvm_status_container.scope.unset_arg(string_aa_key); \
                end \
            end \
           end \
        UVM_COPY: \
          begin \
            if(!((FLAG)&UVM_NOCOPY) && (tmp_data__ != null) ) \
            begin \
              $cast(local_data__, tmp_data__); \
              ARG.delete(); \
              if(local_data__.ARG.first(aa_key)) \
                do begin \
                  ARG[aa_key] = local_data__.ARG[aa_key]; \
                end while(local_data__.ARG.next(aa_key)); \
            end \
          end \
        UVM_PRINT: \
          if(!((FLAG)&UVM_NOPRINT)) begin \
             `uvm_print_aa_int_key4(KEY,ARG, uvm_radix_enum'((FLAG)&(UVM_RADIX)), \
                                    __m_uvm_status_container.printer) \
          end \
      endcase \
    end \
  end



`define M_UVM_FIELD_DATA_AA_enum_key(KEY, ARG, FLAG) \
  begin \
    begin \
      KEY aa_key; \
      case (what__) \
        UVM_COMPARE: \
           begin \
            if(!((FLAG)&UVM_NOCOMPARE) && (tmp_data__ != null) ) \
            begin \
              $cast(local_data__, tmp_data__); \
              if(ARG.num() != local_data__.ARG.num()) begin \
                 int s1__, s2__; \
                 __m_uvm_status_container.stringv = ""; \
                 s1__ = ARG.num(); s2__ = local_data__.ARG.num(); \
                 $swrite(__m_uvm_status_container.stringv, "lhs size = %0d : rhs size = %0d", \
                    s1__, s2__);\
                 __m_uvm_status_container.comparer.print_msg(__m_uvm_status_container.stringv); \
              end \
              foreach(ARG[_aa_key]) begin \
                  void'(__m_uvm_status_container.comparer.compare_field_int({`"ARG[`",_aa_key.name(),"]"}, \
                    ARG[_aa_key], local_data__.ARG[_aa_key], $bits(ARG[_aa_key]), \
                    uvm_radix_enum'((FLAG)&UVM_RADIX) )); \
                end \
            end \
           end \
        UVM_COPY: \
          begin \
            if(!((FLAG)&UVM_NOCOPY) && (tmp_data__ != null) ) \
            begin \
              $cast(local_data__, tmp_data__); \
              ARG=local_data__.ARG; \
            end \
          end \
        UVM_PRINT: \
          if(!((FLAG)&UVM_NOPRINT)) begin \
            uvm_printer p__ = __m_uvm_status_container.printer; \
            p__.print_array_header (`"ARG`", ARG.num(),`"aa_``KEY`"); \
            if((p__.knobs.depth == -1) || (__m_uvm_status_container.printer.m_scope.depth() < p__.knobs.depth+1)) \
            begin \
              foreach(ARG[_aa_key]) \
               begin \
                  if ($bits(ARG[_aa_key]) > 64) \
                    __m_uvm_status_container.printer.print_field( \
                      {"[",_aa_key.name(),"]"}, ARG[_aa_key], $bits(ARG[_aa_key]), \
                      uvm_radix_enum'((FLAG)&UVM_RADIX), "[" ); \
                  else \
                    __m_uvm_status_container.printer.print_field_int( \
                      {"[",_aa_key.name(),"]"}, ARG[_aa_key], $bits(ARG[_aa_key]), \
                      uvm_radix_enum'((FLAG)&UVM_RADIX), "[" ); \
                end \
            end \
            p__.print_array_footer(ARG.num()); \
          end \
      endcase \
    end \
  end 



`define M_UVM_FIELD_DATA_AA_object_string(ARG, FLAG) \
  begin \
    begin \
      case (what__) \
        UVM_COMPARE: \
           begin \
            if(!((FLAG)&UVM_NOCOMPARE) && (tmp_data__ != null) ) \
            begin \
              $cast(local_data__, tmp_data__); \
              if(ARG.num() != local_data__.ARG.num()) begin \
                 int s1__, s2__; \
                 __m_uvm_status_container.stringv = ""; \
                 s1__ = ARG.num(); s2__ = local_data__.ARG.num(); \
                 $swrite(__m_uvm_status_container.stringv, "lhs size = %0d : rhs size = %0d", \
                          s1__, s2__);\
                 __m_uvm_status_container.comparer.print_msg(__m_uvm_status_container.stringv); \
              end \
              string_aa_key = ""; \
              while(ARG.next(string_aa_key)) begin \
                uvm_object lhs; \
                uvm_object rhs; \
                lhs = ARG[string_aa_key]; \
                rhs = local_data__.ARG[string_aa_key]; \
                __m_uvm_status_container.scope.down({"[",string_aa_key,"]"}); \
                if(rhs != lhs) begin \
                  bit refcmp; \
                  refcmp = ((FLAG)& UVM_SHALLOW) && !(__m_uvm_status_container.comparer.policy == UVM_DEEP); \
                  if(!refcmp && !(__m_uvm_status_container.comparer.policy == UVM_REFERENCE)) begin \
                    if(((rhs == null) && (lhs != null)) || ((lhs==null) && (rhs!=null))) begin \
                      __m_uvm_status_container.comparer.print_msg_object(lhs, rhs); \
                    end \
                    else begin \
                      if (lhs != null)  \
                        void'(lhs.compare(rhs, __m_uvm_status_container.comparer)); \
                    end \
                  end \
                  else begin  \
                    __m_uvm_status_container.comparer.print_msg_object(lhs, rhs); \
                  end \
                end \
                __m_uvm_status_container.scope.up_element(); \
              end \
            end \
          end \
        UVM_COPY: \
          begin \
           if(!((FLAG)&UVM_NOCOPY) && (tmp_data__ != null) ) \
           begin \
            $cast(local_data__, tmp_data__); \
            ARG.delete(); \
            foreach(local_data__.ARG[_string_aa_key]) begin\
               if((FLAG)&UVM_REFERENCE) \
                ARG[_string_aa_key] = local_data__.ARG[_string_aa_key]; \
               else begin\
                $cast(ARG[_string_aa_key],local_data__.ARG[_string_aa_key].clone());\
                ARG[_string_aa_key].set_name({`"ARG`","[",_string_aa_key, "]"});\
               end \
             end \
           end \
          end \
        UVM_PRINT: \
          if(!((FLAG)&UVM_NOPRINT)) begin \
            `uvm_print_aa_string_object3(ARG, __m_uvm_status_container.printer,FLAG) \
          end \
      endcase \
    end \
  end



`define M_UVM_FIELD_DATA_AA_object_int(ARG, FLAG) \
  begin \
    int key__; \
    begin \
      case (what__) \
        UVM_COMPARE: \
           begin \
            if(!((FLAG)&UVM_NOCOMPARE) && (tmp_data__ != null) ) \
            begin \
              $cast(local_data__, tmp_data__); \
              if(ARG.num() != local_data__.ARG.num()) begin \
                 int s1__, s2__; \
                 __m_uvm_status_container.stringv = ""; \
                 s1__ = ARG.num(); s2__ = local_data__.ARG.num(); \
                 $swrite(__m_uvm_status_container.stringv, "lhs size = %0d : rhs size = %0d", \
                          s1__, s2__);\
                 __m_uvm_status_container.comparer.print_msg(__m_uvm_status_container.stringv); \
              end \
              foreach(ARG[_key__]) begin \
                  uvm_object lhs; \
                  uvm_object rhs; \
                  lhs = ARG[key__]; \
                  rhs = local_data__.ARG[_key__]; \
                  __m_uvm_status_container.scope.down_element(_key__); \
                  if(rhs != lhs) begin \
                    bit refcmp; \
                    refcmp = ((FLAG)& UVM_SHALLOW) && !(__m_uvm_status_container.comparer.policy == UVM_DEEP); \
                    if(!refcmp && !(__m_uvm_status_container.comparer.policy == UVM_REFERENCE)) begin \
                      if(((rhs == null) && (lhs != null)) || ((lhs==null) && (rhs!=null))) begin \
                        __m_uvm_status_container.comparer.print_msg_object(lhs, rhs); \
                      end \
                      else begin \
                        if (lhs != null)  \
                          void'(lhs.compare(rhs, __m_uvm_status_container.comparer)); \
                      end \
                    end \
                    else begin  \
                      __m_uvm_status_container.comparer.print_msg_object(lhs, rhs); \
                    end \
                  end \
                  __m_uvm_status_container.scope.up_element(); \
              end \
            end \
          end \
        UVM_COPY: \
          begin \
           if(!((FLAG)&UVM_NOCOPY) && (tmp_data__ != null) ) \
           begin \
            $cast(local_data__, tmp_data__); \
            ARG.delete(); \
            foreach(local_data__.ARG[_key__]) begin \
               if((FLAG)&UVM_REFERENCE) \
                ARG[_key__] = local_data__.ARG[_key__]; \
               else begin\
                 uvm_object tmp_obj; \
                 tmp_obj = local_data__.ARG[_key__].clone(); \
                 if(tmp_obj != null) \
                   $cast(ARG[_key__], tmp_obj); \
                 else \
                   ARG[_key__]=null; \
               end \
             end \
           end \
         end \
        UVM_PRINT: \
          if(!((FLAG)&UVM_NOPRINT)) begin \
             `uvm_print_aa_int_object3(ARG, __m_uvm_status_container.printer,FLAG) \
          end \
      endcase \
    end \
  end



`define M_UVM_FIELD_DATA_AA_string_string(ARG, FLAG) \
  begin \
    begin \
      case (what__) \
        UVM_COPY: \
          begin \
            if(!((FLAG)&UVM_NOCOPY) && (local_data__ !=null)) \
              ARG = local_data__.ARG ; \
          end \
        UVM_PRINT: \
          if(!((FLAG)&UVM_NOPRINT)) begin \
            `uvm_print_aa_string_string2(ARG, __m_uvm_status_container.printer) \
          end \
        UVM_COMPARE: \
           begin \
            if(!((FLAG)&UVM_NOCOMPARE) && (tmp_data__ != null) ) \
            begin \
              $cast(local_data__, tmp_data__); \
              if(ARG.num() != local_data__.ARG.num()) begin \
                 int s1__, s2__; \
                 __m_uvm_status_container.stringv = ""; \
                 s1__ = ARG.num(); s2__ = local_data__.ARG.num(); \
                 $swrite(__m_uvm_status_container.stringv, "lhs size = %0d : rhs size = %0d", \
                    s1__, s2__);\
                 __m_uvm_status_container.comparer.print_msg(__m_uvm_status_container.stringv); \
              end \
              string_aa_key = ""; \
              while(ARG.next(string_aa_key)) begin \
                string s__ = ARG[string_aa_key]; \
                __m_uvm_status_container.scope.set_arg({"[",string_aa_key,"]"}); \
                if(ARG[string_aa_key] != local_data__.ARG[string_aa_key]) begin \
                   __m_uvm_status_container.stringv = { "lhs = \"", s__, "\" : rhs = \"", local_data__.ARG[string_aa_key], "\""}; \
                   __m_uvm_status_container.comparer.print_msg(__m_uvm_status_container.stringv); \
                end \
                __m_uvm_status_container.scope.unset_arg(string_aa_key); \
              end \
            end \
           end \
      endcase \
    end \
  end



`define M_UVM_FIELD_SET_AA_TYPE(INDEX_TYPE, ARRAY_TYPE, ARRAY, RHS, FLAG) \
  if((what__ >= UVM_START_FUNCS && what__ <= UVM_END_FUNCS) && (((FLAG)&UVM_READONLY) == 0)) begin \
    bit wildcard_index__; \
    INDEX_TYPE index__; \
    index__ = uvm_get_array_index_``INDEX_TYPE(str__, wildcard_index__); \
    if(what__==UVM_SET``ARRAY_TYPE) \
    begin \
      __m_uvm_status_container.scope.down(`"ARRAY`"); \
      if(uvm_is_array(str__) ) begin\
        if(wildcard_index__) begin \
          if(ARRAY.first(index__)) \
          do begin \
            if(uvm_is_match(str__, {__m_uvm_status_container.scope.get(),$sformatf("[%0d]", index__)}) ||  \
               uvm_is_match(str__, {__m_uvm_status_container.scope.get(),$sformatf("[%0s]", index__)})) begin \
              ARRAY[index__] = RHS; \
              __m_uvm_status_container.status = 1; \
            end \
          end while(ARRAY.next(index__));\
        end \
        else if(uvm_is_match(str__, {__m_uvm_status_container.scope.get(),$sformatf("[%0d]", index__)})) begin \
          ARRAY[index__] = RHS; \
          __m_uvm_status_container.status = 1; \
        end \
        else if(uvm_is_match(str__, {__m_uvm_status_container.scope.get(),$sformatf("[%0s]", index__)})) begin \
          ARRAY[index__] = RHS; \
          __m_uvm_status_container.status = 1; \
        end \
      end \
      __m_uvm_status_container.scope.up(); \
    end \
 end



`define M_UVM_FIELD_SET_AA_OBJECT_TYPE(INDEX_TYPE, ARRAY, FLAG) \
  if((what__ >= UVM_START_FUNCS && what__ <= UVM_END_FUNCS) && (((FLAG)&UVM_READONLY) == 0)) begin \
    bit wildcard_index__; \
    INDEX_TYPE index__; \
    index__ = uvm_get_array_index_``INDEX_TYPE(str__, wildcard_index__); \
    if(what__==UVM_SETOBJ) \
    begin \
      __m_uvm_status_container.scope.down(`"ARRAY`"); \
      if(uvm_is_array(str__) ) begin\
        if(wildcard_index__) begin \
          foreach(ARRAY[_index__]) begin \
            if(uvm_is_match(str__, {__m_uvm_status_container.scope.get(),$sformatf("[%0d]", _index__)}) || \
               uvm_is_match(str__, {__m_uvm_status_container.scope.get(),$sformatf("[%0s]", _index__)})) begin \
              if (__m_uvm_status_container.object != null) \
                $cast(ARRAY[_index__], __m_uvm_status_container.object); \
              __m_uvm_status_container.status = 1; \
            end \
          end \
        end \
        else if(uvm_is_match(str__, {__m_uvm_status_container.scope.get(),$sformatf("[%0d]", index__)})) begin \
          if (__m_uvm_status_container.object != null) \
            $cast(ARRAY[index__], __m_uvm_status_container.object); \
          __m_uvm_status_container.status = 1; \
        end \
        else if(uvm_is_match(str__, {__m_uvm_status_container.scope.get(),$sformatf("[%0s]", index__)})) begin \
          if (__m_uvm_status_container.object != null) \
            $cast(ARRAY[index__], __m_uvm_status_container.object); \
          __m_uvm_status_container.status = 1; \
        end \
      end \
      __m_uvm_status_container.scope.up(); \
    end \
 end



`define M_UVM_FIELD_SET_AA_INT_TYPE(INDEX_TYPE, ARRAY_TYPE, ARRAY, RHS, FLAG) \
  if((what__ >= UVM_START_FUNCS && what__ <= UVM_END_FUNCS) && (((FLAG)&UVM_READONLY) == 0)) begin \
    bit wildcard_index__; \
    INDEX_TYPE index__; \
    string idx__; \
    index__ = uvm_get_array_index_int(str__, wildcard_index__); \
    if(what__==UVM_SET``ARRAY_TYPE) \
    begin \
      __m_uvm_status_container.scope.down(`"ARRAY`"); \
      if(uvm_is_array(str__) ) begin\
        if(wildcard_index__) begin \
          foreach(ARRAY[_index__]) begin \
            $swrite(idx__, __m_uvm_status_container.scope.get(), "[", _index__, "]"); \
            if(uvm_is_match(str__, idx__)) begin \
              ARRAY[_index__] = RHS; \
              __m_uvm_status_container.status = 1; \
            end \
          end \
        end \
        else if(uvm_is_match(str__, {__m_uvm_status_container.scope.get(),$sformatf("[%0d]", index__)})) begin \
          ARRAY[index__] = RHS; \
          __m_uvm_status_container.status = 1; \
        end  \
      end \
      __m_uvm_status_container.scope.up(); \
    end \
 end



`define M_UVM_FIELD_SET_AA_INT_ENUMTYPE(INDEX_TYPE, ARRAY_TYPE, ARRAY, RHS, FLAG) \
  if((what__ >= UVM_START_FUNCS && what__ <= UVM_END_FUNCS) && (((FLAG)&UVM_READONLY) == 0)) begin \
    bit wildcard_index__; \
    INDEX_TYPE index__; \
    string idx__; \
    index__ = INDEX_TYPE'(uvm_get_array_index_int(str__, wildcard_index__)); \
    if(what__==UVM_SET``ARRAY_TYPE) \
    begin \
      __m_uvm_status_container.scope.down(`"ARRAY`"); \
      if(uvm_is_array(str__) ) begin\
        if(wildcard_index__) begin \
          foreach(ARRAY[_index__]) begin \
            $swrite(idx__, __m_uvm_status_container.scope.get(), "[", _index__, "]"); \
            if(uvm_is_match(str__, idx__)) begin \
              ARRAY[_index__] = RHS; \
              __m_uvm_status_container.status = 1; \
            end \
          end \
        end \
        else if(uvm_is_match(str__, {__m_uvm_status_container.scope.get(),$sformatf("[%0d]", index__)})) begin \
          ARRAY[index__] = RHS; \
          __m_uvm_status_container.status = 1; \
        end  \
      end \
      __m_uvm_status_container.scope.up(); \
    end \
 end

`endif 





`ifndef uvm_record_attribute
 `ifdef QUESTA
    `define uvm_record_attribute(TR_HANDLE,NAME,VALUE) \
      $add_attribute(TR_HANDLE,VALUE,NAME);
  `else
    `define uvm_record_attribute(TR_HANDLE,NAME,VALUE) \
      recorder.record_generic(NAME, $sformatf("%p", VALUE)); 
  `endif
`endif


`ifndef uvm_record_int
  `define uvm_record_int(NAME,VALUE,SIZE,RADIX = UVM_NORADIX) \
    if (recorder != null && recorder.is_open()) begin \
      if (recorder.use_record_attribute()) \
        `uvm_record_attribute(recorder.get_record_attribute_handle(),NAME,VALUE) \
      else \
        if (SIZE > 64) \
          recorder.record_field(NAME, VALUE, SIZE, RADIX); \
        else \
          recorder.record_field_int(NAME, VALUE, SIZE, RADIX); \
    end
`endif


`ifndef uvm_record_string
  `define uvm_record_string(NAME,VALUE) \
    if (recorder != null && recorder.is_open()) begin \
      if (recorder.use_record_attribute()) \
        `uvm_record_attribute(recorder.get_record_attribute_handle(),NAME,VALUE) \
      else \
        recorder.record_string(NAME,VALUE); \
    end
`endif

`ifndef uvm_record_time
  `define uvm_record_time(NAME,VALUE) \
    if (recorder != null && recorder.is_open()) begin \
      if (recorder.use_record_attribute()) \
        `uvm_record_attribute(recorder.get_record_attribute_handle(),NAME,VALUE) \
      else \
         recorder.record_time(NAME,VALUE); \
    end
`endif


`ifndef uvm_record_real
  `define uvm_record_real(NAME,VALUE) \
    if (recorder != null && recorder.is_open()) begin \
      if (recorder.use_record_attribute()) \
        `uvm_record_attribute(recorder.get_record_attribute_handle(),NAME,VALUE) \
      else \
        recorder.record_field_real(NAME,VALUE); \
    end
`endif

`define uvm_record_field(NAME,VALUE) \
   if (recorder != null && recorder.is_open()) begin \
     if (recorder.use_record_attribute()) begin \
       `uvm_record_attribute(recorder.get_record_attribute_handle(),NAME,VALUE) \
     end \
     else \
       recorder.record_generic(NAME, $sformatf("%p", VALUE)); \
   end

  



`define uvm_pack_intN(VAR,SIZE) \
  begin \
   int __array[]; \
   begin \
     bit [SIZE-1:0] __vector = VAR; \
     { << int { __array }} = {{($bits(int) - (SIZE % $bits(int))) {1'b0}}, __vector}; \
   end \
   packer.pack_ints(__array, SIZE); \
  end

`define uvm_pack_enumN(VAR,SIZE) \
   `uvm_pack_intN(VAR,SIZE)


`define uvm_pack_sarrayN(VAR,SIZE) \
    begin \
    foreach (VAR `` [index]) \
      `uvm_pack_intN(VAR[index],SIZE) \
    end


`define uvm_pack_arrayN(VAR,SIZE) \
    begin \
    if (packer.use_metadata) \
      `uvm_pack_intN(VAR.size(),32) \
    `uvm_pack_sarrayN(VAR,SIZE) \
    end


`define uvm_pack_queueN(VAR,SIZE) \
   `uvm_pack_arrayN(VAR,SIZE)



`define uvm_pack_int(VAR) \
   `uvm_pack_intN(VAR,$bits(VAR))


`define uvm_pack_enum(VAR) \
   `uvm_pack_enumN(VAR,$bits(VAR))


`define uvm_pack_string(VAR) \
    begin \
    `uvm_pack_sarrayN(VAR,8) \
    if (packer.use_metadata) \
      `uvm_pack_intN(8'b0,8) \
    end


`define uvm_pack_real(VAR) \
   `uvm_pack_intN($realtobits(VAR),64)


`define uvm_pack_sarray(VAR)  \
   `uvm_pack_sarrayN(VAR,$bits(VAR[0]))


`define uvm_pack_array(VAR) \
   `uvm_pack_arrayN(VAR,$bits(VAR[0]))


`define uvm_pack_queue(VAR) \
   `uvm_pack_queueN(VAR,$bits(VAR[0]))





`define uvm_unpack_intN(VAR,SIZE) \
   begin \
      int __array[] = new[(SIZE+31)/32]; \
      bit [(((SIZE + 31) / 32) * 32) - 1:0] __var; \
      packer.unpack_ints(__array, SIZE); \
      __var = { << int { __array }}; \
      VAR = __var; \
   end


`define uvm_unpack_enumN(VAR,SIZE,TYPE) \
   begin \
   if (packer.big_endian) \
     { << { VAR }} = packer.m_bits[packer.count +: SIZE];  \
   else \
     VAR = TYPE'(packer.m_bits[packer.count +: SIZE]); \
   \
   packer.count += SIZE; \
   end


`define uvm_unpack_sarrayN(VAR,SIZE) \
    begin \
    foreach (VAR `` [i]) \
      `uvm_unpack_intN(VAR``[i], SIZE) \
    end


`define uvm_unpack_arrayN(VAR,SIZE) \
    begin \
    int sz__; \
    if (packer.use_metadata) begin \
      `uvm_unpack_intN(sz__,32) \
      VAR = new[sz__]; \
    end \
    `uvm_unpack_sarrayN(VAR,SIZE) \
    end


`define uvm_unpack_queueN(VAR,SIZE) \
    begin \
    int sz__; \
    if (packer.use_metadata) \
      `uvm_unpack_intN(sz__,32) \
    while (VAR.size() > sz__) \
      void'(VAR.pop_back()); \
    for (int i=0; i<sz__; i++) \
      `uvm_unpack_intN(VAR[i],SIZE) \
    end




`define uvm_unpack_int(VAR) \
   `uvm_unpack_intN(VAR,$bits(VAR))


`define uvm_unpack_enum(VAR,TYPE) \
   `uvm_unpack_enumN(VAR,$bits(VAR),TYPE)


`define uvm_unpack_string(VAR) \
  VAR = packer.unpack_string();

`define uvm_unpack_real(VAR) \
   begin \
   longint unsigned real_bits64__; \
   `uvm_unpack_intN(real_bits64__,64) \
   VAR = $bitstoreal(real_bits64__); \
   end


`define uvm_unpack_sarray(VAR)  \
   `uvm_unpack_sarrayN(VAR,$bits(VAR[0]))


`define uvm_unpack_array(VAR) \
   `uvm_unpack_arrayN(VAR,$bits(VAR[0]))


`define uvm_unpack_queue(VAR) \
   `uvm_unpack_queueN(VAR,$bits(VAR[0]))



`endif  



`ifndef UVM_PRINTER_DEFINES_SVH
`define UVM_PRINTER_DEFINES_SVH


`define uvm_print_int(F, R) \
  `uvm_print_int3(F, R, uvm_default_printer)

`define uvm_print_int3(F, R, P) \
   do begin \
     uvm_printer p__; \
     if(P!=null) p__ = P; \
     else p__ = uvm_default_printer; \
     `uvm_print_int4(F, R, `"F`", p__) \
   end while(0);

`define uvm_print_int4(F, R, NM, P) \
    if ($bits(F) > 64) \
      P.print_field(NM, F, $bits(F), R, "["); \
    else \
      P.print_field_int(NM, F, $bits(F), R, "["); 



`define uvm_print_enum(T, F, NM, P) \
    P.print_generic(NM, `"T`", $bits(F), F.name(), "[");



`define uvm_print_object(F) \
  `uvm_print_object2(F, uvm_default_printer)

`define uvm_print_object2(F, P) \
   do begin \
     uvm_printer p__; \
     if(P!=null) p__ = P; \
     else p__ = uvm_default_printer; \
     p__.print_object(`"F`", F, "["); \
   end while(0);



`define uvm_print_string(F) \
  `uvm_print_string2(F, uvm_default_printer)

`define uvm_print_string2(F, P) \
   do begin \
     uvm_printer p__; \
     if(P!=null) p__ = P; \
     else p__ = uvm_default_printer; \
     p__.print_string(`"F`", F, "["); \
   end while(0);



`define uvm_print_array_int(F, R) \
  `uvm_print_array_int3(F, R, uvm_default_printer)
   
`define uvm_print_array_int3(F, R, P) \
  `uvm_print_qda_int4(F, R, P, da)



`define uvm_print_sarray_int3(F, R, P) \
  `uvm_print_qda_int4(F, R, P, sa)

`define uvm_print_qda_int4(F, R, P, T) \
  begin \
    uvm_printer p__; \
    uvm_printer_knobs k__; \
    int curr, max__; max__=0; curr=0; \
    if(P!=null) p__ = P; \
    else p__ = uvm_default_printer; \
    max__ = $right(F)+1; \
    p__.print_array_header (`"F`", max__,`"T``(integral)`"); \
    k__ = p__.knobs; \
    if((p__.knobs.depth == -1) || (p__.m_scope.depth() < p__.knobs.depth+1)) \
    begin \
      foreach(F[i__]) begin \
        if(k__.begin_elements == -1 || k__.end_elements == -1 || curr < k__.begin_elements ) begin \
          `uvm_print_int4(F[curr], R, p__.index_string(curr), p__) \
        end \
        else break; \
        curr++; \
      end \
      if(curr<max__) begin \
        if((max__-k__.end_elements) > curr) curr = max__-k__.end_elements; \
        if(curr<k__.begin_elements) curr = k__.begin_elements; \
        else begin \
          p__.print_array_range(k__.begin_elements, curr-1); \
        end \
        for(curr=curr; curr<max__; ++curr) begin \
          `uvm_print_int4(F[curr], R, p__.index_string(curr), p__) \
        end \
      end \
    end \
    p__.print_array_footer(max__); \
  end
 
`define uvm_print_qda_enum(F, P, T, ET) \
  begin \
    uvm_printer p__; \
    uvm_printer_knobs k__; \
    int curr, max__; max__=0; curr=0; \
    if(P!=null) p__ = P; \
    else p__ = uvm_default_printer; \
    foreach(F[i]) max__ = i+1; \
    p__.print_array_header (`"F`", max__,`"T``(``ET``)`"); \
    k__ = p__.knobs; \
    if((p__.knobs.depth == -1) || (p__.m_scope.depth() < p__.knobs.depth+1)) \
    begin \
      foreach(F[i__]) begin \
        if(k__.begin_elements == -1 || k__.end_elements == -1 || curr < k__.begin_elements ) begin \
          `uvm_print_enum(ET, F[curr], p__.index_string(curr), p__) \
        end \
        else break; \
        curr++; \
      end \
      if(curr<max__) begin \
        if((max__-k__.end_elements) > curr) curr = max__-k__.end_elements; \
        if(curr<k__.begin_elements) curr = k__.begin_elements; \
        else begin \
          p__.print_array_range(k__.begin_elements, curr-1); \
        end \
        for(curr=curr; curr<max__; ++curr) begin \
          `uvm_print_enum(ET, F[curr], p__.index_string(curr), p__) \
        end \
      end \
    end \
    p__.print_array_footer(max__); \
  end
 
`define uvm_print_queue_int(F, R) \
  `uvm_print_queue_int3(F, R, uvm_default_printer)

`define uvm_print_queue_int3(F, R, P) \
  `uvm_print_qda_int3(F, R, P, queue)

`define uvm_print_array_object(F,FLAG) \
  `uvm_print_array_object3(F, uvm_default_printer,FLAG)
   
`define uvm_print_sarray_object(F,FLAG) \
  `uvm_print_sarray_object3(F, uvm_default_printer,FLAG)
   
`define uvm_print_array_object3(F, P,FLAG) \
  `uvm_print_object_qda4(F, P, da,FLAG)

`define uvm_print_sarray_object3(F, P,FLAG) \
  `uvm_print_object_qda4(F, P, sa,FLAG)

`define uvm_print_object_qda4(F, P, T,FLAG) \
  do begin \
    int curr, max__; \
    uvm_printer p__; \
    max__=0; curr=0; \
    if(P!=null) p__ = P; \
    else p__ = uvm_default_printer; \
    foreach(F[i]) max__ = i+1; \
\
\
    p__.m_scope.set_arg(`"F`");\
    p__.print_array_header(`"F`", max__, `"T``(object)`");\
    if((p__.knobs.depth == -1) || (p__.knobs.depth+1 > p__.m_scope.depth())) \
    begin\
      for(curr=0; curr<max__ && (p__.knobs.begin_elements == -1 || \
         p__.knobs.end_elements == -1 || curr<p__.knobs.begin_elements); ++curr) begin \
        if(((FLAG)&UVM_REFERENCE) == 0) \
          p__.print_object(p__.index_string(curr), F[curr], "[");\
        else \
          p__.print_object_header(p__.index_string(curr), F[curr], "[");\
      end \
      if(curr<max__) begin\
        curr = max__-p__.knobs.end_elements;\
        if(curr<p__.knobs.begin_elements) curr = p__.knobs.begin_elements;\
        else begin\
          p__.print_array_range(p__.knobs.begin_elements, curr-1);\
        end\
        for(curr=curr; curr<max__; ++curr) begin\
          if(((FLAG)&UVM_REFERENCE) == 0) \
            p__.print_object(p__.index_string(curr), F[curr], "[");\
          else \
            p__.print_object_header(p__.index_string(curr), F[curr], "[");\
        end \
      end\
    end \
\
    p__.print_array_footer(max__); \
  end while(0);
 
`define uvm_print_object_queue(F,FLAG) \
  `uvm_print_object_queue3(F, uvm_default_printer,FLAG)
   
`define uvm_print_object_queue3(F, P,FLAG) \
  do begin \
    `uvm_print_object_qda4(F,P, queue,FLAG); \
  end while(0);
 
`define uvm_print_array_string(F) \
  `uvm_print_array_string2(F, uvm_default_printer)
   
`define uvm_print_array_string2(F, P) \
   `uvm_print_string_qda3(F, P, da)

`define uvm_print_sarray_string2(F, P) \
   `uvm_print_string_qda3(F, P, sa)

`define uvm_print_string_qda3(F, P, T) \
  do begin \
    int curr, max__; \
    uvm_printer p__; \
    max__=0; curr=0; \
    foreach(F[i]) max__ = i+1; \
    if(P!=null) p__ = P; \
    else p__ = uvm_default_printer; \
\
\
    p__.m_scope.set_arg(`"F`");\
    p__.print_array_header(`"F`", max__, `"T``(string)`");\
    if((p__.knobs.depth == -1) || (p__.knobs.depth+1 > p__.m_scope.depth())) \
    begin\
      for(curr=0; curr<max__ && curr<p__.knobs.begin_elements; ++curr) begin\
        p__.print_string(p__.index_string(curr), F[curr], "[");\
      end \
      if(curr<max__) begin\
        curr = max__-p__.knobs.end_elements;\
        if(curr<p__.knobs.begin_elements) curr = p__.knobs.begin_elements;\
        else begin\
          p__.print_array_range(p__.knobs.begin_elements, curr-1);\
        end\
        for(curr=curr; curr<max__; ++curr) begin\
          p__.print_string(p__.index_string(curr), F[curr], "[");\
        end \
      end\
    end \
\
    p__.print_array_footer(max__); \
  end while(0);
 
`define uvm_print_string_queue(F) \
  `uvm_print_string_queue2(F, uvm_default_printer)
   
`define uvm_print_string_queue2(F, P) \
  do begin \
    `uvm_print_string_qda3(F,P, queue); \
  end while(0);

`define uvm_print_aa_string_int(F) \
  `uvm_print_aa_string_int3(F, R, uvm_default_printer)


`define uvm_print_aa_string_int3(F, R, P) \
  begin \
    uvm_printer p__; \
    uvm_printer_knobs k__; \
    if(P!=null) p__ = P; \
    else p__ = uvm_default_printer; \
    p__.print_array_header (`"F`", F.num(), "aa(int,string)"); \
    k__ = p__.knobs; \
    if((p__.knobs.depth == -1) || (p__.m_scope.depth() < p__.knobs.depth+1)) \
    begin \
      foreach(F[string_aa_key]) \
          `uvm_print_int4(F[string_aa_key], R,  \
                                {"[", string_aa_key, "]"}, p__) \
    end \
    p__.print_array_footer(F.num()); \
  end

`define uvm_print_aa_string_object(F,FLAG) \
  `uvm_print_aa_string_object_3(F, uvm_default_printer,FLAG)
  
`define uvm_print_aa_string_object3(F, P,FLAG) \
  begin \
    uvm_printer p__; \
    uvm_printer_knobs k__; \
    uvm_object u__; \
    if(P!=null) p__ = P; \
    else p__ = uvm_default_printer; \
    p__.print_array_header (`"F`", F.num(), "aa(object,string)"); \
    k__ = p__.knobs; \
    if((p__.knobs.depth == -1) || (p__.m_scope.depth() < p__.knobs.depth+1)) \
    begin \
      foreach(F[string_aa_key]) begin \
          if(((FLAG)&UVM_REFERENCE)==0) \
            p__.print_object({"[", string_aa_key, "]"}, F[string_aa_key], "[");\
          else \
            p__.print_object_header({"[", string_aa_key, "]"}, F[string_aa_key], "[");\
      end \
    end \
    p__.print_array_footer(F.num()); \
  end

`define uvm_print_aa_string_string(F) \
  `uvm_print_aa_string_string_2(F, uvm_default_printer)
  
`define uvm_print_aa_string_string2(F, P) \
  begin \
    uvm_printer p__; \
    uvm_printer_knobs k__; \
    if(P!=null) p__ = P; \
    else p__ = uvm_default_printer; \
    p__.print_array_header (`"F`", F.num(), "aa(string,string)"); \
    k__ = p__.knobs; \
    if((p__.knobs.depth == -1) || (p__.m_scope.depth() < p__.knobs.depth+1)) \
    begin \
      foreach(F[string_aa_key]) \
          p__.print_string({"[", string_aa_key, "]"}, F[string_aa_key], "["); \
    end \
    p__.print_array_footer(F.num()); \
  end

`define uvm_print_aa_int_object(F,FLAG) \
  `uvm_print_aa_int_object_3(F, uvm_default_printer,FLAG)

`define uvm_print_aa_int_object3(F, P,FLAG) \
  begin \
    uvm_printer p__; \
    uvm_printer_knobs k__; \
    uvm_object u__; \
    int key; \
    if(P!=null) p__ = P; \
    else p__ = uvm_default_printer; \
    p__.print_array_header (`"F`", F.num(), "aa(object,int)"); \
    k__ = p__.knobs; \
    if((p__.knobs.depth == -1) || (p__.m_scope.depth() < p__.knobs.depth+1)) \
    begin \
      foreach(F[key]) begin \
          $swrite(__m_uvm_status_container.stringv, "[%0d]", key); \
          if(((FLAG)&UVM_REFERENCE)==0) \
            p__.print_object(__m_uvm_status_container.stringv, F[key], "[");\
          else \
            p__.print_object_header(__m_uvm_status_container.stringv, F[key], "[");\
      end \
    end \
    p__.print_array_footer(F.num()); \
  end

`define uvm_print_aa_int_key4(KEY, F, R, P) \
  begin \
    uvm_printer p__; \
    uvm_printer_knobs k__; \
    if(P!=null) p__ = P; \
    else p__ = uvm_default_printer; \
    __m_uvm_status_container.stringv = "aa(int,int)"; \
    for(int i=0; i<__m_uvm_status_container.stringv.len(); ++i) \
      if(__m_uvm_status_container.stringv[i] == " ") \
        __m_uvm_status_container.stringv[i] = "_"; \
    p__.print_array_header (`"F`", F.num(), __m_uvm_status_container.stringv); \
    k__ = p__.knobs; \
    if((p__.knobs.depth == -1) || (p__.m_scope.depth() < p__.knobs.depth+1)) \
    begin \
      foreach(F[aa_key]) begin \
          `uvm_print_int4(F[aa_key], R,  \
                                {"[", $sformatf("%0d",aa_key), "]"}, p__) \
      end \
    end \
    p__.print_array_footer(F.num()); \
  end

`endif





`define uvm_blocking_put_imp_decl(SFX) \
class uvm_blocking_put_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_BLOCKING_PUT_MASK,`"uvm_blocking_put_imp``SFX`",IMP) \
  `UVM_BLOCKING_PUT_IMP_SFX(SFX, m_imp, T, t) \
endclass


`define uvm_nonblocking_put_imp_decl(SFX) \
class uvm_nonblocking_put_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_NONBLOCKING_PUT_MASK,`"uvm_nonblocking_put_imp``SFX`",IMP) \
  `UVM_NONBLOCKING_PUT_IMP_SFX( SFX, m_imp, T, t) \
endclass


`define uvm_put_imp_decl(SFX) \
class uvm_put_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_PUT_MASK,`"uvm_put_imp``SFX`",IMP) \
  `UVM_BLOCKING_PUT_IMP_SFX(SFX, m_imp, T, t) \
  `UVM_NONBLOCKING_PUT_IMP_SFX(SFX, m_imp, T, t) \
endclass


`define uvm_blocking_get_imp_decl(SFX) \
class uvm_blocking_get_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_BLOCKING_GET_MASK,`"uvm_blocking_get_imp``SFX`",IMP) \
  `UVM_BLOCKING_GET_IMP_SFX(SFX, m_imp, T, t) \
endclass


`define uvm_nonblocking_get_imp_decl(SFX) \
class uvm_nonblocking_get_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_NONBLOCKING_GET_MASK,`"uvm_nonblocking_get_imp``SFX`",IMP) \
  `UVM_NONBLOCKING_GET_IMP_SFX(SFX, m_imp, T, t) \
endclass


`define uvm_get_imp_decl(SFX) \
class uvm_get_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_GET_MASK,`"uvm_get_imp``SFX`",IMP) \
  `UVM_BLOCKING_GET_IMP_SFX(SFX, m_imp, T, t) \
  `UVM_NONBLOCKING_GET_IMP_SFX(SFX, m_imp, T, t) \
endclass


`define uvm_blocking_peek_imp_decl(SFX) \
class uvm_blocking_peek_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_BLOCKING_PEEK_MASK,`"uvm_blocking_peek_imp``SFX`",IMP) \
  `UVM_BLOCKING_PEEK_IMP_SFX(SFX, m_imp, T, t) \
endclass 


`define uvm_nonblocking_peek_imp_decl(SFX) \
class uvm_nonblocking_peek_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_NONBLOCKING_PEEK_MASK,`"uvm_nonblocking_peek_imp``SFX`",IMP) \
  `UVM_NONBLOCKING_PEEK_IMP_SFX(SFX, m_imp, T, t) \
endclass


`define uvm_peek_imp_decl(SFX) \
class uvm_peek_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_PEEK_MASK,`"uvm_peek_imp``SFX`",IMP) \
  `UVM_BLOCKING_PEEK_IMP_SFX(SFX, m_imp, T, t) \
  `UVM_NONBLOCKING_PEEK_IMP_SFX(SFX, m_imp, T, t) \
endclass



`define uvm_blocking_get_peek_imp_decl(SFX) \
class uvm_blocking_get_peek_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_BLOCKING_GET_PEEK_MASK,`"uvm_blocking_get_peek_imp``SFX`",IMP) \
  `UVM_BLOCKING_GET_IMP_SFX(SFX, m_imp, T, t) \
  `UVM_BLOCKING_PEEK_IMP_SFX(SFX, m_imp, T, t) \
endclass


`define uvm_nonblocking_get_peek_imp_decl(SFX) \
class uvm_nonblocking_get_peek_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_NONBLOCKING_GET_PEEK_MASK,`"uvm_nonblocking_get_peek_imp``SFX`",IMP) \
  `UVM_NONBLOCKING_GET_IMP_SFX(SFX, m_imp, T, t) \
  `UVM_NONBLOCKING_PEEK_IMP_SFX(SFX, m_imp, T, t) \
endclass



`define uvm_get_peek_imp_decl(SFX) \
class uvm_get_peek_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_GET_PEEK_MASK,`"uvm_get_peek_imp``SFX`",IMP) \
  `UVM_BLOCKING_GET_IMP_SFX(SFX, m_imp, T, t) \
  `UVM_NONBLOCKING_GET_IMP_SFX(SFX, m_imp, T, t) \
  `UVM_BLOCKING_PEEK_IMP_SFX(SFX, m_imp, T, t) \
  `UVM_NONBLOCKING_PEEK_IMP_SFX(SFX, m_imp, T, t) \
endclass


`define uvm_blocking_master_imp_decl(SFX) \
class uvm_blocking_master_imp``SFX #(type REQ=int, type RSP=int, type IMP=int, \
                                     type REQ_IMP=IMP, type RSP_IMP=IMP) \
  extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP)); \
  typedef IMP     this_imp_type; \
  typedef REQ_IMP this_req_type; \
  typedef RSP_IMP this_rsp_type; \
  `UVM_MS_IMP_COMMON(`UVM_TLM_BLOCKING_MASTER_MASK,`"uvm_blocking_master_imp``SFX`") \
  \
  `UVM_BLOCKING_PUT_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  \
  `UVM_BLOCKING_GET_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  `UVM_BLOCKING_PEEK_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  \
endclass


`define uvm_nonblocking_master_imp_decl(SFX) \
class uvm_nonblocking_master_imp``SFX #(type REQ=int, type RSP=int, type IMP=int, \
                                   type REQ_IMP=IMP, type RSP_IMP=IMP) \
  extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP)); \
  typedef IMP     this_imp_type; \
  typedef REQ_IMP this_req_type; \
  typedef RSP_IMP this_rsp_type; \
  `UVM_MS_IMP_COMMON(`UVM_TLM_NONBLOCKING_MASTER_MASK,`"uvm_nonblocking_master_imp``SFX`") \
  \
  `UVM_NONBLOCKING_PUT_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  \
  `UVM_NONBLOCKING_GET_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  `UVM_NONBLOCKING_PEEK_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  \
endclass


`define uvm_master_imp_decl(SFX) \
class uvm_master_imp``SFX #(type REQ=int, type RSP=int, type IMP=int, \
                            type REQ_IMP=IMP, type RSP_IMP=IMP) \
  extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP)); \
  typedef IMP     this_imp_type; \
  typedef REQ_IMP this_req_type; \
  typedef RSP_IMP this_rsp_type; \
  `UVM_MS_IMP_COMMON(`UVM_TLM_MASTER_MASK,`"uvm_master_imp``SFX`") \
  \
  `UVM_BLOCKING_PUT_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  `UVM_NONBLOCKING_PUT_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  \
  `UVM_BLOCKING_GET_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  `UVM_BLOCKING_PEEK_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  `UVM_NONBLOCKING_GET_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  `UVM_NONBLOCKING_PEEK_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  \
endclass


`define uvm_blocking_slave_imp_decl(SFX) \
class uvm_blocking_slave_imp``SFX #(type REQ=int, type RSP=int, type IMP=int, \
                                    type REQ_IMP=IMP, type RSP_IMP=IMP) \
  extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ)); \
  typedef IMP     this_imp_type; \
  typedef REQ_IMP this_req_type; \
  typedef RSP_IMP this_rsp_type; \
  `UVM_MS_IMP_COMMON(`UVM_TLM_BLOCKING_SLAVE_MASK,`"uvm_blocking_slave_imp``SFX`") \
  \
  `UVM_BLOCKING_PUT_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  \
  `UVM_BLOCKING_GET_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  `UVM_BLOCKING_PEEK_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  \
endclass


`define uvm_nonblocking_slave_imp_decl(SFX) \
class uvm_nonblocking_slave_imp``SFX #(type REQ=int, type RSP=int, type IMP=int, \
                                       type REQ_IMP=IMP, type RSP_IMP=IMP) \
  extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ)); \
  typedef IMP     this_imp_type; \
  typedef REQ_IMP this_req_type; \
  typedef RSP_IMP this_rsp_type; \
  `UVM_MS_IMP_COMMON(`UVM_TLM_NONBLOCKING_SLAVE_MASK,`"uvm_nonblocking_slave_imp``SFX`") \
  \
  `UVM_NONBLOCKING_PUT_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  \
  `UVM_NONBLOCKING_GET_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  `UVM_NONBLOCKING_PEEK_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  \
endclass


`define uvm_slave_imp_decl(SFX) \
class uvm_slave_imp``SFX #(type REQ=int, type RSP=int, type IMP=int, \
                           type REQ_IMP=IMP, type RSP_IMP=IMP) \
  extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ)); \
  typedef IMP     this_imp_type; \
  typedef REQ_IMP this_req_type; \
  typedef RSP_IMP this_rsp_type; \
  `UVM_MS_IMP_COMMON(`UVM_TLM_SLAVE_MASK,`"uvm_slave_imp``SFX`") \
  \
  `UVM_BLOCKING_PUT_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  `UVM_NONBLOCKING_PUT_IMP_SFX(SFX, m_rsp_imp, RSP, t)  \
  \
  `UVM_BLOCKING_GET_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  `UVM_BLOCKING_PEEK_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  `UVM_NONBLOCKING_GET_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  `UVM_NONBLOCKING_PEEK_IMP_SFX(SFX, m_req_imp, REQ, t)  \
  \
endclass


`define uvm_blocking_transport_imp_decl(SFX) \
class uvm_blocking_transport_imp``SFX #(type REQ=int, type RSP=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP)); \
  `UVM_IMP_COMMON(`UVM_TLM_BLOCKING_TRANSPORT_MASK,`"uvm_blocking_transport_imp``SFX`",IMP) \
  `UVM_BLOCKING_TRANSPORT_IMP_SFX(SFX, m_imp, REQ, RSP, req, rsp) \
endclass


`define uvm_nonblocking_transport_imp_decl(SFX) \
class uvm_nonblocking_transport_imp``SFX #(type REQ=int, type RSP=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP)); \
  `UVM_IMP_COMMON(`UVM_TLM_NONBLOCKING_TRANSPORT_MASK,`"uvm_nonblocking_transport_imp``SFX`",IMP) \
  `UVM_NONBLOCKING_TRANSPORT_IMP_SFX(SFX, m_imp, REQ, RSP, req, rsp) \
endclass

`define uvm_non_blocking_transport_imp_decl(SFX) \
  `uvm_nonblocking_transport_imp_decl(SFX)


`define uvm_transport_imp_decl(SFX) \
class uvm_transport_imp``SFX #(type REQ=int, type RSP=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP)); \
  `UVM_IMP_COMMON(`UVM_TLM_TRANSPORT_MASK,`"uvm_transport_imp``SFX`",IMP) \
  `UVM_BLOCKING_TRANSPORT_IMP_SFX(SFX, m_imp, REQ, RSP, req, rsp) \
  `UVM_NONBLOCKING_TRANSPORT_IMP_SFX(SFX, m_imp, REQ, RSP, req, rsp) \
endclass


`define uvm_analysis_imp_decl(SFX) \
class uvm_analysis_imp``SFX #(type T=int, type IMP=int) \
  extends uvm_port_base #(uvm_tlm_if_base #(T,T)); \
  `UVM_IMP_COMMON(`UVM_TLM_ANALYSIS_MASK,`"uvm_analysis_imp``SFX`",IMP) \
  function void write( input T t); \
    m_imp.write``SFX( t); \
  endfunction \
  \
endclass



`define UVM_BLOCKING_PUT_IMP_SFX(SFX, imp, TYPE, arg) \
  task put( input TYPE arg); imp.put``SFX( arg); endtask

`define UVM_BLOCKING_GET_IMP_SFX(SFX, imp, TYPE, arg) \
  task get( output TYPE arg); imp.get``SFX( arg); endtask

`define UVM_BLOCKING_PEEK_IMP_SFX(SFX, imp, TYPE, arg) \
  task peek( output TYPE arg);imp.peek``SFX( arg); endtask

`define UVM_NONBLOCKING_PUT_IMP_SFX(SFX, imp, TYPE, arg) \
  function bit try_put( input TYPE arg); \
    if( !imp.try_put``SFX( arg)) return 0; \
    return 1; \
  endfunction \
  function bit can_put(); return imp.can_put``SFX(); endfunction

`define UVM_NONBLOCKING_GET_IMP_SFX(SFX, imp, TYPE, arg) \
  function bit try_get( output TYPE arg); \
    if( !imp.try_get``SFX( arg)) return 0; \
    return 1; \
  endfunction \
  function bit can_get(); return imp.can_get``SFX(); endfunction

`define UVM_NONBLOCKING_PEEK_IMP_SFX(SFX, imp, TYPE, arg) \
  function bit try_peek( output TYPE arg); \
    if( !imp.try_peek``SFX( arg)) return 0; \
    return 1; \
  endfunction \
  function bit can_peek(); return imp.can_peek``SFX(); endfunction

`define UVM_BLOCKING_TRANSPORT_IMP_SFX(SFX, imp, REQ, RSP, req_arg, rsp_arg) \
  task transport( input REQ req_arg, output RSP rsp_arg); \
    imp.transport``SFX(req_arg, rsp_arg); \
  endtask

`define UVM_NONBLOCKING_TRANSPORT_IMP_SFX(SFX, imp, REQ, RSP, req_arg, rsp_arg) \
  function bit nb_transport( input REQ req_arg, output RSP rsp_arg); \
    if(imp) return imp.nb_transport``SFX(req_arg, rsp_arg); \
  endfunction

`define UVM_SEQ_ITEM_PULL_IMP(imp, REQ, RSP, req_arg, rsp_arg) \
  function void disable_auto_item_recording(); imp.disable_auto_item_recording(); endfunction \
  function bit is_auto_item_recording_enabled(); return imp.is_auto_item_recording_enabled(); endfunction \
  virtual task get_next_item(output REQ req_arg); imp.get_next_item(req_arg); endtask \
  virtual task try_next_item(output REQ req_arg); imp.try_next_item(req_arg); endtask \
  virtual function void item_done(input RSP rsp_arg = null); imp.item_done(rsp_arg); endfunction \
  task wait_for_sequences(); imp.wait_for_sequences(); endtask \
  function bit has_do_available(); return imp.has_do_available(); endfunction \
  function void put_response(input RSP rsp_arg); imp.put_response(rsp_arg); endfunction \
  task get(output REQ req_arg); imp.get(req_arg); endtask \
  task peek(output REQ req_arg); imp.peek(req_arg); endtask \
  virtual task put(input RSP rsp_arg); imp.put(rsp_arg); endtask

`define UVM_TLM_BLOCKING_PUT_MASK          (1<<0)
`define UVM_TLM_BLOCKING_GET_MASK          (1<<1)
`define UVM_TLM_BLOCKING_PEEK_MASK         (1<<2)
`define UVM_TLM_BLOCKING_TRANSPORT_MASK    (1<<3)

`define UVM_TLM_NONBLOCKING_PUT_MASK       (1<<4)
`define UVM_TLM_NONBLOCKING_GET_MASK       (1<<5)
`define UVM_TLM_NONBLOCKING_PEEK_MASK      (1<<6)
`define UVM_TLM_NONBLOCKING_TRANSPORT_MASK (1<<7)

`define UVM_TLM_ANALYSIS_MASK              (1<<8)

`define UVM_TLM_MASTER_BIT_MASK            (1<<9)
`define UVM_TLM_SLAVE_BIT_MASK             (1<<10)
`define UVM_TLM_PUT_MASK                  (`UVM_TLM_BLOCKING_PUT_MASK    | `UVM_TLM_NONBLOCKING_PUT_MASK)
`define UVM_TLM_GET_MASK                  (`UVM_TLM_BLOCKING_GET_MASK    | `UVM_TLM_NONBLOCKING_GET_MASK)
`define UVM_TLM_PEEK_MASK                 (`UVM_TLM_BLOCKING_PEEK_MASK   | `UVM_TLM_NONBLOCKING_PEEK_MASK)

`define UVM_TLM_BLOCKING_GET_PEEK_MASK    (`UVM_TLM_BLOCKING_GET_MASK    | `UVM_TLM_BLOCKING_PEEK_MASK)
`define UVM_TLM_BLOCKING_MASTER_MASK      (`UVM_TLM_BLOCKING_PUT_MASK       | `UVM_TLM_BLOCKING_GET_MASK | `UVM_TLM_BLOCKING_PEEK_MASK | `UVM_TLM_MASTER_BIT_MASK)
`define UVM_TLM_BLOCKING_SLAVE_MASK       (`UVM_TLM_BLOCKING_PUT_MASK       | `UVM_TLM_BLOCKING_GET_MASK | `UVM_TLM_BLOCKING_PEEK_MASK | `UVM_TLM_SLAVE_BIT_MASK)

`define UVM_TLM_NONBLOCKING_GET_PEEK_MASK (`UVM_TLM_NONBLOCKING_GET_MASK | `UVM_TLM_NONBLOCKING_PEEK_MASK)
`define UVM_TLM_NONBLOCKING_MASTER_MASK   (`UVM_TLM_NONBLOCKING_PUT_MASK    | `UVM_TLM_NONBLOCKING_GET_MASK | `UVM_TLM_NONBLOCKING_PEEK_MASK | `UVM_TLM_MASTER_BIT_MASK)
`define UVM_TLM_NONBLOCKING_SLAVE_MASK    (`UVM_TLM_NONBLOCKING_PUT_MASK    | `UVM_TLM_NONBLOCKING_GET_MASK | `UVM_TLM_NONBLOCKING_PEEK_MASK | `UVM_TLM_SLAVE_BIT_MASK)

`define UVM_TLM_GET_PEEK_MASK             (`UVM_TLM_GET_MASK | `UVM_TLM_PEEK_MASK)
`define UVM_TLM_MASTER_MASK               (`UVM_TLM_BLOCKING_MASTER_MASK    | `UVM_TLM_NONBLOCKING_MASTER_MASK)
`define UVM_TLM_SLAVE_MASK                (`UVM_TLM_BLOCKING_SLAVE_MASK    | `UVM_TLM_NONBLOCKING_SLAVE_MASK)
`define UVM_TLM_TRANSPORT_MASK            (`UVM_TLM_BLOCKING_TRANSPORT_MASK | `UVM_TLM_NONBLOCKING_TRANSPORT_MASK)

`define UVM_SEQ_ITEM_GET_NEXT_ITEM_MASK       (1<<0)
`define UVM_SEQ_ITEM_TRY_NEXT_ITEM_MASK       (1<<1)
`define UVM_SEQ_ITEM_ITEM_DONE_MASK           (1<<2)
`define UVM_SEQ_ITEM_HAS_DO_AVAILABLE_MASK    (1<<3)
`define UVM_SEQ_ITEM_WAIT_FOR_SEQUENCES_MASK  (1<<4)
`define UVM_SEQ_ITEM_PUT_RESPONSE_MASK        (1<<5)
`define UVM_SEQ_ITEM_PUT_MASK                 (1<<6)
`define UVM_SEQ_ITEM_GET_MASK                 (1<<7)
`define UVM_SEQ_ITEM_PEEK_MASK                (1<<8)

`define UVM_SEQ_ITEM_PULL_MASK  (`UVM_SEQ_ITEM_GET_NEXT_ITEM_MASK | `UVM_SEQ_ITEM_TRY_NEXT_ITEM_MASK | \
                        `UVM_SEQ_ITEM_ITEM_DONE_MASK | `UVM_SEQ_ITEM_HAS_DO_AVAILABLE_MASK |  \
                        `UVM_SEQ_ITEM_WAIT_FOR_SEQUENCES_MASK | `UVM_SEQ_ITEM_PUT_RESPONSE_MASK | \
                        `UVM_SEQ_ITEM_PUT_MASK | `UVM_SEQ_ITEM_GET_MASK | `UVM_SEQ_ITEM_PEEK_MASK)

`define UVM_SEQ_ITEM_UNI_PULL_MASK (`UVM_SEQ_ITEM_GET_NEXT_ITEM_MASK | `UVM_SEQ_ITEM_TRY_NEXT_ITEM_MASK | \
                           `UVM_SEQ_ITEM_ITEM_DONE_MASK | `UVM_SEQ_ITEM_HAS_DO_AVAILABLE_MASK | \
                           `UVM_SEQ_ITEM_WAIT_FOR_SEQUENCES_MASK | `UVM_SEQ_ITEM_GET_MASK | \
                           `UVM_SEQ_ITEM_PEEK_MASK)

`define UVM_SEQ_ITEM_PUSH_MASK  (`UVM_SEQ_ITEM_PUT_MASK)


`ifndef UVM_TLM_IMPS_SVH
`define UVM_TLM_IMPS_SVH







`define UVM_BLOCKING_PUT_IMP(imp, TYPE, arg) \
  task put (TYPE arg); \
    imp.put(arg); \
  endtask

`define UVM_NONBLOCKING_PUT_IMP(imp, TYPE, arg) \
  function bit try_put (TYPE arg); \
    return imp.try_put(arg); \
  endfunction \
  function bit can_put(); \
    return imp.can_put(); \
  endfunction

`define UVM_BLOCKING_GET_IMP(imp, TYPE, arg) \
  task get (output TYPE arg); \
    imp.get(arg); \
  endtask

`define UVM_NONBLOCKING_GET_IMP(imp, TYPE, arg) \
  function bit try_get (output TYPE arg); \
    return imp.try_get(arg); \
  endfunction \
  function bit can_get(); \
    return imp.can_get(); \
  endfunction

`define UVM_BLOCKING_PEEK_IMP(imp, TYPE, arg) \
  task peek (output TYPE arg); \
    imp.peek(arg); \
  endtask

`define UVM_NONBLOCKING_PEEK_IMP(imp, TYPE, arg) \
  function bit try_peek (output TYPE arg); \
    return imp.try_peek(arg); \
  endfunction \
  function bit can_peek(); \
    return imp.can_peek(); \
  endfunction

`define UVM_BLOCKING_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg) \
  task transport (REQ req_arg, output RSP rsp_arg); \
    imp.transport(req_arg, rsp_arg); \
  endtask

`define UVM_NONBLOCKING_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg) \
  function bit nb_transport (REQ req_arg, output RSP rsp_arg); \
    return imp.nb_transport(req_arg, rsp_arg); \
  endfunction

`define UVM_PUT_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_PUT_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_PUT_IMP(imp, TYPE, arg)

`define UVM_GET_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_GET_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_GET_IMP(imp, TYPE, arg)

`define UVM_PEEK_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_PEEK_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_PEEK_IMP(imp, TYPE, arg)

`define UVM_BLOCKING_GET_PEEK_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_GET_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_PEEK_IMP(imp, TYPE, arg)

`define UVM_NONBLOCKING_GET_PEEK_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_GET_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_PEEK_IMP(imp, TYPE, arg)

`define UVM_GET_PEEK_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_GET_PEEK_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_GET_PEEK_IMP(imp, TYPE, arg)

`define UVM_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg) \
  `UVM_BLOCKING_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg) \
  `UVM_NONBLOCKING_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg)



`define UVM_TLM_GET_TYPE_NAME(NAME) \
  virtual function string get_type_name(); \
    return NAME; \
  endfunction

`define UVM_PORT_COMMON(MASK,TYPE_NAME) \
  function new (string name, uvm_component parent, \
                int min_size=1, int max_size=1); \
    super.new (name, parent, UVM_PORT, min_size, max_size); \
    m_if_mask = MASK; \
  endfunction \
  `UVM_TLM_GET_TYPE_NAME(TYPE_NAME)

`define UVM_SEQ_PORT(MASK,TYPE_NAME) \
  function new (string name, uvm_component parent, \
                int min_size=0, int max_size=1); \
    super.new (name, parent, UVM_PORT, min_size, max_size); \
    m_if_mask = MASK; \
  endfunction \
  `UVM_TLM_GET_TYPE_NAME(TYPE_NAME)
  
`define UVM_EXPORT_COMMON(MASK,TYPE_NAME) \
  function new (string name, uvm_component parent, \
                int min_size=1, int max_size=1); \
    super.new (name, parent, UVM_EXPORT, min_size, max_size); \
    m_if_mask = MASK; \
  endfunction \
  `UVM_TLM_GET_TYPE_NAME(TYPE_NAME)
  
`define UVM_IMP_COMMON(MASK,TYPE_NAME,IMP) \
  local IMP m_imp; \
  function new (string name, IMP imp); \
    super.new (name, imp, UVM_IMPLEMENTATION, 1, 1); \
    m_imp = imp; \
    m_if_mask = MASK; \
  endfunction \
  `UVM_TLM_GET_TYPE_NAME(TYPE_NAME)

`define UVM_MS_IMP_COMMON(MASK,TYPE_NAME) \
  local this_req_type m_req_imp; \
  local this_rsp_type m_rsp_imp; \
  function new (string name, this_imp_type imp, \
                this_req_type req_imp = null, this_rsp_type rsp_imp = null); \
    super.new (name, imp, UVM_IMPLEMENTATION, 1, 1); \
    if(req_imp==null) $cast(req_imp, imp); \
    if(rsp_imp==null) $cast(rsp_imp, imp); \
    m_req_imp = req_imp; \
    m_rsp_imp = rsp_imp; \
    m_if_mask = MASK; \
  endfunction  \
  `UVM_TLM_GET_TYPE_NAME(TYPE_NAME)

`endif








`define uvm_create(SEQ_OR_ITEM) \
  `uvm_create_on(SEQ_OR_ITEM, m_sequencer)



`define uvm_do(SEQ_OR_ITEM) \
  `uvm_do_on_pri_with(SEQ_OR_ITEM, m_sequencer, -1, {})



`define uvm_do_pri(SEQ_OR_ITEM, PRIORITY) \
  `uvm_do_on_pri_with(SEQ_OR_ITEM, m_sequencer, PRIORITY, {})



`define uvm_do_with(SEQ_OR_ITEM, CONSTRAINTS) \
  `uvm_do_on_pri_with(SEQ_OR_ITEM, m_sequencer, -1, CONSTRAINTS)



`define uvm_do_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS) \
  `uvm_do_on_pri_with(SEQ_OR_ITEM, m_sequencer, PRIORITY, CONSTRAINTS)




`define uvm_create_on(SEQ_OR_ITEM, SEQR) \
  begin \
  uvm_object_wrapper w_; \
  w_ = SEQ_OR_ITEM.get_type(); \
  $cast(SEQ_OR_ITEM , create_item(w_, SEQR, `"SEQ_OR_ITEM`"));\
  end



`define uvm_do_on(SEQ_OR_ITEM, SEQR) \
  `uvm_do_on_pri_with(SEQ_OR_ITEM, SEQR, -1, {})



`define uvm_do_on_pri(SEQ_OR_ITEM, SEQR, PRIORITY) \
  `uvm_do_on_pri_with(SEQ_OR_ITEM, SEQR, PRIORITY, {})



`define uvm_do_on_with(SEQ_OR_ITEM, SEQR, CONSTRAINTS) \
  `uvm_do_on_pri_with(SEQ_OR_ITEM, SEQR, -1, CONSTRAINTS)



`define uvm_do_on_pri_with(SEQ_OR_ITEM, SEQR, PRIORITY, CONSTRAINTS) \
  begin \
  uvm_sequence_base __seq; \
  `uvm_create_on(SEQ_OR_ITEM, SEQR) \
  if (!$cast(__seq,SEQ_OR_ITEM)) start_item(SEQ_OR_ITEM, PRIORITY);\
  if ((__seq == null || !__seq.do_not_randomize) && !SEQ_OR_ITEM.randomize() with CONSTRAINTS ) begin \
    `uvm_warning("RNDFLD", "Randomization failed in uvm_do_with action") \
  end\
  if (!$cast(__seq,SEQ_OR_ITEM)) finish_item(SEQ_OR_ITEM, PRIORITY); \
  else __seq.start(SEQR, this, PRIORITY, 0); \
  end





`define uvm_send(SEQ_OR_ITEM) \
  `uvm_send_pri(SEQ_OR_ITEM, -1)
  


`define uvm_send_pri(SEQ_OR_ITEM, PRIORITY) \
  begin \
  uvm_sequence_base __seq; \
  if (!$cast(__seq,SEQ_OR_ITEM)) begin \
     start_item(SEQ_OR_ITEM, PRIORITY);\
     finish_item(SEQ_OR_ITEM, PRIORITY);\
  end \
  else __seq.start(__seq.get_sequencer(), this, PRIORITY, 0);\
  end
  


`define uvm_rand_send(SEQ_OR_ITEM) \
  `uvm_rand_send_pri_with(SEQ_OR_ITEM, -1, {})



`define uvm_rand_send_pri(SEQ_OR_ITEM, PRIORITY) \
  `uvm_rand_send_pri_with(SEQ_OR_ITEM, PRIORITY, {})



`define uvm_rand_send_with(SEQ_OR_ITEM, CONSTRAINTS) \
  `uvm_rand_send_pri_with(SEQ_OR_ITEM, -1, CONSTRAINTS)



`define uvm_rand_send_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS) \
  begin \
  uvm_sequence_base __seq; \
  if (!$cast(__seq,SEQ_OR_ITEM)) start_item(SEQ_OR_ITEM, PRIORITY);\
  else __seq.set_item_context(this,SEQ_OR_ITEM.get_sequencer()); \
  if ((__seq == null || !__seq.do_not_randomize) && !SEQ_OR_ITEM.randomize() with CONSTRAINTS ) begin \
    `uvm_warning("RNDFLD", "Randomization failed in uvm_rand_send_with action") \
  end\
  if (!$cast(__seq,SEQ_OR_ITEM)) finish_item(SEQ_OR_ITEM, PRIORITY);\
  else __seq.start(__seq.get_sequencer(), this, PRIORITY, 0);\
  end


`define uvm_create_seq(UVM_SEQ, SEQR_CONS_IF) \
  `uvm_create_on(UVM_SEQ, SEQR_CONS_IF.consumer_seqr) \

`define uvm_do_seq(UVM_SEQ, SEQR_CONS_IF) \
  `uvm_do_on(UVM_SEQ, SEQR_CONS_IF.consumer_seqr) \

`define uvm_do_seq_with(UVM_SEQ, SEQR_CONS_IF, CONSTRAINTS) \
  `uvm_do_on_with(UVM_SEQ, SEQR_CONS_IF.consumer_seqr, CONSTRAINTS) \







`define uvm_add_to_seq_lib(TYPE,LIBTYPE) \
   static bit add_``TYPE``_to_seq_lib_``LIBTYPE =\
      LIBTYPE::m_add_typewide_sequence(TYPE::get_type());




`define uvm_sequence_library_utils(TYPE) \
\
   static protected uvm_object_wrapper m_typewide_sequences[$]; \
   \
   function void init_sequence_library(); \
     foreach (TYPE::m_typewide_sequences[i]) \
       sequences.push_back(TYPE::m_typewide_sequences[i]); \
   endfunction \
   \
   static function void add_typewide_sequence(uvm_object_wrapper seq_type); \
     if (m_static_check(seq_type)) \
       TYPE::m_typewide_sequences.push_back(seq_type); \
   endfunction \
   \
   static function void add_typewide_sequences(uvm_object_wrapper seq_types[$]); \
     foreach (seq_types[i]) \
       TYPE::add_typewide_sequence(seq_types[i]); \
   endfunction \
   \
   static function bit m_add_typewide_sequence(uvm_object_wrapper seq_type); \
     TYPE::add_typewide_sequence(seq_type); \
     return 1; \
   endfunction






`define uvm_declare_p_sequencer(SEQUENCER) \
  SEQUENCER p_sequencer;\
  virtual function void m_set_p_sequencer();\
    super.m_set_p_sequencer(); \
    if( !$cast(p_sequencer, m_sequencer)) \
        `uvm_fatal("DCLPSQ", \
        $sformatf("%m %s Error casting p_sequencer, please verify that this sequence/sequence item is intended to execute on this type of sequencer", get_full_name())) \
  endfunction  


`ifndef UVM_CB_MACROS_SVH
`define UVM_CB_MACROS_SVH




`define uvm_register_cb(T,CB) \
  static local bit m_register_cb_``CB = uvm_callbacks#(T,CB)::m_register_pair(`"T`",`"CB`");



`define uvm_set_super_type(T,ST) \
  static local bit m_register_``T``ST = uvm_derived_callbacks#(T,ST)::register_super_type(`"T`",`"ST`"); 




`define uvm_do_callbacks(T,CB,METHOD) \
  `uvm_do_obj_callbacks(T,CB,this,METHOD)



`define uvm_do_obj_callbacks(T,CB,OBJ,METHOD) \
   begin \
     uvm_callback_iter#(T,CB) iter = new(OBJ); \
     CB cb = iter.first(); \
     while(cb != null) begin \
       `uvm_cb_trace_noobj(cb,$sformatf(`"Executing callback method 'METHOD' for callback %s (CB) from %s (T)`",cb.get_name(), OBJ.get_full_name())) \
       cb.METHOD; \
       cb = iter.next(); \
     end \
   end






`define uvm_do_callbacks_exit_on(T,CB,METHOD,VAL) \
  `uvm_do_obj_callbacks_exit_on(T,CB,this,METHOD,VAL) \



`define uvm_do_obj_callbacks_exit_on(T,CB,OBJ,METHOD,VAL) \
   begin \
     uvm_callback_iter#(T,CB) iter = new(OBJ); \
     CB cb = iter.first(); \
     while(cb != null) begin \
       if (cb.METHOD == VAL) begin \
         `uvm_cb_trace_noobj(cb,$sformatf(`"Executed callback method 'METHOD' for callback %s (CB) from %s (T) : returned value VAL (other callbacks will be ignored)`",cb.get_name(), OBJ.get_full_name())) \
         return VAL; \
       end \
       `uvm_cb_trace_noobj(cb,$sformatf(`"Executed callback method 'METHOD' for callback %s (CB) from %s (T) : did not return value VAL`",cb.get_name(), OBJ.get_full_name())) \
       cb = iter.next(); \
     end \
     return 1-VAL; \
   end



`ifdef UVM_CB_TRACE_ON

`define uvm_cb_trace(OBJ,CB,OPER) \
  begin \
    string msg; \
    msg = (OBJ == null) ? "null" : $sformatf("%s (%s@%0d)", \
      OBJ.get_full_name(), OBJ.get_type_name(), OBJ.get_inst_id()); \
    `uvm_info("UVMCB_TRC", $sformatf("%s: callback %s (%s@%0d) : to object %s",  \
       OPER, CB.get_name(), CB.get_type_name(), CB.get_inst_id(), msg), UVM_NONE) \
  end

`define uvm_cb_trace_noobj(CB,OPER) \
  begin \
    if(uvm_callbacks_base::m_tracing) \
      `uvm_info("UVMCB_TRC", $sformatf("%s : callback %s (%s@%0d)" ,  \
       OPER, CB.get_name(), CB.get_type_name(), CB.get_inst_id()), UVM_NONE) \
  end
`else

`define uvm_cb_trace_noobj(CB,OPER) 
`define uvm_cb_trace(OBJ,CB,OPER) 

`endif


`endif



`ifndef UVM_REG_ADDR_WIDTH
 `define UVM_REG_ADDR_WIDTH 64
`endif


`ifndef UVM_REG_DATA_WIDTH
 `define UVM_REG_DATA_WIDTH 64
`endif


`ifndef UVM_REG_BYTENABLE_WIDTH 
  `define UVM_REG_BYTENABLE_WIDTH ((`UVM_REG_DATA_WIDTH-1)/8+1) 
`endif


`ifndef UVM_REG_CVR_WIDTH
 `define UVM_REG_CVR_WIDTH 32
`endif



`ifndef UVM_NO_DEPRECATED


`define m_uvm_register_sequence(TYPE_NAME, SEQUENCER) \
  static bit is_registered_with_sequencer = SEQUENCER``::add_typewide_sequence(`"TYPE_NAME`");


`define uvm_sequence_utils_begin(TYPE_NAME, SEQUENCER) \
  `m_uvm_register_sequence(TYPE_NAME, SEQUENCER) \
  `uvm_declare_p_sequencer(SEQUENCER) \
  `uvm_object_utils_begin(TYPE_NAME)

`define uvm_sequence_utils_end \
  `uvm_object_utils_end


`define uvm_sequence_utils(TYPE_NAME, SEQUENCER) \
  `uvm_sequence_utils_begin(TYPE_NAME,SEQUENCER) \
  `uvm_sequence_utils_end



`define uvm_declare_sequence_lib \
  protected bit m_set_sequences_called = 1;    \
  static protected string m_static_sequences[$]; \
  static protected string m_static_remove_sequences[$]; \
  \
  static function bit add_typewide_sequence(string type_name); \
    m_static_sequences.push_back(type_name); \
    return 1; \
  endfunction\
  \
  static function bit remove_typewide_sequence(string type_name); \
    m_static_remove_sequences.push_back(type_name); \
    for (int i = 0; i < m_static_sequences.size(); i++) begin \
      if (m_static_sequences[i] == type_name) \
        m_static_sequences.delete(i); \
    end \
    return 1;\
  endfunction\
  \
  function void uvm_update_sequence_lib();\
    if(this.m_set_sequences_called) begin \
      set_sequences_queue(m_static_sequences); \
      this.m_set_sequences_called = 0;\
    end\
    for (int i = 0; i < m_static_remove_sequences.size(); i++) begin \
      remove_sequence(m_static_remove_sequences[i]); \
    end \
  endfunction\




`define uvm_update_sequence_lib \
  m_add_builtin_seqs(0); \
  uvm_update_sequence_lib();



`define uvm_update_sequence_lib_and_item(USER_ITEM) \
  begin   uvm_coreservice_t cs = uvm_coreservice_t::get(); uvm_factory factory=cs.get_factory(); \
  factory.set_inst_override_by_type( \
    uvm_sequence_item::get_type(), USER_ITEM::get_type(), \
  {get_full_name(), "*.item"}); end \
  m_add_builtin_seqs(1); \
  uvm_update_sequence_lib();



`define uvm_sequencer_utils(TYPE_NAME) \
  `uvm_sequencer_utils_begin(TYPE_NAME) \
  `uvm_sequencer_utils_end


`define uvm_sequencer_utils_begin(TYPE_NAME) \
  `uvm_declare_sequence_lib \
  `uvm_component_utils_begin(TYPE_NAME)


`define uvm_sequencer_param_utils(TYPE_NAME) \
  `uvm_sequencer_param_utils_begin(TYPE_NAME) \
  `uvm_sequencer_utils_end


`define uvm_sequencer_param_utils_begin(TYPE_NAME) \
  `uvm_declare_sequence_lib \
  `uvm_component_param_utils_begin(TYPE_NAME)



`define uvm_sequencer_utils_end \
  `uvm_component_utils_end




`define uvm_package(PKG) \
  package PKG; \
  class uvm_bogus_class extends uvm::uvm_sequence;\
  endclass

`define uvm_end_package \
   endpackage



`define uvm_sequence_library_package(PKG_NAME) \
  import PKG_NAME``::*; \
  PKG_NAME``::uvm_bogus_class M_``PKG_NAME``uvm_bogus_class

`endif 

`endif

package uvm_pkg;


`ifndef UVM_DPI_SVH
`define UVM_DPI_SVH


`ifdef UVM_NO_DPI
  `define UVM_HDL_NO_DPI
  `define UVM_REGEX_NO_DPI
  `define UVM_CMDLINE_NO_DPI
`endif




`ifndef UVM_HDL__SVH
`define UVM_HDL__SVH


`ifndef UVM_HDL_MAX_WIDTH
`define UVM_HDL_MAX_WIDTH 1024
`endif

parameter int UVM_HDL_MAX_WIDTH = `UVM_HDL_MAX_WIDTH;


typedef logic [UVM_HDL_MAX_WIDTH-1:0] uvm_hdl_data_t;

                            
`ifndef UVM_HDL_NO_DPI

  import "DPI-C" context function int uvm_hdl_check_path(string path);


  import "DPI-C" context function int uvm_hdl_deposit(string path, uvm_hdl_data_t value);


  import "DPI-C" context function int uvm_hdl_force(string path, uvm_hdl_data_t value);


  task uvm_hdl_force_time(string path, uvm_hdl_data_t value, time force_time = 0);
    if (force_time == 0) begin
      void'(uvm_hdl_deposit(path, value));
      return;
    end
    if (!uvm_hdl_force(path, value))
      return;
    #force_time;
    void'(uvm_hdl_release_and_read(path, value));
  endtask


  import "DPI-C" context function int uvm_hdl_release_and_read(string path, inout uvm_hdl_data_t value);


  import "DPI-C" context function int uvm_hdl_release(string path);


  import "DPI-C" context function int uvm_hdl_read(string path, output uvm_hdl_data_t value);

`else

  function int uvm_hdl_check_path(string path);
    uvm_report_fatal("UVM_HDL_CHECK_PATH", 
      $sformatf("uvm_hdl DPI routines are compiled off. Recompile without +define+UVM_HDL_NO_DPI"));
    return 0;
  endfunction

  function int uvm_hdl_deposit(string path, uvm_hdl_data_t value);
    uvm_report_fatal("UVM_HDL_DEPOSIT", 
      $sformatf("uvm_hdl DPI routines are compiled off. Recompile without +define+UVM_HDL_NO_DPI"));
    return 0;
  endfunction

  function int uvm_hdl_force(string path, uvm_hdl_data_t value);
    uvm_report_fatal("UVM_HDL_FORCE", 
      $sformatf("uvm_hdl DPI routines are compiled off. Recompile without +define+UVM_HDL_NO_DPI"));
    return 0;
  endfunction

  task uvm_hdl_force_time(string path, uvm_hdl_data_t value, time force_time=0);
    uvm_report_fatal("UVM_HDL_FORCE_TIME", 
      $sformatf("uvm_hdl DPI routines are compiled off. Recompile without +define+UVM_HDL_NO_DPI"));
  endtask

  function int uvm_hdl_release(string path, output uvm_hdl_data_t value);
    uvm_report_fatal("UVM_HDL_RELEASE", 
      $sformatf("uvm_hdl DPI routines are compiled off. Recompile without +define+UVM_HDL_NO_DPI"));
    return 0;
  endfunction

  function int uvm_hdl_read(string path, output uvm_hdl_data_t value);
    uvm_report_fatal("UVM_HDL_READ", 
      $sformatf("uvm_hdl DPI routines are compiled off. Recompile without +define+UVM_HDL_NO_DPI"));
    return 0;
  endfunction

`endif


`endif



`ifndef UVM_CMDLINE_NO_DPI
import "DPI-C" function string uvm_dpi_get_next_arg_c (int init);
import "DPI-C" function string uvm_dpi_get_tool_name_c ();
import "DPI-C" function string uvm_dpi_get_tool_version_c ();

function string uvm_dpi_get_next_arg(int init=0);
  return uvm_dpi_get_next_arg_c(init);
endfunction

function string uvm_dpi_get_tool_name();
  return uvm_dpi_get_tool_name_c();
endfunction

function string uvm_dpi_get_tool_version();
  return uvm_dpi_get_tool_version_c();
endfunction

import "DPI-C" function chandle uvm_dpi_regcomp(string regex);
import "DPI-C" function int uvm_dpi_regexec(chandle preg, string str);
import "DPI-C" function void uvm_dpi_regfree(chandle preg);

`else
function string uvm_dpi_get_next_arg(int init=0);
  return "";
endfunction

function string uvm_dpi_get_tool_name();
  return "?";
endfunction

function string uvm_dpi_get_tool_version();
  return "?";
endfunction


function chandle uvm_dpi_regcomp(string regex); return null; endfunction
function int uvm_dpi_regexec(chandle preg, string str); return 0; endfunction
function void uvm_dpi_regfree(chandle preg); endfunction

`endif


`ifndef UVM_REGEX_NO_DPI
import "DPI-C" context function int uvm_re_match(string re, string str);
import "DPI-C" context function void uvm_dump_re_cache();
import "DPI-C" context function string uvm_glob_to_re(string glob);

`else

function int uvm_re_match(string re, string str);
  int e, es, s, ss;
  string tmp;
  e  = 0; s  = 0;
  es = 0; ss = 0;

  if(re.len() == 0)
    return 0;

  if(re[0] == "^")
    re = re.substr(1, re.len()-1);

  while (s != str.len() && re.getc(e) != "*") begin
    if ((re.getc(e) != str.getc(s)) && (re.getc(e) != "?"))
      return 1;
    e++; s++;
  end

  while (s != str.len()) begin
    if (re.getc(e) == "*") begin
      e++;
      if (e == re.len()) begin
        return 0;
      end
      es = e;
      ss = s+1;
    end
    else if (re.getc(e) == str.getc(s) || re.getc(e) == "?") begin
      e++;
      s++;
    end
    else begin
      e = es;
      s = ss++;
    end
  end
  while (e < re.len() && re.getc(e) == "*")
    e++;
  if(e == re.len()) begin
    return 0;
  end
  else begin
    return 1;
  end
endfunction

function void uvm_dump_re_cache();
endfunction

function string uvm_glob_to_re(string glob);
  return glob;
endfunction

`endif


`endif 

`ifndef UVM_BASE_SVH
`define UVM_BASE_SVH

typedef class uvm_cmdline_processor;
typedef class uvm_factory;
typedef class uvm_default_factory;
typedef class uvm_report_server;
typedef class uvm_default_report_server;
typedef class uvm_root;
typedef class uvm_visitor;
typedef class uvm_component_name_check_visitor;
typedef class uvm_component;
typedef class uvm_tr_database;
typedef class uvm_text_tr_database;
   
`ifndef UVM_CORESERVICE_TYPE
`define UVM_CORESERVICE_TYPE uvm_default_coreservice_t
`endif

typedef class `UVM_CORESERVICE_TYPE;


virtual class uvm_coreservice_t;

	pure virtual function uvm_factory get_factory();
	pure virtual function void set_factory(uvm_factory f);
	pure virtual function uvm_report_server get_report_server();
	pure virtual function void set_report_server(uvm_report_server server);
        pure virtual function uvm_tr_database get_default_tr_database();
        pure virtual function void set_default_tr_database(uvm_tr_database db);
	pure virtual function void set_component_visitor(uvm_visitor#(uvm_component) v);
	pure virtual function uvm_visitor#(uvm_component) get_component_visitor();
	pure virtual function uvm_root get_root();
	local static `UVM_CORESERVICE_TYPE inst;
	
	static function uvm_coreservice_t get();
		if(inst==null)
			inst=new;
		return inst;
	endfunction 

endclass

class uvm_default_coreservice_t extends uvm_coreservice_t;

	local uvm_factory factory;
        local uvm_tr_database tr_database;
	local uvm_report_server report_server;

	virtual function uvm_factory get_factory();
		if(factory==null) begin
			uvm_default_factory f;
			f=new;
			factory=f;
		end 

		return factory;
	endfunction

	virtual function void set_factory(uvm_factory f);
		factory = f;
	endfunction 

        virtual function uvm_tr_database get_default_tr_database();
           if (tr_database == null) begin
	           process p = process::self();
	           uvm_text_tr_database tx_db;
	           string s;
	           if(p != null)
	           	s = p.get_randstate();
	           	
	           tx_db = new("default_tr_database");
               tr_database = tx_db;
              
              if(p != null)
              	p.set_randstate(s);
           end
           return tr_database;
        endfunction : get_default_tr_database

        virtual function void set_default_tr_database(uvm_tr_database db);
           tr_database = db;
        endfunction : set_default_tr_database
   
	virtual function uvm_report_server get_report_server();
		if(report_server==null) begin
			uvm_default_report_server f;
			f=new;
			report_server=f;
		end 

		return report_server;
	endfunction 

	virtual function void set_report_server(uvm_report_server server);
		report_server=server;
	endfunction 

	virtual function uvm_root get_root();
		return uvm_root::m_uvm_get_root();
	endfunction
	
	local uvm_visitor#(uvm_component) _visitor;
	virtual function void set_component_visitor(uvm_visitor#(uvm_component) v);
		_visitor=v;
	endfunction
	
	virtual function uvm_visitor#(uvm_component) get_component_visitor();
		if(_visitor==null) begin
			uvm_component_name_check_visitor v = new("name-check-visitor");
			_visitor=v;
		end
		return _visitor;
	endfunction	
	
endclass

`ifndef UVM_VERSION_SVH
`define UVM_VERSION_SVH

parameter string uvm_mgc_copyright  = "(C) 2007-2014 Mentor Graphics Corporation";
parameter string uvm_cdn_copyright  = "(C) 2007-2014 Cadence Design Systems, Inc.";
parameter string uvm_snps_copyright = "(C) 2006-2014 Synopsys, Inc.";
parameter string uvm_cy_copyright   = "(C) 2011-2013 Cypress Semiconductor Corp.";
parameter string uvm_nv_copyright   = "(C) 2013-2014 NVIDIA Corporation";
parameter string uvm_revision = `UVM_VERSION_STRING;

function string uvm_revision_string();
  return uvm_revision;
endfunction

`endif 

bit uvm_start_uvm_declarations = 1;
parameter UVM_STREAMBITS = `UVM_MAX_STREAMBITS; 
typedef logic signed [UVM_STREAMBITS-1:0] uvm_bitstream_t;
typedef logic signed [63:0] uvm_integral_t;

typedef enum {
   UVM_BIN       = 'h1000000,
   UVM_DEC       = 'h2000000,
   UVM_UNSIGNED  = 'h3000000,
   UVM_UNFORMAT2 = 'h4000000,
   UVM_UNFORMAT4 = 'h5000000,
   UVM_OCT       = 'h6000000,
   UVM_HEX       = 'h7000000,
   UVM_STRING    = 'h8000000,
   UVM_TIME      = 'h9000000,
   UVM_ENUM      = 'ha000000,
   UVM_REAL      = 'hb000000,
   UVM_REAL_DEC  = 'hc000000,
   UVM_REAL_EXP  = 'hd000000,
   UVM_NORADIX   = 0
} uvm_radix_enum;

parameter UVM_RADIX = 'hf000000; 

function string uvm_radix_to_string(uvm_radix_enum radix);
  case(radix)
    UVM_BIN:        return "b";
    UVM_OCT:        return "o";
    UVM_DEC:        return "d";
    UVM_HEX:        return "h";
    UVM_UNSIGNED:   return "u";
    UVM_UNFORMAT2:  return "u";
    UVM_UNFORMAT4:  return "z";
    UVM_STRING:     return "s";
    UVM_TIME:       return "t";
    UVM_ENUM:       return "s";
    UVM_REAL:       return "g";
    UVM_REAL_DEC:   return "f";
    UVM_REAL_EXP:   return "e";
    default:        return "x"; 
  endcase
endfunction

typedef enum { 
  UVM_DEFAULT_POLICY = 0, 
  UVM_DEEP           = 'h400, 
  UVM_SHALLOW        = 'h800, 
  UVM_REFERENCE      = 'h1000
 } uvm_recursion_policy_enum;


typedef enum bit { UVM_PASSIVE=0, UVM_ACTIVE=1 } uvm_active_passive_enum;


parameter UVM_MACRO_NUMFLAGS    = 17;
parameter UVM_DEFAULT     = 'b000010101010101;
parameter UVM_ALL_ON      = 'b000000101010101;
parameter UVM_FLAGS_ON    = 'b000000101010101;
parameter UVM_FLAGS_OFF   = 0;

parameter UVM_COPY         = (1<<0);
parameter UVM_NOCOPY       = (1<<1);
parameter UVM_COMPARE      = (1<<2);
parameter UVM_NOCOMPARE    = (1<<3);
parameter UVM_PRINT        = (1<<4);
parameter UVM_NOPRINT      = (1<<5);
parameter UVM_RECORD       = (1<<6);
parameter UVM_NORECORD     = (1<<7);
parameter UVM_PACK         = (1<<8);
parameter UVM_NOPACK       = (1<<9);
parameter UVM_PHYSICAL     = (1<<13);
parameter UVM_ABSTRACT     = (1<<14);
parameter UVM_READONLY     = (1<<15);
parameter UVM_NODEFPRINT   = (1<<16);

parameter UVM_MACRO_EXTRAS   = (1<<UVM_MACRO_NUMFLAGS);
parameter UVM_FLAGS          = UVM_MACRO_EXTRAS+1;
parameter UVM_UNPACK         = UVM_MACRO_EXTRAS+2;
parameter UVM_CHECK_FIELDS   = UVM_MACRO_EXTRAS+3;
parameter UVM_END_DATA_EXTRA = UVM_MACRO_EXTRAS+4;


parameter UVM_START_FUNCS   = UVM_END_DATA_EXTRA+1;
parameter UVM_SET           = UVM_START_FUNCS+1;
parameter UVM_SETINT        = UVM_SET;
parameter UVM_SETOBJ        = UVM_START_FUNCS+2;
parameter UVM_SETSTR        = UVM_START_FUNCS+3;
parameter UVM_END_FUNCS     = UVM_SETSTR;

string uvm_aa_string_key;

typedef enum bit [1:0]
{
  UVM_INFO,
  UVM_WARNING,
  UVM_ERROR,
  UVM_FATAL
} uvm_severity;

`ifndef UVM_NO_DEPRECATED
typedef uvm_severity uvm_severity_type;
`endif

typedef int uvm_action;

typedef enum
{
  UVM_NO_ACTION = 'b0000000,
  UVM_DISPLAY   = 'b0000001,
  UVM_LOG       = 'b0000010,
  UVM_COUNT     = 'b0000100,
  UVM_EXIT      = 'b0001000,
  UVM_CALL_HOOK = 'b0010000,
  UVM_STOP      = 'b0100000,
  UVM_RM_RECORD = 'b1000000
} uvm_action_type;


typedef enum
{
  UVM_NONE   = 0,
  UVM_LOW    = 100,
  UVM_MEDIUM = 200,
  UVM_HIGH   = 300,
  UVM_FULL   = 400,
  UVM_DEBUG  = 500
} uvm_verbosity;

typedef int UVM_FILE;


typedef enum
{
  UVM_PORT ,
  UVM_EXPORT ,
  UVM_IMPLEMENTATION
} uvm_port_type_e;

typedef enum
{
  UVM_SEQ_ARB_FIFO,
  UVM_SEQ_ARB_WEIGHTED,
  UVM_SEQ_ARB_RANDOM,
  UVM_SEQ_ARB_STRICT_FIFO,
  UVM_SEQ_ARB_STRICT_RANDOM,
  UVM_SEQ_ARB_USER
} uvm_sequencer_arb_mode;

typedef uvm_sequencer_arb_mode UVM_SEQ_ARB_TYPE; 

typedef enum
{
  UVM_CREATED   = 1,
  UVM_PRE_START = 2,
  UVM_PRE_BODY  = 4,
  UVM_BODY      = 8,
  UVM_POST_BODY = 16,
  UVM_POST_START= 32,
  UVM_ENDED     = 64,
  UVM_STOPPED   = 128,
  UVM_FINISHED  = 256
} uvm_sequence_state;

typedef uvm_sequence_state uvm_sequence_state_enum; 

typedef enum
{
  UVM_SEQ_LIB_RAND,
  UVM_SEQ_LIB_RANDC,
  UVM_SEQ_LIB_ITEM,
  UVM_SEQ_LIB_USER
} uvm_sequence_lib_mode;


typedef enum { UVM_PHASE_IMP,
               UVM_PHASE_NODE,
               UVM_PHASE_TERMINAL,
               UVM_PHASE_SCHEDULE,
               UVM_PHASE_DOMAIN,
               UVM_PHASE_GLOBAL
} uvm_phase_type;



typedef enum { UVM_PHASE_UNINITIALIZED = 0,
               UVM_PHASE_DORMANT      = 1,
               UVM_PHASE_SCHEDULED    = 2,
               UVM_PHASE_SYNCING      = 4,
               UVM_PHASE_STARTED      = 8,
               UVM_PHASE_EXECUTING    = 16,
               UVM_PHASE_READY_TO_END = 32,
               UVM_PHASE_ENDED        = 64,
               UVM_PHASE_CLEANUP      = 128,
               UVM_PHASE_DONE         = 256,
               UVM_PHASE_JUMPING      = 512
               } uvm_phase_state;

typedef enum { UVM_LT,
               UVM_LTE,
               UVM_NE,
               UVM_EQ,
               UVM_GT,
               UVM_GTE
} uvm_wait_op;

typedef enum { UVM_RAISED      = 'h01, 
               UVM_DROPPED     = 'h02,
               UVM_ALL_DROPPED = 'h04
} uvm_objection_event;


typedef class uvm_printer;
typedef class uvm_table_printer;
typedef class uvm_tree_printer;
typedef class uvm_line_printer;
typedef class uvm_comparer;
typedef class uvm_packer;
typedef class uvm_tr_database;
typedef class uvm_text_tr_database;
typedef class uvm_recorder;


uvm_table_printer uvm_default_table_printer = new();
uvm_tree_printer uvm_default_tree_printer  = new();
uvm_line_printer uvm_default_line_printer  = new();
uvm_printer uvm_default_printer = uvm_default_table_printer;
uvm_packer uvm_default_packer = new();
uvm_comparer uvm_default_comparer = new(); 

virtual class uvm_void;
endclass

typedef enum {UVM_APPEND, UVM_PREPEND} uvm_apprepend;

typedef class uvm_object;

typedef class uvm_coreservice_t;
typedef class uvm_factory;

typedef class uvm_config_db;
typedef uvm_config_db#(uvm_object) m_uvm_config_obj_misc;

class uvm_scope_stack;
  local string m_arg;
  local string m_stack[$];

  function int depth();
    return m_stack.size();
  endfunction
  
  function string get();
    string v;
    if(m_stack.size() == 0) return m_arg;
    get = m_stack[0];
    for(int i=1; i<m_stack.size(); ++i) begin
      v = m_stack[i];
      if(v != "" && (v[0] == "[" || v[0] == "(" || v[0] == "{"))
        get = {get,v};
      else
        get = {get,".",v};
    end
    if(m_arg != "") begin
      if(get != "")
        get = {get, ".", m_arg};
      else
        get = m_arg;
    end
  endfunction
  
  function string get_arg();
    return m_arg;
  endfunction
  
  function void set (string s);
    m_stack.delete();
    
    m_stack.push_back(s);
    m_arg = "";
  endfunction
  
  function void down (string s);
    m_stack.push_back(s);
    m_arg = "";
  endfunction
  
  function void down_element (int element);
    m_stack.push_back($sformatf("[%0d]",element));
    m_arg = "";
  endfunction
  
  function void up_element ();
    string s;
    if(!m_stack.size())
      return;
    s = m_stack.pop_back();
    if(s != "" && s[0] != "[")
      m_stack.push_back(s);
  endfunction
  
  function void up (byte separator =".");
    bit found;
    string s;
    while(m_stack.size() && !found ) begin
      s = m_stack.pop_back();
      if(separator == ".") begin
        if (s == "" || (s[0] != "[" && s[0] != "(" && s[0] != "{"))
          found = 1;
      end
      else begin
        if(s != "" && s[0] == separator)
          found = 1;
      end
    end
    m_arg = "";
  endfunction
  
  function void set_arg (string arg);
    if(arg=="") return;
    m_arg = arg;
  endfunction
  
  function void set_arg_element (string arg, int ele);
    string tmp_value_str;
    tmp_value_str.itoa(ele);
    m_arg = {arg, "[", tmp_value_str, "]"};
  endfunction
  
  function void unset_arg (string arg);
    if(arg == m_arg)
      m_arg = "";
  endfunction

endclass

class uvm_status_container;
  bit             clone = 1;

  bit          warning;
  bit          status;
  uvm_bitstream_t  bitstream;
  int          intv;
  int          element;
  string       stringv;
  string       scratch1;
  string       scratch2;
  string       key;
  uvm_object   object;
  bit          array_warning_done;
  static bit field_array[string];
  static bit print_matches;

  function void do_field_check(string field, uvm_object obj);
   `ifdef UVM_ENABLE_FIELD_CHECKS                                           
    if (field_array.exists(field))
      uvm_report_error("MLTFLD", $sformatf("Field %s is defined multiple times in type '%s'", field, obj.get_type_name()), UVM_NONE);
    `endif
    field_array[field] = 1;
  endfunction

  function string get_function_type (int what);
    case (what)
      UVM_COPY:    return "copy";
      UVM_COMPARE: return "compare";
      UVM_PRINT:   return "print";
      UVM_RECORD:  return "record";
      UVM_PACK:    return "pack";
      UVM_UNPACK:  return "unpack";
      UVM_FLAGS:   return "get_flags";
      UVM_SETINT:  return "set";
      UVM_SETOBJ:  return "set_object";
      UVM_SETSTR:  return "set_string";
      default:     return "unknown";
    endcase
  endfunction

  uvm_scope_stack scope  = new;

  function string get_full_scope_arg ();
    get_full_scope_arg = scope.get();
  endfunction

  bit             cycle_check[uvm_object];
  uvm_comparer    comparer;
  uvm_packer      packer;
  uvm_recorder    recorder;
  uvm_printer     printer;
  
  uvm_object m_uvm_cycle_scopes[$];
  function bit m_do_cycle_check(uvm_object scope);
    uvm_object l = (m_uvm_cycle_scopes.size()==0) ? null : m_uvm_cycle_scopes[$];

    if(l == scope) 
    begin
       m_uvm_cycle_scopes.push_back(scope);
       return 0;
    end
    else
    begin
        uvm_object m[$] = m_uvm_cycle_scopes.find_first(item) with (item == scope);
        if(m.size()!=0) begin
             return 1;    
        end
        else begin
            m_uvm_cycle_scopes.push_back(scope);
            return 0;            
        end
    end
  endfunction
endclass

int unsigned uvm_global_random_seed = $urandom;


class uvm_seed_map;
  int unsigned seed_table [string];
  int unsigned count [string];
endclass

uvm_seed_map uvm_random_seed_table_lookup [string];

function string uvm_instance_scope();
  byte c;
  int pos;

  if(uvm_instance_scope != "") 
    return uvm_instance_scope;

  $swrite(uvm_instance_scope, "%m");
  pos = uvm_instance_scope.len()-1;
  c = uvm_instance_scope[pos];
  while(pos && (c != ".") && (c != ":")) 
    c = uvm_instance_scope[--pos];
  if(pos == 0)
    uvm_report_error("SCPSTR", $sformatf("Illegal name %s in scope string",uvm_instance_scope));
  uvm_instance_scope = uvm_instance_scope.substr(0,pos);
endfunction


parameter UVM_STR_CRC_POLYNOMIAL = 32'h04c11db6;
function int unsigned uvm_oneway_hash ( string string_in, int unsigned seed=0 );
  bit          msb;
  bit [7:0]    current_byte;
  bit [31:0]   crc1;
      
  if(!seed) seed = uvm_global_random_seed;
  uvm_oneway_hash = seed;

  crc1 = 32'hffffffff;
  for (int _byte=0; _byte < string_in.len(); _byte++) begin
     current_byte = string_in[_byte];
     if (current_byte == 0) break;
     for (int _bit=0; _bit < 8; _bit++) begin
        msb = crc1[31];
        crc1 <<= 1;
        if (msb ^ current_byte[_bit]) begin
           crc1 ^=  UVM_STR_CRC_POLYNOMIAL;
           crc1[0] = 1;
        end
     end
  end
  uvm_oneway_hash += ~{crc1[7:0], crc1[15:8], crc1[23:16], crc1[31:24]};

endfunction


function int unsigned uvm_create_random_seed ( string type_id, string inst_id="" );
  uvm_seed_map seed_map;

  if(inst_id == "")
    inst_id = "__global__";

  if(!uvm_random_seed_table_lookup.exists(inst_id))
    uvm_random_seed_table_lookup[inst_id] = new;
  seed_map = uvm_random_seed_table_lookup[inst_id];

  type_id = {uvm_instance_scope(),type_id};

  if(!seed_map.seed_table.exists(type_id)) begin
    seed_map.seed_table[type_id] = uvm_oneway_hash ({type_id,"::",inst_id}, uvm_global_random_seed);
  end
  if (!seed_map.count.exists(type_id)) begin
    seed_map.count[type_id] = 0;
  end

  seed_map.seed_table[type_id] = seed_map.seed_table[type_id]+seed_map.count[type_id]; 
  seed_map.count[type_id]++;

  return seed_map.seed_table[type_id];
endfunction


function string uvm_object_value_str(uvm_object v);
  if (v == null)
    return "<null>";
  uvm_object_value_str.itoa(v.get_inst_id());
  uvm_object_value_str = {"@",uvm_object_value_str};
endfunction


function string uvm_leaf_scope (string full_name, byte scope_separator = ".");
  byte bracket_match;
  int  pos;
  int  bmatches;

  bmatches = 0;
  case(scope_separator)
    "[": bracket_match = "]";
    "(": bracket_match = ")";
    "<": bracket_match = ">";
    "{": bracket_match = "}";
    default: bracket_match = "";
  endcase

  if(bracket_match != "" && bracket_match != full_name[full_name.len()-1])
    bracket_match = "";

  for(pos=full_name.len()-1; pos>0; --pos) begin
    if(full_name[pos] == bracket_match) bmatches++;
    else if(full_name[pos] == scope_separator) begin
      bmatches--;
      if(!bmatches || (bracket_match == "")) break;
    end
  end
  if(pos) begin
    if(scope_separator != ".") pos--;
    uvm_leaf_scope = full_name.substr(pos+1,full_name.len()-1);
  end
  else begin
    uvm_leaf_scope = full_name;
  end
endfunction

function string uvm_bitstream_to_string (uvm_bitstream_t value, int size, uvm_radix_enum radix=UVM_NORADIX, string radix_str="");
  if (radix == UVM_DEC && value[size-1] === 1)
    return $sformatf("%0d", value);

  if($isunknown(value)) begin
	  uvm_bitstream_t _t;
	  _t=0;
	  for(int idx=0;idx<size;idx++)
	    _t[idx]=value[idx];
	  value=_t;
  	end
  else 
  	value &= (1 << size)-1;

  case(radix)
    UVM_BIN:      return $sformatf("%0s%0b", radix_str, value);
    UVM_OCT:      return $sformatf("%0s%0o", radix_str, value);
    UVM_UNSIGNED: return $sformatf("%0s%0d", radix_str, value);
    UVM_STRING:   return $sformatf("%0s%0s", radix_str, value);
    UVM_TIME:     return $sformatf("%0s%0t", radix_str, value);
    UVM_DEC:      return $sformatf("%0s%0d", radix_str, value);
    default:      return $sformatf("%0s%0x", radix_str, value);
  endcase
endfunction

function string uvm_integral_to_string (uvm_integral_t value, int size, uvm_radix_enum radix=UVM_NORADIX, string radix_str="");
  if (radix == UVM_DEC && value[size-1] === 1)
    return $sformatf("%0d", value);

  if($isunknown(value)) begin
	  uvm_integral_t _t;
	  _t=0;
	  for(int idx=0;idx<size;idx++)
	  	_t[idx]=value[idx];
	  value=_t;
  	end
  else 
  	value &= (1 << size)-1;

  case(radix)
    UVM_BIN:      return $sformatf("%0s%0b", radix_str, value);
    UVM_OCT:      return $sformatf("%0s%0o", radix_str, value);
    UVM_UNSIGNED: return $sformatf("%0s%0d", radix_str, value);
    UVM_STRING:   return $sformatf("%0s%0s", radix_str, value);
    UVM_TIME:     return $sformatf("%0s%0t", radix_str, value);
    UVM_DEC:      return $sformatf("%0s%0d", radix_str, value);
    default:      return $sformatf("%0s%0x", radix_str, value);
  endcase
endfunction

function string uvm_vector_to_string(uvm_bitstream_t value, int size, uvm_radix_enum radix=UVM_NORADIX, string radix_str="");
   return uvm_bitstream_to_string(value,size,radix,radix_str);
endfunction 
   
function int uvm_get_array_index_int(string arg, output bit is_wildcard);
  int i;
  uvm_get_array_index_int = 0;
  is_wildcard = 1;
  i = arg.len() - 1;
  if(arg[i] == "]")
    while(i > 0 && (arg[i] != "[")) begin
      --i;
      if((arg[i] == "*") || (arg[i] == "?")) i=0;
      else if((arg[i] < "0") || (arg[i] > "9") && (arg[i] != "[")) begin
        uvm_get_array_index_int = -1; 
        i=0;
      end
    end
  else begin
    is_wildcard = 0;
    return 0;
  end

  if(i>0) begin
    arg = arg.substr(i+1, arg.len()-2);
    uvm_get_array_index_int = arg.atoi(); 
    is_wildcard = 0;
  end
endfunction 
  
function string uvm_get_array_index_string(string arg, output bit is_wildcard);
  int i;
  uvm_get_array_index_string = "";
  is_wildcard = 1;
  i = arg.len() - 1;
  if(arg[i] == "]")
    while(i > 0 && (arg[i] != "[")) begin
      if((arg[i] == "*") || (arg[i] == "?")) i=0;
      --i;
    end
  if(i>0) begin
    uvm_get_array_index_string = arg.substr(i+1, arg.len()-2);
    is_wildcard = 0;
  end
endfunction


function bit uvm_is_array(string arg);
  return arg[arg.len()-1] == "]";
endfunction


function automatic bit uvm_has_wildcard (string arg);
  uvm_has_wildcard = 0;

  if( (arg.len() > 1) && (arg[0] == "/") && (arg[arg.len()-1] == "/") )
    return 1;

  foreach(arg[i])
    if( (arg[i] == "*") || (arg[i] == "+") || (arg[i] == "?") )
      uvm_has_wildcard = 1;

endfunction


typedef class uvm_component;
typedef class uvm_root;
typedef class uvm_report_object;

        
class uvm_utils #(type TYPE=int, string FIELD="config");

  typedef TYPE types_t[$];

  static function types_t find_all(uvm_component start);
    uvm_component list[$];
    types_t types;
    uvm_root top;
    uvm_coreservice_t cs;
    cs = uvm_coreservice_t::get();
    top = cs.get_root();
    top.find_all("*",list,start);
    foreach (list[i]) begin
      TYPE typ;
      if ($cast(typ,list[i]))
        types.push_back(typ);
    end
    if (types.size() == 0) begin
      `uvm_warning("find_type-no match",{"Instance of type '",TYPE::type_name, " not found in component hierarchy beginning at ",start.get_full_name()})
    end
    return types;
  endfunction

  static function TYPE find(uvm_component start);
    types_t types = find_all(start);
    if (types.size() == 0)
      return null;
    if (types.size() > 1) begin
      `uvm_warning("find_type-multi match",{"More than one instance of type '",TYPE::type_name, " found in component hierarchy beginning at ",start.get_full_name()})
      return null;
    end
    return types[0];
  endfunction

  static function TYPE create_type_by_name(string type_name, string contxt);
    uvm_object obj;
    TYPE  typ;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
  
    obj = factory.create_object_by_name(type_name,contxt,type_name);
       if (!$cast(typ,obj))
         uvm_report_error("WRONG_TYPE",{"The type_name given '",type_name, "' with context '",contxt,"' did not produce the expected type."});
    return typ;
  endfunction

  static function TYPE get_config(uvm_component comp, bit is_fatal);
    uvm_object obj;
    TYPE cfg;

    if (!m_uvm_config_obj_misc::get(comp,"",FIELD, obj)) begin
      if (is_fatal)
        comp.uvm_report_fatal("NO_SET_CFG", {"no set_config to field '", FIELD, "' for component '",comp.get_full_name(),"'"}, UVM_MEDIUM, `uvm_file , `uvm_line  );
      else
        comp.uvm_report_warning("NO_SET_CFG", {"no set_config to field '", FIELD, "' for component '",comp.get_full_name(),"'"}, UVM_MEDIUM, `uvm_file , `uvm_line  );
      return null;
    end

    if (!$cast(cfg, obj)) begin
      if (is_fatal)
        comp.uvm_report_fatal( "GET_CFG_TYPE_FAIL", {"set_config_object with field name ",FIELD, " is not of type '",TYPE::type_name,"'"}, UVM_NONE , `uvm_file , `uvm_line );
      else
        comp.uvm_report_warning( "GET_CFG_TYPE_FAIL", {"set_config_object with field name ",FIELD, " is not of type '",TYPE::type_name,"'"}, UVM_NONE , `uvm_file , `uvm_line );
    end

    return cfg;
  endfunction
endclass

`ifdef UVM_USE_PROCESS_CONTAINER
class process_container_c;
   process p;
   function new(process p_);
     p=p_;
   endfunction
endclass
`endif

function automatic string m_uvm_string_queue_join(ref string i[$]);
`ifndef QUESTA
   m_uvm_string_queue_join = {>>{i}};
`else
	foreach(i[idx])
		m_uvm_string_queue_join = {m_uvm_string_queue_join,i[idx]};
`endif
endfunction


typedef class uvm_report_object;
typedef class uvm_object_wrapper;
typedef class uvm_objection;
typedef class uvm_component;


typedef class uvm_status_container;


virtual class uvm_object extends uvm_void;

  static bit use_uvm_seeding = 1;
  local string m_leaf_name;
  local int m_inst_id;
  static protected int m_inst_count;
  local static uvm_object uvm_global_copy_map[uvm_object];
  static uvm_status_container __m_uvm_status_container = new;

  virtual function string get_type_name (); return "<unknown>"; endfunction
  virtual function uvm_object create (string name=""); return null; endfunction

  function new (string name="");
    m_inst_id = m_inst_count++;
    m_leaf_name = name;
  endfunction
  
  function void reseed ();
    if(use_uvm_seeding)
      this.srandom(uvm_create_random_seed(get_type_name(), get_full_name()));
  endfunction
  
  static function uvm_object_wrapper get_type();
    uvm_report_error("NOTYPID", "get_type not implemented in derived class.", UVM_NONE);
    return null;
  endfunction
  
  virtual function int get_inst_id();
    return m_inst_id;
  endfunction
  
  virtual function uvm_object_wrapper get_object_type();
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    if(get_type_name() == "<unknown>") return null;
    return factory.find_wrapper_by_name(get_type_name());
  endfunction
  
  static function int get_inst_count();
    return m_inst_count;
  endfunction
  
  virtual function string get_name ();
    return m_leaf_name;
  endfunction
  
  virtual function string get_full_name ();
    return get_name();
  endfunction
  
  virtual function void set_name (string name);
    m_leaf_name = name;
  endfunction
   
  function void print(uvm_printer printer=null);
    if (printer==null)
      printer = uvm_default_printer;
    if (printer == null)
      `uvm_error("NULLPRINTER","uvm_default_printer is null")
    $fwrite(printer.knobs.mcd,sprint(printer)); 
  endfunction
  
  function string sprint(uvm_printer printer=null);
    bit p;
  
    if(printer==null)
      printer = uvm_default_printer;
  
    if(!printer.istop()) begin
      __m_uvm_status_container.printer = printer;
      __m_uvm_field_automation(null, UVM_PRINT, "");
      do_print(printer);
      return "";
    end
    
    printer.print_object(get_name(), this);
    if (printer.m_string != "")
      return printer.m_string;
  
    return printer.emit();
  
  endfunction
  
  virtual function string convert2string();
    return "";
  endfunction
  
  virtual function void  set_int_local (string      field_name, uvm_bitstream_t value, bit         recurse=1);
    __m_uvm_status_container.cycle_check.delete();
    __m_uvm_status_container.m_uvm_cycle_scopes.delete();
  
    this.__m_uvm_status_container.status = 0;
    this.__m_uvm_status_container.bitstream = value;
  
    __m_uvm_field_automation(null, UVM_SETINT, field_name);
  
    if(__m_uvm_status_container.warning && !this.__m_uvm_status_container.status) begin
      uvm_report_error("NOMTC", $sformatf("did not find a match for field %s", field_name),UVM_NONE);
    end
    __m_uvm_status_container.cycle_check.delete();
  endfunction
  
  virtual function void  set_object_local (string     field_name, uvm_object value, bit        clone=1, bit        recurse=1);
    uvm_object cc;
    __m_uvm_status_container.cycle_check.delete();
    __m_uvm_status_container.m_uvm_cycle_scopes.delete();
  
    if(clone && (value!=null)) begin 
      cc = value.clone();
      if(cc != null) cc.set_name(field_name); 
      value = cc; 
    end 
  
    this.__m_uvm_status_container.status = 0;
    this.__m_uvm_status_container.object = value;
    __m_uvm_status_container.clone = clone;
  
    __m_uvm_field_automation(null, UVM_SETOBJ, field_name);
  
    if(__m_uvm_status_container.warning && !this.__m_uvm_status_container.status) begin
      uvm_report_error("NOMTC", $sformatf("did not find a match for field %s", field_name), UVM_NONE);
    end
    __m_uvm_status_container.cycle_check.delete();  
  
  endfunction
  
  virtual function void  set_string_local (string field_name, string value, bit    recurse=1);
                                               
    __m_uvm_status_container.cycle_check.delete();
    __m_uvm_status_container.m_uvm_cycle_scopes.delete();
  
    this.__m_uvm_status_container.status = 0;
    this.__m_uvm_status_container.stringv = value;
  
    __m_uvm_field_automation(null, UVM_SETSTR, field_name);
  
    if(__m_uvm_status_container.warning && !this.__m_uvm_status_container.status) begin
      uvm_report_error("NOMTC", $sformatf("did not find a match for field %s (@%0d)", field_name, this.get_inst_id()), UVM_NONE);
    end
    __m_uvm_status_container.cycle_check.delete();
  endfunction
  
  virtual function uvm_object clone();
    uvm_object tmp;
    tmp = this.create(get_name());
    if(tmp == null)
      uvm_report_warning("CRFLD", $sformatf("The create method failed for %s,  object cannot be cloned", get_name()), UVM_NONE);
    else
      tmp.copy(this);
    return(tmp);
  endfunction
  
  function void copy (uvm_object rhs);
    static int depth;
    if((rhs !=null)  && uvm_global_copy_map.exists(rhs)) begin
      return;
    end
  
    if(rhs==null) begin
      uvm_report_warning("NULLCP", "A null object was supplied to copy; copy is ignored", UVM_NONE);
      return;
    end
  
    uvm_global_copy_map[rhs]= this; 
    ++depth;
  
    __m_uvm_field_automation(rhs, UVM_COPY, "");
    do_copy(rhs);
  
    --depth;
    if(depth==0) begin
      uvm_global_copy_map.delete();
    end
  endfunction
  
  virtual function void do_copy (uvm_object rhs);
    return;
  endfunction
  
  
  function bit  compare (uvm_object rhs, uvm_comparer comparer=null);
    bit t, dc;
    static int style;
    bit done;
    done = 0;
    if(comparer != null) 
      __m_uvm_status_container.comparer = comparer;
    else 
      __m_uvm_status_container.comparer = uvm_default_comparer;
    comparer = __m_uvm_status_container.comparer;
  
    if(!__m_uvm_status_container.scope.depth()) begin
      comparer.compare_map.delete();
      comparer.result = 0;
      comparer.miscompares = "";
      comparer.scope = __m_uvm_status_container.scope;
      if(get_name() == "")
        __m_uvm_status_container.scope.down("<object>");
      else
        __m_uvm_status_container.scope.down(this.get_name());
    end
    if(!done && (rhs == null)) begin
      if(__m_uvm_status_container.scope.depth()) begin
        comparer.print_msg_object(this, rhs);
      end
      else begin
        comparer.print_msg_object(this, rhs);
        uvm_report_info("MISCMP", $sformatf("%0d Miscompare(s) for object %s@%0d vs. null", comparer.result, __m_uvm_status_container.scope.get(), this.get_inst_id()), __m_uvm_status_container.comparer.verbosity);
        done = 1;
      end
    end
  
    if(!done && comparer.compare_map.exists(rhs)) begin
      if(comparer.compare_map[rhs] != this) begin
        comparer.print_msg_object(this, comparer.compare_map[rhs]);
      end 
      done = 1;  
    end
  
    if(!done && comparer.check_type && (rhs != null) && (get_type_name() != rhs.get_type_name())) begin
      __m_uvm_status_container.stringv = { "lhs type = \"", get_type_name(), "\" : rhs type = \"", rhs.get_type_name(), "\""};
      comparer.print_msg(__m_uvm_status_container.stringv);
    end
  
    if(!done) begin
      comparer.compare_map[rhs]= this;
      __m_uvm_field_automation(rhs, UVM_COMPARE, "");
      dc = do_compare(rhs, comparer);
    end
  
    if(__m_uvm_status_container.scope.depth()==1)  begin
      __m_uvm_status_container.scope.up();
    end
  
    if(rhs != null)
      comparer.print_rollup(this, rhs);
    return (comparer.result == 0 && dc == 1);
  endfunction
  
  virtual function bit  do_compare (uvm_object rhs, uvm_comparer comparer);
    return 1;
  endfunction
  
  virtual function void __m_uvm_field_automation (uvm_object tmp_data__, int        what__, string     str__ );
    return;
  endfunction
  
  
  virtual function void do_print(uvm_printer printer);
    return;
  endfunction
  
  local function void m_pack (inout uvm_packer packer);
  
    if(packer!=null) 
      __m_uvm_status_container.packer = packer;
    else  
      __m_uvm_status_container.packer = uvm_default_packer;
    packer = __m_uvm_status_container.packer;
  
    packer.reset();
    packer.scope.down(get_name());
  
    __m_uvm_field_automation(null, UVM_PACK, "");
    do_pack(packer);
  
    packer.set_packed_size();
  
    packer.scope.up(); 
  
  endfunction
    
  function int pack (ref bit bitstream [], input uvm_packer packer =null );
    m_pack(packer);
    packer.get_bits(bitstream);
    return packer.get_packed_size();
  endfunction
  
  function int pack_bytes (ref byte unsigned bytestream [], input uvm_packer packer=null );
    m_pack(packer);
    packer.get_bytes(bytestream);
    return packer.get_packed_size();
  endfunction
  
  function int pack_ints (ref int unsigned intstream [], input uvm_packer packer=null );
    m_pack(packer);
    packer.get_ints(intstream);
    return packer.get_packed_size();
  endfunction
  
  virtual function void do_pack (uvm_packer packer );
    return;
  endfunction
    
  local function void m_unpack_pre (inout uvm_packer packer);
    if(packer!=null)
      __m_uvm_status_container.packer = packer;
    else
      __m_uvm_status_container.packer = uvm_default_packer;
    packer = __m_uvm_status_container.packer;
    packer.reset();
  endfunction
  
  local function void m_unpack_post (uvm_packer packer);
  
    int provided_size; 
  
    provided_size = packer.get_packed_size();
  
    packer.scope.down(get_name());
  
    __m_uvm_field_automation(null, UVM_UNPACK, "");
  
    do_unpack(packer);
  
    packer.scope.up();
  
    if(packer.get_packed_size() != provided_size) begin
      uvm_report_warning("BDUNPK", $sformatf("Unpack operation unsuccessful: unpacked %0d bits from a total of %0d bits", packer.get_packed_size(), provided_size), UVM_NONE);
    end
  
  endfunction
  
  function int unpack (ref    bit        bitstream [], input  uvm_packer packer=null);
    m_unpack_pre(packer);
    packer.put_bits(bitstream);
    m_unpack_post(packer);
    packer.set_packed_size();
    return packer.get_packed_size();
  endfunction
  
  function int unpack_bytes (ref    byte unsigned bytestream [], input  uvm_packer packer=null);
    m_unpack_pre(packer);
    packer.put_bytes(bytestream);
    m_unpack_post(packer);
    packer.set_packed_size();
    return packer.get_packed_size();
  endfunction
    
  function int unpack_ints (ref    int unsigned intstream [], input  uvm_packer packer=null);
    m_unpack_pre(packer);
    packer.put_ints(intstream);
    m_unpack_post(packer);
    packer.set_packed_size();
    return packer.get_packed_size();
  endfunction
  
  virtual function void do_unpack (uvm_packer packer);
    return;
  endfunction
  
  function void record (uvm_recorder recorder=null);
  
    if(recorder == null)
      return;
  
    __m_uvm_status_container.recorder = recorder;
    recorder.recording_depth++;
    __m_uvm_field_automation(null, UVM_RECORD, "");
    do_record(recorder);
  
    recorder.recording_depth--;
  
  endfunction
  
  virtual function void do_record (uvm_recorder recorder);
    return;
  endfunction
  
  protected virtual function uvm_report_object m_get_report_object();
    return null;
  endfunction

endclass

class uvm_pool #(type KEY=int, T=uvm_void) extends uvm_object;

  const static string type_name = "uvm_pool";
  typedef uvm_pool #(KEY,T) this_type;
  static protected this_type m_global_pool;
  protected T pool[KEY];

  function new (string name="");
    super.new(name);
  endfunction

  static function this_type get_global_pool ();
    if (m_global_pool==null)
      m_global_pool = new("pool");
    return m_global_pool;
  endfunction

  static function T get_global (KEY key);
    this_type gpool;
    gpool = get_global_pool(); 
    return gpool.get(key);
  endfunction

  virtual function T get (KEY key);
    if (!pool.exists(key)) begin
      T default_value;
      pool[key] = default_value;
    end
    return pool[key];
  endfunction

  virtual function void add (KEY key, T item);
    pool[key] = item;
  endfunction

  virtual function int num ();
    return pool.num();
  endfunction

  virtual function void delete (KEY key);
    if (!exists(key)) begin
      uvm_report_warning("POOLDEL", $sformatf("delete: pool key doesn't exist. Ignoring delete request"));
      return;
    end
    pool.delete(key);
  endfunction

  virtual function int exists (KEY key);
    return pool.exists(key);
  endfunction

  virtual function int first (ref KEY key);
    return pool.first(key);
  endfunction

  virtual function int last (ref KEY key);
    return pool.last(key);
  endfunction

  virtual function int next (ref KEY key);
    return pool.next(key);
  endfunction

  virtual function int prev (ref KEY key);
    return pool.prev(key);
  endfunction

  virtual function uvm_object create (string name=""); 
    this_type v;
    v=new(name);
    return v;
  endfunction

  virtual function string get_type_name ();
    return type_name;
  endfunction

  virtual function void do_copy (uvm_object rhs);
    this_type p;
    KEY key;
    super.do_copy(rhs);
    if (rhs==null || !$cast(p, rhs))
      return;
    pool = p.pool;
  endfunction

  virtual function void do_print (uvm_printer printer);
    string v;
    int cnt;
    string item;
    KEY key;
    printer.print_array_header("pool",pool.num(),"aa_object_string");
    if (pool.first(key))
      do begin
        item.itoa(cnt);
        item = {"[-key",item,"--]"};
        $swrite(v,pool[key]);
        printer.print_generic(item,"",-1,v,"[");
      end
      while (pool.next(key));
    printer.print_array_footer();
  endfunction

endclass

class uvm_object_string_pool #(type T=uvm_object) extends uvm_pool #(string,T);

  typedef uvm_object_string_pool #(T) this_type;
  static protected this_type m_global_pool;
  const static string type_name = {"uvm_obj_str_pool"};

  function new (string name="");
    super.new(name);
  endfunction

  virtual function string get_type_name();
    return type_name;
  endfunction

  static function this_type get_global_pool ();
    if (m_global_pool==null)
      m_global_pool = new("global_pool");
    return m_global_pool;
  endfunction

  static function T get_global (string key);
    this_type gpool;
    gpool = get_global_pool(); 
    return gpool.get(key);
  endfunction

  virtual function T get (string key);
    if (!pool.exists(key))
      pool[key] = new (key);
    return pool[key];
  endfunction

  virtual function void delete (string key);
    if (!exists(key)) begin
      uvm_report_warning("POOLDEL", $sformatf("delete: key '%s' doesn't exist", key));
      return;
    end
    pool.delete(key);
  endfunction

  virtual function void do_print (uvm_printer printer);
    string key;
    printer.print_array_header("pool",pool.num(),"aa_object_string");
    if (pool.first(key))
      do
        printer.print_object({"[",key,"]"}, pool[key],"[");
      while (pool.next(key));
    printer.print_array_footer();
  endfunction

endclass


typedef class uvm_barrier;
typedef class uvm_event;
typedef uvm_object_string_pool #(uvm_barrier) uvm_barrier_pool;
typedef uvm_object_string_pool #(uvm_event#(uvm_object)) uvm_event_pool;

`ifndef UVM_QUEUE_SVH
`define UVM_QUEUE_SVH

class uvm_queue #(type T=int) extends uvm_object;

  const static string type_name = "uvm_queue";
  typedef uvm_queue #(T) this_type;
  static local this_type m_global_queue;
  protected T queue[$];

  function new (string name="");
    super.new(name);
  endfunction

  static function this_type get_global_queue ();
    if (m_global_queue==null)
      m_global_queue = new("global_queue");
    return m_global_queue;
  endfunction

  static function T get_global (int index);
    this_type gqueue;
    gqueue = get_global_queue(); 
    return gqueue.get(index);
  endfunction

  virtual function T get (int index);
    T default_value;
    if (index >= size() || index < 0) begin
      uvm_report_warning("QUEUEGET", $sformatf("get: given index out of range for queue of size %0d. Ignoring get request",size()));
      return default_value;
    end
    return queue[index];
  endfunction

  virtual function int size ();
    return queue.size();
  endfunction

  virtual function void insert (int index, T item);
    if (index >= size() || index < 0) begin
      uvm_report_warning("QUEUEINS", $sformatf("insert: given index out of range for queue of size %0d. Ignoring insert request",size()));
      return;
    end
    queue.insert(index,item);
  endfunction

  virtual function void delete (int index=-1);
    if (index >= size() || index < -1) begin
      uvm_report_warning("QUEUEDEL", $sformatf("delete: given index out of range for queue of size %0d. Ignoring delete request",size()));
      return;
    end
    if (index == -1)
      queue.delete();
    else
      queue.delete(index);
  endfunction

  virtual function T pop_front();
    return queue.pop_front();
  endfunction

  virtual function T pop_back();
    return queue.pop_back();
  endfunction

  virtual function void push_front(T item);
    queue.push_front(item);
  endfunction

  virtual function void push_back(T item);
    queue.push_back(item);
  endfunction

  virtual function uvm_object create (string name=""); 
    this_type v;
    v=new(name);
    return v;
  endfunction

  virtual function string get_type_name ();
    return type_name;
  endfunction

  virtual function void do_copy (uvm_object rhs);
    this_type p;
    super.do_copy(rhs);
    if (rhs == null || !$cast(p, rhs))
      return;
    queue = p.queue;
  endfunction
  
  virtual function string convert2string();
      return $sformatf("%p",queue);
  endfunction

endclass

`endif 

typedef class uvm_object;
typedef class uvm_component;
typedef class uvm_object_wrapper;
typedef class uvm_factory_override;

class uvm_factory_queue_class;
  uvm_factory_override queue[$];
endclass
  
virtual class uvm_factory;
 
  static function uvm_factory get();
	  	uvm_coreservice_t s;
	  	s = uvm_coreservice_t::get();
	  	return s.get_factory();
  endfunction	
  
  pure virtual function void register (uvm_object_wrapper obj);

  pure virtual function void set_inst_override_by_type (uvm_object_wrapper original_type, uvm_object_wrapper override_type, string full_inst_path);

  pure virtual function void set_inst_override_by_name (string original_type_name, string override_type_name, string full_inst_path);

  pure virtual function void set_type_override_by_type (uvm_object_wrapper original_type, uvm_object_wrapper override_type, bit replace=1);

  pure virtual function void set_type_override_by_name (string original_type_name, string override_type_name, bit replace=1);

  pure virtual function uvm_object    create_object_by_type    (uvm_object_wrapper requested_type,  string parent_inst_path="", string name=""); 

  pure virtual function uvm_component create_component_by_type (uvm_object_wrapper requested_type,  string parent_inst_path="", string name, uvm_component parent);

  pure virtual function uvm_object    create_object_by_name    (string requested_type_name,  string parent_inst_path="", string name=""); 

  pure virtual function uvm_component create_component_by_name (string requested_type_name,  string parent_inst_path="", string name, uvm_component parent);

  pure virtual function void debug_create_by_type (uvm_object_wrapper requested_type, string parent_inst_path="", string name="");

  pure virtual function void debug_create_by_name (string requested_type_name, string parent_inst_path="", string name="");

  pure virtual function uvm_object_wrapper find_override_by_type (uvm_object_wrapper requested_type, string full_inst_path);

  pure virtual function uvm_object_wrapper find_override_by_name (string requested_type_name, string full_inst_path);

  pure virtual function uvm_object_wrapper find_wrapper_by_name            (string type_name);

  pure  virtual function void print (int all_types=1);

endclass 
    
class uvm_default_factory extends uvm_factory;
   
  protected bit                  m_types[uvm_object_wrapper];
  protected bit                  m_lookup_strs[string];
  protected uvm_object_wrapper   m_type_names[string];
  protected uvm_factory_override m_type_overrides[$];
  protected uvm_factory_queue_class m_inst_override_queues[uvm_object_wrapper];
  protected uvm_factory_queue_class m_inst_override_name_queues[string];
  protected uvm_factory_override    m_wildcard_inst_overrides[$];
  local uvm_factory_override     m_override_info[$];
  local static bit m_debug_pass;

  function void register (uvm_object_wrapper obj);
  
    if (obj == null) begin
      uvm_report_fatal ("NULLWR", "Attempting to register a null object with the factory", UVM_NONE);
    end
    if (obj.get_type_name() != "" && obj.get_type_name() != "<unknown>") begin
      if (m_type_names.exists(obj.get_type_name()))
        uvm_report_warning("TPRGED", {"Type name '",obj.get_type_name(), "' already registered with factory. No string-based lookup ", "support for multiple types with the same type name."}, UVM_NONE);
      else 
        m_type_names[obj.get_type_name()] = obj;
    end
  
    if (m_types.exists(obj)) begin
      if (obj.get_type_name() != "" && obj.get_type_name() != "<unknown>")
        uvm_report_warning("TPRGED", {"Object type '",obj.get_type_name(), "' already registered with factory. "}, UVM_NONE);
    end
    else begin
      m_types[obj] = 1;
      if(m_inst_override_name_queues.exists(obj.get_type_name())) begin
         m_inst_override_queues[obj] = new;
         m_inst_override_queues[obj].queue = m_inst_override_name_queues[obj.get_type_name()].queue;
         m_inst_override_name_queues.delete(obj.get_type_name());
      end
      if(m_wildcard_inst_overrides.size()) begin
         if(! m_inst_override_queues.exists(obj)) 
              m_inst_override_queues[obj] = new;
         foreach (m_wildcard_inst_overrides[i]) begin
           if(uvm_is_match( m_wildcard_inst_overrides[i].orig_type_name, obj.get_type_name()))
              m_inst_override_queues[obj].queue.push_back(m_wildcard_inst_overrides[i]);
         end
      end
    end
  endfunction
  
  function void set_type_override_by_type (uvm_object_wrapper original_type, uvm_object_wrapper override_type, bit replace=1);
    bit replaced;
  
    if (original_type == override_type) begin
      if (original_type.get_type_name() == "" || original_type.get_type_name() == "<unknown>")
        uvm_report_warning("TYPDUP", {"Original and override type ", "arguments are identical"}, UVM_NONE);
      else
        uvm_report_warning("TYPDUP", {"Original and override type ", "arguments are identical: ", original_type.get_type_name()}, UVM_NONE);
    end
  
    if (!m_types.exists(original_type))
      register(original_type); 
  
    if (!m_types.exists(override_type))
      register(override_type); 
  
  
    foreach (m_type_overrides[index]) begin
      if (m_type_overrides[index].orig_type == original_type || (m_type_overrides[index].orig_type_name != "<unknown>" && m_type_overrides[index].orig_type_name != "" && m_type_overrides[index].orig_type_name == original_type.get_type_name())) begin
        string msg;
        msg = {"Original object type '",original_type.get_type_name(), "' already registered to produce '", m_type_overrides[index].ovrd_type_name,"'"};
        if (!replace) begin
          msg = {msg, ".  Set 'replace' argument to replace the existing entry."};
          uvm_report_info("TPREGD", msg, UVM_MEDIUM);
          return;
        end
        msg = {msg, ".  Replacing with override to produce type '", override_type.get_type_name(),"'."};
        uvm_report_info("TPREGR", msg, UVM_MEDIUM);
        replaced = 1;
        m_type_overrides[index].orig_type = original_type; 
        m_type_overrides[index].orig_type_name = original_type.get_type_name(); 
        m_type_overrides[index].ovrd_type = override_type; 
        m_type_overrides[index].ovrd_type_name = override_type.get_type_name(); 
      end
    end
  
    if (!replaced) begin
      uvm_factory_override override;
      override = new(.orig_type(original_type), .orig_type_name(original_type.get_type_name()), .full_inst_path("*"), .ovrd_type(override_type));
      m_type_overrides.push_back(override);
    end
  
  endfunction
  
  function void set_type_override_by_name (string original_type_name, string override_type_name, bit replace=1);
    bit replaced;
    
    uvm_object_wrapper original_type;
    uvm_object_wrapper override_type;
  
    if(m_type_names.exists(original_type_name))
      original_type = m_type_names[original_type_name];
  
    if(m_type_names.exists(override_type_name))
      override_type = m_type_names[override_type_name];
  
    if (override_type == null) begin
        uvm_report_error("TYPNTF", {"Cannot register override for original type '", original_type_name,"' because the override type '", override_type_name, "' is not registered with the factory."}, UVM_NONE);
      return;
    end
  
    if (original_type_name == override_type_name) begin
        uvm_report_warning("TYPDUP", {"Requested and actual type name ", " arguments are identical: ",original_type_name,". Ignoring this override."}, UVM_NONE);
      return;
    end
  
    foreach (m_type_overrides[index]) begin
      if (m_type_overrides[index].orig_type_name == original_type_name) begin
        if (!replace) begin
          uvm_report_info("TPREGD", {"Original type '",original_type_name, "' already registered to produce '",m_type_overrides[index].ovrd_type_name, "'.  Set 'replace' argument to replace the existing entry."}, UVM_MEDIUM);
          return;
        end
        uvm_report_info("TPREGR", {"Original object type '",original_type_name, "' already registered to produce '",m_type_overrides[index].ovrd_type_name, "'.  Replacing with override to produce type '",override_type_name,"'."}, UVM_MEDIUM);
        replaced = 1;
        m_type_overrides[index].ovrd_type = override_type; 
        m_type_overrides[index].ovrd_type_name = override_type_name; 
      end
    end
  
    if (original_type == null)
      m_lookup_strs[original_type_name] = 1;
  
    if (!replaced) begin
      uvm_factory_override override;
      override = new(.orig_type(original_type), .orig_type_name(original_type_name), .full_inst_path("*"), .ovrd_type(override_type));
      m_type_overrides.push_back(override);
    end
  
  endfunction
  
  function bit check_inst_override_exists (uvm_object_wrapper original_type, uvm_object_wrapper override_type, string full_inst_path);
    uvm_factory_override override;
    uvm_factory_queue_class qc;
  
    if (m_inst_override_queues.exists(original_type))
      qc = m_inst_override_queues[original_type];
    else
      return 0;
  
    for (int index=0; index<qc.queue.size(); ++index) begin
  
      override = qc.queue[index]; 
      if (override.full_inst_path == full_inst_path && override.orig_type == original_type && override.ovrd_type == override_type && override.orig_type_name == original_type.get_type_name()) begin
      uvm_report_info("DUPOVRD",{"Instance override for '", original_type.get_type_name(),"' already exists: override type '", override_type.get_type_name(),"' with full_inst_path '", full_inst_path,"'"},UVM_HIGH);
        return 1;
      end
    end
    return 0;
  endfunction
  
  function void set_inst_override_by_type (uvm_object_wrapper original_type, uvm_object_wrapper override_type, string full_inst_path);
    
    uvm_factory_override override;
  
    if (!m_types.exists(original_type))
      register(original_type); 
  
    if (!m_types.exists(override_type))
      register(override_type); 
  
    if (check_inst_override_exists(original_type,override_type,full_inst_path))
      return;
  
    if(!m_inst_override_queues.exists(original_type))
      m_inst_override_queues[original_type] = new;
  
    override = new(.full_inst_path(full_inst_path), .orig_type(original_type), .orig_type_name(original_type.get_type_name()), .ovrd_type(override_type));
  
  
    m_inst_override_queues[original_type].queue.push_back(override);
  
  endfunction
  
  function void set_inst_override_by_name (string original_type_name, string override_type_name, string full_inst_path);
    
    uvm_factory_override override;
    uvm_object_wrapper original_type;
    uvm_object_wrapper override_type;
  
    if(m_type_names.exists(original_type_name))
      original_type = m_type_names[original_type_name];
  
    if(m_type_names.exists(override_type_name))
      override_type = m_type_names[override_type_name];
  
    if (override_type == null) begin
      uvm_report_error("TYPNTF", {"Cannot register instance override with type name '", original_type_name,"' and instance path '",full_inst_path,"' because the type it's supposed ", "to produce, '",override_type_name,"', is not registered with the factory."}, UVM_NONE);
      return;
    end
  
    if (original_type == null)
        m_lookup_strs[original_type_name] = 1;
  
    override = new(.full_inst_path(full_inst_path), .orig_type(original_type), .orig_type_name(original_type_name), .ovrd_type(override_type));
  
    if(original_type != null) begin
      if (check_inst_override_exists(original_type,override_type,full_inst_path))
        return;
      if(!m_inst_override_queues.exists(original_type))
        m_inst_override_queues[original_type] = new;
      m_inst_override_queues[original_type].queue.push_back(override);
    end 
    else begin
      if(m_has_wildcard(original_type_name)) begin
         foreach(m_type_names[i]) begin
           if(uvm_is_match(original_type_name,i)) begin
             this.set_inst_override_by_name(i, override_type_name, full_inst_path);
           end
         end
         m_wildcard_inst_overrides.push_back(override);
      end
      else begin
        if(!m_inst_override_name_queues.exists(original_type_name))
          m_inst_override_name_queues[original_type_name] = new;
        m_inst_override_name_queues[original_type_name].queue.push_back(override);
      end
    end
  
  endfunction
  
  function bit m_has_wildcard(string nm);
    foreach (nm[i]) 
      if(nm[i] == "*" || nm[i] == "?") return 1;
    return 0;
  endfunction
  
  function uvm_object create_object_by_name (string requested_type_name,  string parent_inst_path="",  string name=""); 
  
    uvm_object_wrapper wrapper;
    string inst_path;
  
    if (parent_inst_path == "")
      inst_path = name;
    else if (name != "")
      inst_path = {parent_inst_path,".",name};
    else
      inst_path = parent_inst_path;
  
    m_override_info.delete();
  
    wrapper = find_override_by_name(requested_type_name, inst_path);
  
    if (wrapper==null) begin
      if(!m_type_names.exists(requested_type_name)) begin
        uvm_report_warning("BDTYP",{"Cannot create an object of type '", requested_type_name,"' because it is not registered with the factory."}, UVM_NONE);
        return null;
      end
      wrapper = m_type_names[requested_type_name];
    end
  
    return wrapper.create_object(name);
  
  endfunction
  
  function uvm_object create_object_by_type (uvm_object_wrapper requested_type,  string parent_inst_path="",  string name=""); 
  
    string full_inst_path;
  
    if (parent_inst_path == "")
      full_inst_path = name;
    else if (name != "")
      full_inst_path = {parent_inst_path,".",name};
    else
      full_inst_path = parent_inst_path;
  
    m_override_info.delete();
  
    requested_type = find_override_by_type(requested_type, full_inst_path);
  
    return requested_type.create_object(name);
  
  endfunction
  
  function uvm_component create_component_by_name (string requested_type_name,  string parent_inst_path="",  string name, uvm_component parent);
    uvm_object_wrapper wrapper;
    string inst_path;
  
    if (parent_inst_path == "")
      inst_path = name;
    else if (name != "")
      inst_path = {parent_inst_path,".",name};
    else
      inst_path = parent_inst_path;
  
    m_override_info.delete();
  
    wrapper = find_override_by_name(requested_type_name, inst_path);
  
    if (wrapper == null) begin
      if(!m_type_names.exists(requested_type_name)) begin 
        uvm_report_warning("BDTYP",{"Cannot create a component of type '", requested_type_name,"' because it is not registered with the factory."}, UVM_NONE);
        return null;
      end
      wrapper = m_type_names[requested_type_name];
    end
  
    return wrapper.create_component(name, parent);
  
  endfunction
  
  function uvm_component create_component_by_type (uvm_object_wrapper requested_type,  string parent_inst_path="",  string name, uvm_component parent);
    string full_inst_path;
  
    if (parent_inst_path == "")
      full_inst_path = name;
    else if (name != "")
      full_inst_path = {parent_inst_path,".",name};
    else
      full_inst_path = parent_inst_path;
  
    m_override_info.delete();
  
    requested_type = find_override_by_type(requested_type, full_inst_path);
  
    return requested_type.create_component(name, parent);
  
  endfunction
  
  
  function uvm_object_wrapper find_wrapper_by_name(string type_name);
  
    if (m_type_names.exists(type_name))
      return m_type_names[type_name];
  
    uvm_report_warning("UnknownTypeName", {"find_wrapper_by_name: Type name '",type_name, "' not registered with the factory."}, UVM_NONE);
    
  endfunction
  
  function uvm_object_wrapper find_override_by_name (string requested_type_name, string full_inst_path);
    uvm_object_wrapper rtype;
    uvm_factory_queue_class qc;
    uvm_factory_override lindex;
  
    uvm_object_wrapper override;
  
    if (m_type_names.exists(requested_type_name))
      rtype = m_type_names[requested_type_name];
  
    if (full_inst_path != "") begin
      if(rtype == null) begin
        if(m_inst_override_name_queues.exists(requested_type_name))
          qc = m_inst_override_name_queues[requested_type_name];
      end
      else begin
        if(m_inst_override_queues.exists(rtype))
          qc = m_inst_override_queues[rtype];
      end
      if(qc != null)
        for(int index = 0; index<qc.queue.size(); ++index) begin
          if (uvm_is_match(qc.queue[index].orig_type_name, requested_type_name) &&
              uvm_is_match(qc.queue[index].full_inst_path, full_inst_path)) begin
            m_override_info.push_back(qc.queue[index]);
            if (m_debug_pass) begin
              if (override == null) begin
                override = qc.queue[index].ovrd_type;
                qc.queue[index].selected = 1;
                lindex=qc.queue[index];
              end
            end
            else begin
  	        qc.queue[index].used++;
              if (qc.queue[index].ovrd_type.get_type_name() == requested_type_name)
                return qc.queue[index].ovrd_type;
              else 
                return find_override_by_type(qc.queue[index].ovrd_type,full_inst_path);
            end
          end
        end
    end
  
    if(rtype != null && !m_inst_override_queues.exists(rtype) && m_wildcard_inst_overrides.size()) begin
       m_inst_override_queues[rtype] = new;
       foreach (m_wildcard_inst_overrides[i]) begin
         if(uvm_is_match(m_wildcard_inst_overrides[i].orig_type_name, requested_type_name))
           m_inst_override_queues[rtype].queue.push_back(m_wildcard_inst_overrides[i]);
       end
    end
  
    foreach (m_type_overrides[index])
      if (m_type_overrides[index].orig_type_name == requested_type_name) begin
        m_override_info.push_back(m_type_overrides[index]);
        if (m_debug_pass) begin
          if (override == null) begin
            override = m_type_overrides[index].ovrd_type;
            m_type_overrides[index].selected = 1;
            lindex=m_type_overrides[index];
          end
        end
        else begin
  	    m_type_overrides[index].used++;
          return find_override_by_type(m_type_overrides[index].ovrd_type,full_inst_path);
        end
      end
  
    if (m_debug_pass && override != null) begin
  	lindex.used++;
      return find_override_by_type(override, full_inst_path);
    end	
  
    return null;
  
  endfunction
  
  function uvm_object_wrapper find_override_by_type(uvm_object_wrapper requested_type, string full_inst_path);
  
    uvm_object_wrapper override;
    uvm_factory_override lindex;
    
    uvm_factory_queue_class qc;
    qc = m_inst_override_queues.exists(requested_type) ?  m_inst_override_queues[requested_type] : null;
  
    foreach (m_override_info[index]) begin
      if (m_override_info[index].orig_type == requested_type) begin
        uvm_report_error("OVRDLOOP", "Recursive loop detected while finding override.", UVM_NONE);
        if (!m_debug_pass)
          debug_create_by_type (requested_type, full_inst_path);
  
  	  m_override_info[index].used++;
        return requested_type;
      end
    end
  
    if (full_inst_path != "" && qc != null)
      for (int index = 0; index < qc.queue.size(); ++index) begin
        if ((qc.queue[index].orig_type == requested_type || (qc.queue[index].orig_type_name != "<unknown>" && qc.queue[index].orig_type_name != "" && qc.queue[index].orig_type_name == requested_type.get_type_name())) && uvm_is_match(qc.queue[index].full_inst_path, full_inst_path)) begin
          m_override_info.push_back(qc.queue[index]);
          if (m_debug_pass) begin
            if (override == null) begin
              override = qc.queue[index].ovrd_type;
              qc.queue[index].selected = 1;
              lindex=qc.queue[index];
            end
          end
          else begin
  	      qc.queue[index].used++;	        
            if (qc.queue[index].ovrd_type == requested_type)
              return requested_type;
            else
              return find_override_by_type(qc.queue[index].ovrd_type,full_inst_path);
          end
        end
      end
  
    foreach (m_type_overrides[index]) begin
      if (m_type_overrides[index].orig_type == requested_type ||
          (m_type_overrides[index].orig_type_name != "<unknown>" && m_type_overrides[index].orig_type_name != "" && requested_type != null && m_type_overrides[index].orig_type_name == requested_type.get_type_name())) begin
	  m_override_info.push_back(m_type_overrides[index]);
        if (m_debug_pass) begin
          if (override == null) begin
            override = m_type_overrides[index].ovrd_type;
            m_type_overrides[index].selected = 1;
            lindex=m_type_overrides[index];
          end
        end
        else begin
  	    m_type_overrides[index].used++;	      
          if (m_type_overrides[index].ovrd_type == requested_type)
            return requested_type;
          else
            return find_override_by_type(m_type_overrides[index].ovrd_type,full_inst_path);
        end
      end
    end
  
  
    if (m_debug_pass && override != null) begin
      lindex.used++;	  
      if (override == requested_type) begin
        return requested_type;
      end	
      else
        return find_override_by_type(override,full_inst_path);
    end	
    
    return requested_type;
  
  endfunction
  
  function void print (int all_types=1);
  
    string key;
    uvm_factory_queue_class sorted_override_queues[string];
    string qs[$];
  
    string tmp;
    int id;
    uvm_object_wrapper obj;
  
    foreach (m_inst_override_queues[i]) begin
      obj = i;
      tmp = obj.get_type_name();
      if(tmp == "") $swrite(tmp, "__unnamed_id_%0d", id++);
      sorted_override_queues[tmp] = m_inst_override_queues[i];
  
    end
    foreach (m_inst_override_name_queues[i]) begin
      sorted_override_queues[i] = m_inst_override_name_queues[i];
    end
  
    qs.push_back("\n#### Factory Configuration (*)\n\n");
  
    if(!m_type_overrides.size() && !sorted_override_queues.num())
      qs.push_back("  No instance or type overrides are registered with this factory\n");
    else begin
      int max1,max2,max3;
      string dash = "---------------------------------------------------------------------------------------------------";
      string space= "                                                                                                   ";
  
      if(!sorted_override_queues.num())
        qs.push_back("No instance overrides are registered with this factory\n");
      else begin
        foreach(sorted_override_queues[j]) begin
          uvm_factory_queue_class qc;
          qc = sorted_override_queues[j];
          for (int i=0; i<qc.queue.size(); ++i) begin
            if (qc.queue[i].orig_type_name.len() > max1)
              max1=qc.queue[i].orig_type_name.len();
            if (qc.queue[i].full_inst_path.len() > max2)
              max2=qc.queue[i].full_inst_path.len();
            if (qc.queue[i].ovrd_type_name.len() > max3)
              max3=qc.queue[i].ovrd_type_name.len();
          end
        end
        if (max1 < 14) max1 = 14;
        if (max2 < 13) max2 = 13;
        if (max3 < 13) max3 = 13;
  
        qs.push_back("Instance Overrides:\n\n");
        qs.push_back($sformatf("  %0s%0s  %0s%0s  %0s%0s\n","Requested Type",space.substr(1,max1-14), "Override Path", space.substr(1,max2-13), "Override Type", space.substr(1,max3-13)));
        qs.push_back($sformatf("  %0s  %0s  %0s\n",dash.substr(1,max1), dash.substr(1,max2), dash.substr(1,max3)));
  
        foreach(sorted_override_queues[j]) begin
          uvm_factory_queue_class qc;
          qc = sorted_override_queues[j];
          for (int i=0; i<qc.queue.size(); ++i) begin
            qs.push_back($sformatf("  %0s%0s  %0s%0s",qc.queue[i].orig_type_name, space.substr(1,max1-qc.queue[i].orig_type_name.len()), qc.queue[i].full_inst_path, space.substr(1,max2-qc.queue[i].full_inst_path.len())));
            qs.push_back($sformatf("  %0s\n",     qc.queue[i].ovrd_type_name));
          end
        end
      end
  
      if (!m_type_overrides.size())
        qs.push_back("\nNo type overrides are registered with this factory\n");
      else begin
        if (max1 < 14) max1 = 14;
        if (max2 < 13) max2 = 13;
        if (max3 < 13) max3 = 13;
  
        foreach (m_type_overrides[i]) begin
          if (m_type_overrides[i].orig_type_name.len() > max1)
            max1=m_type_overrides[i].orig_type_name.len();
          if (m_type_overrides[i].ovrd_type_name.len() > max2)
            max2=m_type_overrides[i].ovrd_type_name.len();
        end
        if (max1 < 14) max1 = 14;
        if (max2 < 13) max2 = 13;
        qs.push_back("\nType Overrides:\n\n");
        qs.push_back($sformatf("  %0s%0s  %0s%0s\n","Requested Type",space.substr(1,max1-14), "Override Type", space.substr(1,max2-13))); qs.push_back($sformatf("  %0s  %0s\n",dash.substr(1,max1), dash.substr(1,max2)));
        foreach (m_type_overrides[index]) 
          qs.push_back($sformatf("  %0s%0s  %0s\n", m_type_overrides[index].orig_type_name, space.substr(1,max1-m_type_overrides[index].orig_type_name.len()), m_type_overrides[index].ovrd_type_name));
      end
    end
  
    if (all_types >= 1 && m_type_names.first(key)) begin
      bit banner;
      qs.push_back($sformatf("\nAll types registered with the factory: %0d total\n",m_types.num()));
      do begin
        if (!(all_types < 2 && uvm_is_match("uvm_*",
             m_type_names[key].get_type_name())) &&
             key == m_type_names[key].get_type_name()) begin
          if (!banner) begin
            qs.push_back("  Type Name\n");
            qs.push_back("  ---------\n");
            banner=1;
          end
          qs.push_back($sformatf("  %s\n", m_type_names[key].get_type_name()));
        end
      end while(m_type_names.next(key));
    end
  
    qs.push_back("(*) Types with no associated type name will be printed as <unknown>\n\n####\n\n");
  
    `uvm_info("UVM/FACTORY/PRINT",`UVM_STRING_QUEUE_STREAMING_PACK(qs),UVM_NONE)
  
  endfunction
  
  function void  debug_create_by_name (string requested_type_name, string parent_inst_path="", string name="");
    m_debug_create(requested_type_name, null, parent_inst_path, name);
  endfunction
  
  function void  debug_create_by_type (uvm_object_wrapper requested_type, string parent_inst_path="", string name="");
    m_debug_create("", requested_type, parent_inst_path, name);
  endfunction
  
  protected function void  m_debug_create (string requested_type_name, uvm_object_wrapper requested_type, string parent_inst_path, string name);
  
    string full_inst_path;
    uvm_object_wrapper result;
    
    if (parent_inst_path == "")
      full_inst_path = name;
    else if (name != "")
      full_inst_path = {parent_inst_path,".",name};
    else
      full_inst_path = parent_inst_path;
  
    m_override_info.delete();
  
    if (requested_type == null) begin
      if (!m_type_names.exists(requested_type_name) &&
        !m_lookup_strs.exists(requested_type_name)) begin
        uvm_report_warning("Factory Warning", {"The factory does not recognize '", requested_type_name,"' as a registered type."}, UVM_NONE);
        return;
      end
      m_debug_pass = 1;
      
      result = find_override_by_name(requested_type_name,full_inst_path);
    end
    else begin
      m_debug_pass = 1;
      if (!m_types.exists(requested_type))
        register(requested_type); 
      result = find_override_by_type(requested_type,full_inst_path);
      if (requested_type_name == "")
        requested_type_name = requested_type.get_type_name();
    end
  
    m_debug_display(requested_type_name, result, full_inst_path);
    m_debug_pass = 0;
  
    foreach (m_override_info[index])
      m_override_info[index].selected = 0;
  
  endfunction
  
  protected function void  m_debug_display (string requested_type_name, uvm_object_wrapper result, string full_inst_path);
  
    int    max1,max2,max3;
    string dash = "---------------------------------------------------------------------------------------------------";
    string space= "                                                                                                   ";
    string qs[$];
  
    qs.push_back("\n#### Factory Override Information (*)\n\n");
    qs.push_back( $sformatf("Given a request for an object of type '%s' with an instance\npath of '%s' the factory encountered\n\n", requested_type_name,full_inst_path));
  
    if (m_override_info.size() == 0)
      qs.push_back("no relevant overrides.\n\n");
    else begin
  
      qs.push_back("the following relevant overrides. An 'x' next to a match indicates a\nmatch that was ignored.\n\n");
  
      foreach (m_override_info[i]) begin
        if (m_override_info[i].orig_type_name.len() > max1)
          max1=m_override_info[i].orig_type_name.len();
        if (m_override_info[i].full_inst_path.len() > max2)
          max2=m_override_info[i].full_inst_path.len();
        if (m_override_info[i].ovrd_type_name.len() > max3)
          max3=m_override_info[i].ovrd_type_name.len();
      end
  
      if (max1 < 13) max1 = 13;
      if (max2 < 13) max2 = 13;
      if (max3 < 13) max3 = 13;
  
      qs.push_back($sformatf("Original Type%0s  Instance Path%0s  Override Type%0s\n", space.substr(1,max1-13),space.substr(1,max2-13),space.substr(1,max3-13)));
  
      qs.push_back($sformatf("  %0s  %0s  %0s\n",dash.substr(1,max1),
                                 dash.substr(1,max2),
                                 dash.substr(1,max3)));
  
      foreach (m_override_info[i]) begin
        qs.push_back($sformatf("%s%0s%0s\n", m_override_info[i].selected ? "  " : "x ", m_override_info[i].orig_type_name, space.substr(1,max1-m_override_info[i].orig_type_name.len()))); qs.push_back($sformatf("  %0s%0s", m_override_info[i].full_inst_path, space.substr(1,max2-m_override_info[i].full_inst_path.len())));
        qs.push_back($sformatf("  %0s%0s", m_override_info[i].ovrd_type_name, space.substr(1,max3-m_override_info[i].ovrd_type_name.len())));
        if (m_override_info[i].full_inst_path == "*")
          qs.push_back("  <type override>");
        else
          qs.push_back("\n");
      end
      qs.push_back("\n");
    end
  
  
    qs.push_back("Result:\n\n");
    qs.push_back($sformatf("  The factory will produce an object of type '%0s'\n", result == null ? requested_type_name : result.get_type_name()));
  
    qs.push_back("\n(*) Types with no associated type name will be printed as <unknown>\n\n####\n\n");
    
    `uvm_info("UVM/FACTORY/DUMP",`UVM_STRING_QUEUE_STREAMING_PACK(qs),UVM_NONE)
  endfunction


endclass

virtual class uvm_object_wrapper;

  virtual function uvm_object create_object (string name="");
    return null;
  endfunction

  virtual function uvm_component create_component (string name, uvm_component parent); 
    return null;
  endfunction

  pure virtual function string get_type_name();

endclass

class uvm_factory_override;
  string full_inst_path;
  string orig_type_name;
  string ovrd_type_name;
  bit selected;
  int unsigned used;
  uvm_object_wrapper orig_type;
  uvm_object_wrapper ovrd_type;
  function new (string full_inst_path="", string orig_type_name="", uvm_object_wrapper orig_type=null, uvm_object_wrapper ovrd_type);
    if (ovrd_type == null) begin
      uvm_report_fatal ("NULLWR", "Attempting to register a null override object with the factory", UVM_NONE);
    end
    this.full_inst_path= full_inst_path;
    this.orig_type_name = orig_type == null ? orig_type_name : orig_type.get_type_name();
    this.orig_type      = orig_type;
    this.ovrd_type_name = ovrd_type.get_type_name();
    this.ovrd_type      = ovrd_type;
  endfunction
endclass

`ifndef UVM_REGISTRY_SVH
`define UVM_REGISTRY_SVH

class uvm_component_registry #(type T=uvm_component, string Tname="<unknown>") extends uvm_object_wrapper;

  typedef uvm_component_registry #(T,Tname) this_type;
  const static string type_name = Tname;
  local static this_type me = get();

  virtual function uvm_component create_component (string name, uvm_component parent);
    T obj;
    obj = new(name, parent);
    return obj;
  endfunction

  virtual function string get_type_name();
    return type_name;
  endfunction

  static function this_type get();
    if (me == null) begin
  	  uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
  	  uvm_factory factory=cs.get_factory();
      me = new;
      factory.register(me);
    end
    return me;
  endfunction

  static function T create(string name, uvm_component parent, string contxt="");
    uvm_object obj;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    if (contxt == "" && parent != null)
      contxt = parent.get_full_name();
    obj = factory.create_component_by_type(get(),contxt,name,parent);
    if (!$cast(create, obj)) begin
      string msg;
      msg = {"Factory did not return a component of type '",type_name, "'. A component of type '",obj == null ? "null" : obj.get_type_name(), "' was returned instead. Name=",name," Parent=", parent==null?"null":parent.get_type_name()," contxt=",contxt};
      uvm_report_fatal("FCTTYP", msg, UVM_NONE);
    end
  endfunction

  static function void set_type_override (uvm_object_wrapper override_type, bit replace=1);
    uvm_coreservice_t cs = uvm_coreservice_t::get();
    uvm_factory factory=cs.get_factory();                                          
    factory.set_type_override_by_type(get(),override_type,replace);
  endfunction

  static function void set_inst_override(uvm_object_wrapper override_type, string inst_path, uvm_component parent=null);
    string full_inst_path;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    
    if (parent != null) begin
      if (inst_path == "")
        inst_path = parent.get_full_name();
      else
        inst_path = {parent.get_full_name(),".",inst_path};
    end
    factory.set_inst_override_by_type(get(),override_type,inst_path);
  endfunction

endclass

class uvm_object_registry #(type T=uvm_object, string Tname="<unknown>") extends uvm_object_wrapper;

  typedef uvm_object_registry #(T,Tname) this_type;
  const static string type_name = Tname;
  local static this_type me = get();

  virtual function uvm_object create_object(string name="");
    T obj;
`ifdef UVM_OBJECT_DO_NOT_NEED_CONSTRUCTOR
    obj = new();
    if (name!="")
      obj.set_name(name);
`else
    if (name=="") obj = new();
    else obj = new(name);
`endif
    return obj;
  endfunction

  virtual function string get_type_name();
    return type_name;
  endfunction

  static function this_type get();
    if (me == null) begin
      uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
      uvm_factory factory=cs.get_factory();
      me = new;
      factory.register(me);
    end
    return me;
  endfunction

  static function T create (string name="", uvm_component parent=null, string contxt="");
    uvm_object obj;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
  
    if (contxt == "" && parent != null)
      contxt = parent.get_full_name();
    obj = factory.create_object_by_type(get(),contxt,name);
    if (!$cast(create, obj)) begin
      string msg;
      msg = {"Factory did not return an object of type '",type_name, "'. A component of type '",obj == null ? "null" : obj.get_type_name(), "' was returned instead. Name=",name," Parent=", parent==null?"null":parent.get_type_name()," contxt=",contxt};
      uvm_report_fatal("FCTTYP", msg, UVM_NONE);
    end
  endfunction

  static function void set_type_override (uvm_object_wrapper override_type, bit replace=1);
    uvm_coreservice_t cs = uvm_coreservice_t::get();
    uvm_factory factory=cs.get_factory();
    factory.set_type_override_by_type(get(),override_type,replace);
  endfunction



  static function void set_inst_override(uvm_object_wrapper override_type, string inst_path, uvm_component parent=null);
    string full_inst_path;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    
    if (parent != null) begin
      if (inst_path == "")
        inst_path = parent.get_full_name();
      else
        inst_path = {parent.get_full_name(),".",inst_path};
    end
    factory.set_inst_override_by_type(get(),override_type,inst_path);
  endfunction

endclass


`endif 

class uvm_spell_chkr #(type T=int);

  typedef T tab_t[string];
  static const int unsigned max = '1;
   
  static function bit check (ref tab_t strtab, input string s);

    string key;
    int distance;
    int unsigned min;
    string min_key[$];

    if(strtab.exists(s)) begin
      return 1;
    end

    min = max;
    foreach(strtab[key]) begin
      distance = levenshtein_distance(key, s);

      if(distance < 0)
        continue;

      if(distance < min) begin
        min = distance;
        min_key.delete();
        min_key.push_back(key);
        continue;
      end

      if(distance == min) begin
        min_key.push_back(key);
      end

    end


    if(min == max) begin
	  `uvm_info("UVM/CONFIGDB/SPELLCHK",$sformatf("%s not located, no alternatives to suggest", s),UVM_NONE)
    end	
    else
    begin
	   	string q[$];
	    
	   	foreach(min_key[i]) begin
     			q.push_back(min_key[i]);
     			q.push_back("|");
	   	end
	   	if(q.size())
	   		void'(q.pop_back());
	   		
	   	`uvm_info("UVM/CONFIGDB/SPELLCHK",$sformatf("%s not located, did you mean %s", s, `UVM_STRING_QUEUE_STREAMING_PACK(q)),UVM_NONE)
    end	
    
    return 0;

  endfunction

  static local function int levenshtein_distance(string s, string t);

    int k, i, j, n, m, cost, distance;
    int d[];

    n = s.len() + 1;
    m = t.len() + 1;

    if(n == 1 || m == 1)
      return -1; 

    d = new[m*n];

    for(k = 0; k < n; k++)
      d[k] = k;

    for(k = 0; k < m; k++)
      d[k*n] = k;

    for(i = 1; i < n; i++) begin
      for(j = 1; j < m; j++) begin

        cost = !(s[i-1] == t[j-1]);

        d[j*n+i] = minimum(d[(j-1)*n+i]+1, d[j*n+i-1]+1, d[(j-1)*n+i-1]+cost);

      end
    end

    distance = d[n*m-1];
    return distance;

  endfunction

  static local function int minimum(int a, int b, int c);

    int min = a;

    if(b < min)
      min = b;
    if(c < min)
      min = c;

    return min;

  endfunction

endclass

typedef class uvm_resource_base; 

class uvm_resource_types;

  typedef bit[1:0] override_t;
  typedef enum override_t { TYPE_OVERRIDE = 2'b01,
                            NAME_OVERRIDE = 2'b10 } override_e;

  typedef uvm_queue#(uvm_resource_base) rsrc_q_t;

  typedef enum { PRI_HIGH, PRI_LOW } priority_e;

  typedef struct
  {
    time read_time;
    time write_time;
    int unsigned read_count;
    int unsigned write_count;
  } access_t;

endclass

class uvm_resource_options;

  static local bit auditing = 1;


  static function void turn_on_auditing();
    auditing = 1;
  endfunction


  static function void turn_off_auditing();
    auditing = 0;
  endfunction


  static function bit is_auditing();
    return auditing;
  endfunction
endclass

virtual class uvm_resource_base extends uvm_object;

  protected string scope;
  protected bit modified;
  protected bit read_only;
  uvm_resource_types::access_t access[string];
  int unsigned precedence;
  static int unsigned default_precedence = 1000;

  function new(string name = "", string s = "*");
    super.new(name);
    set_scope(s);
    modified = 0;
    read_only = 0;
    precedence = default_precedence;
  endfunction

  pure virtual function uvm_resource_base get_type_handle();

  function void set_read_only();
    read_only = 1;
  endfunction

  function void set_read_write();
    read_only = 0;
  endfunction

  function bit is_read_only();
    return read_only;
  endfunction

  task wait_modified();
    wait (modified == 1);
    modified = 0;
  endtask

  function void set_scope(string s);
    scope = uvm_glob_to_re(s);
  endfunction

  function string get_scope();
    return scope;
  endfunction

  function bit match_scope(string s);
    int err = uvm_re_match(scope, s);
    return (err == 0);
  endfunction

  pure virtual function void set_priority (uvm_resource_types::priority_e pri);

  function string convert2string();
    return "?";
  endfunction

  function void do_print (uvm_printer printer);
    printer.print_string("",$sformatf("%s [%s] : %s", get_name(), get_scope(), convert2string()));
  endfunction

  function void record_read_access(uvm_object accessor = null);

    string str;
    uvm_resource_types::access_t access_record;


    if(!uvm_resource_options::is_auditing())
      return;

    if(accessor != null)
      str = accessor.get_full_name();
    else
      str = "<empty>";

    if(access.exists(str))
      access_record = access[str];
    else
      init_access_record(access_record);

    access_record.read_count++;
    access_record.read_time = $realtime;
    access[str] = access_record;

  endfunction

  function void record_write_access(uvm_object accessor = null);

    string str;


    if(uvm_resource_options::is_auditing()) begin
      if(accessor != null) begin
        uvm_resource_types::access_t access_record;
        string str;
        str = accessor.get_full_name();
        if(access.exists(str))
          access_record = access[str];
        else
          init_access_record(access_record);
        access_record.write_count++;
        access_record.write_time = $realtime;
        access[str] = access_record;
      end
    end
  endfunction

  virtual function void print_accessors();

    string str;
    uvm_component comp;
    uvm_resource_types::access_t access_record;
    string qs[$];
    
    if(access.num() == 0)
      return;

    foreach (access[i]) begin
      str = i;
      access_record = access[str];
      qs.push_back($sformatf("%s reads: %0d @ %0t  writes: %0d @ %0t\n",str, access_record.read_count, access_record.read_time, access_record.write_count, access_record.write_time));
    end
    `uvm_info("UVM/RESOURCE/ACCESSOR",`UVM_STRING_QUEUE_STREAMING_PACK(qs),UVM_NONE)

  endfunction

  function void init_access_record (inout uvm_resource_types::access_t access_record);
    access_record.read_time = 0;
    access_record.write_time = 0;
    access_record.read_count = 0;
    access_record.write_count = 0;
  endfunction
endclass


class get_t;
  string name;
  string scope;
  uvm_resource_base rsrc;
  time t;
endclass

class uvm_resource_pool;

  static local uvm_resource_pool rp = get();

  uvm_resource_types::rsrc_q_t rtab [string];
  uvm_resource_types::rsrc_q_t ttab [uvm_resource_base];

  get_t get_record [$];  

  local function new();
  endfunction

  static function uvm_resource_pool get();
    if(rp == null)
      rp = new();
    return rp;
  endfunction

  function bit spell_check(string s);
    return uvm_spell_chkr#(uvm_resource_types::rsrc_q_t)::check(rtab, s);
  endfunction

  function void set (uvm_resource_base rsrc, uvm_resource_types::override_t override = 0);

    uvm_resource_types::rsrc_q_t rq;
    string name;
    uvm_resource_base type_handle;

    if(rsrc == null)
      return;

    name = rsrc.get_name();
    if(name != "") begin
      if(rtab.exists(name))
        rq = rtab[name];
      else
        rq = new();

      if(override & uvm_resource_types::NAME_OVERRIDE)
        rq.push_front(rsrc);
      else
        rq.push_back(rsrc);

      rtab[name] = rq;
    end

    type_handle = rsrc.get_type_handle();
    if(ttab.exists(type_handle))
      rq = ttab[type_handle];
    else
      rq = new();

    if(override & uvm_resource_types::TYPE_OVERRIDE)
      rq.push_front(rsrc);
    else
      rq.push_back(rsrc);
    ttab[type_handle] = rq;

  endfunction

  function void set_override(uvm_resource_base rsrc);
    set(rsrc, (uvm_resource_types::NAME_OVERRIDE | uvm_resource_types::TYPE_OVERRIDE));
  endfunction

  function void set_name_override(uvm_resource_base rsrc);
    set(rsrc, uvm_resource_types::NAME_OVERRIDE);
  endfunction

  function void set_type_override(uvm_resource_base rsrc);
    set(rsrc, uvm_resource_types::TYPE_OVERRIDE);
  endfunction

  function void push_get_record(string name, string scope, uvm_resource_base rsrc);
    get_t impt;

    if(!uvm_resource_options::is_auditing())
      return;

    impt = new();

    impt.name  = name;
    impt.scope = scope;
    impt.rsrc  = rsrc;
    impt.t     = $realtime;

    get_record.push_back(impt);
  endfunction

  function void dump_get_records();

    get_t record;
    bit success;
    string qs[$];

    qs.push_back("--- resource get records ---\n");
    foreach (get_record[i]) begin
      record = get_record[i];
      success = (record.rsrc != null);
      qs.push_back($sformatf("get: name=%s  scope=%s  %s @ %0t\n", record.name, record.scope, ((success)?"success":"fail"), record.t));
    end
    `uvm_info("UVM/RESOURCE/GETRECORD",`UVM_STRING_QUEUE_STREAMING_PACK(qs),UVM_NONE)
  endfunction

  function uvm_resource_types::rsrc_q_t lookup_name(string scope = "", string name, uvm_resource_base type_handle = null, bit rpterr = 1);
    uvm_resource_types::rsrc_q_t rq;
    uvm_resource_types::rsrc_q_t q;
    uvm_resource_base rsrc;
    uvm_resource_base r;

     begin
	process p = process::self();
	string s;
	if(p!=null) s=p.get_randstate();
	q=new();
	if(p!=null) p.set_randstate(s);
     end

     
    if(name == "")
      return q;

    if(!rtab.exists(name)) begin
	    if(rpterr) void'(spell_check(name));	
		return q;
    end	

    rsrc = null;
    rq = rtab[name];
    for(int i=0; i<rq.size(); ++i) begin 
      r = rq.get(i);
      if(((type_handle == null) || (r.get_type_handle() == type_handle)) && r.match_scope(scope))
        q.push_back(r);
    end

    return q;

  endfunction

  function uvm_resource_base get_highest_precedence(ref uvm_resource_types::rsrc_q_t q);

    uvm_resource_base rsrc;
    uvm_resource_base r;
    int unsigned i;
    int unsigned prec;

    if(q.size() == 0)
      return null;

    rsrc = q.get(0);
    prec = rsrc.precedence;

    for(int i = 1; i < q.size(); ++i) begin
      r = q.get(i);
      if(r.precedence > prec) begin
        rsrc = r;
        prec = r.precedence;
      end
    end

    return rsrc;

  endfunction

  static function void sort_by_precedence(ref uvm_resource_types::rsrc_q_t q);
    uvm_resource_types::rsrc_q_t all[int];
    uvm_resource_base r;
    for(int i=0; i<q.size(); ++i) begin
      r = q.get(i);
      if(!all.exists(r.precedence))
         all[r.precedence] = new;
      all[r.precedence].push_front(r); 
    end
    q.delete();
    foreach(all[i]) begin
      for(int j=0; j<all[i].size(); ++j) begin
        r = all[i].get(j);
        q.push_front(r);
      end
    end
  endfunction

  function uvm_resource_base get_by_name(string scope = "", string name, uvm_resource_base type_handle, bit rpterr = 1);

    uvm_resource_types::rsrc_q_t q;
    uvm_resource_base rsrc;

    q = lookup_name(scope, name, type_handle, rpterr);

    if(q.size() == 0) begin
      push_get_record(name, scope, null);
      return null;
    end

    rsrc = get_highest_precedence(q);
    push_get_record(name, scope, rsrc);
    return rsrc;
    
  endfunction

  function uvm_resource_types::rsrc_q_t lookup_type(string scope = "", uvm_resource_base type_handle); uvm_resource_types::rsrc_q_t q = new();
    uvm_resource_types::rsrc_q_t rq;
    uvm_resource_base r;
    int unsigned i;

    if(type_handle == null || !ttab.exists(type_handle)) begin
      return q;
    end

    rq = ttab[type_handle];
    for(int i = 0; i < rq.size(); ++i) begin 
      r = rq.get(i);
      if(r.match_scope(scope))
        q.push_back(r);
    end

    return q;

  endfunction

  function uvm_resource_base get_by_type(string scope = "", uvm_resource_base type_handle); uvm_resource_types::rsrc_q_t q;
    uvm_resource_base rsrc;

    q = lookup_type(scope, type_handle);

    if(q.size() == 0) begin
      push_get_record("<type>", scope, null);
      return null;
    end

    rsrc = q.get(0);
    push_get_record("<type>", scope, rsrc);
    return rsrc;
    
  endfunction

  function uvm_resource_types::rsrc_q_t lookup_regex_names(string scope, string name, uvm_resource_base type_handle = null); return lookup_name(scope, name, type_handle, 0);
  endfunction

  function uvm_resource_types::rsrc_q_t lookup_regex(string re, scope);

    uvm_resource_types::rsrc_q_t rq;
    uvm_resource_types::rsrc_q_t result_q;
    int unsigned i;
    uvm_resource_base r;

    re = uvm_glob_to_re(re);
    result_q = new();

    foreach (rtab[name]) begin
      if(uvm_re_match(re, name))
        continue;
      rq = rtab[name];
      for(i = 0; i < rq.size(); i++) begin
        r = rq.get(i);
        if(r.match_scope(scope))
          result_q.push_back(r);
      end
    end

    return result_q;

  endfunction

  function uvm_resource_types::rsrc_q_t lookup_scope(string scope);

    uvm_resource_types::rsrc_q_t rq;
    uvm_resource_base r;
    int unsigned i;

    int unsigned err;
    uvm_resource_types::rsrc_q_t q = new();

    string name;
    if(rtab.last(name)) begin
    do begin
      rq = rtab[name];
      for(int i = 0; i < rq.size(); ++i) begin
        r = rq.get(i);
        if(r.match_scope(scope)) begin
          q.push_back(r);
        end
      end
    end while(rtab.prev(name));
    end

    return q;
    
  endfunction

  local function void set_priority_queue(uvm_resource_base rsrc, ref uvm_resource_types::rsrc_q_t q, uvm_resource_types::priority_e pri);

    uvm_resource_base r;
    int unsigned i;

    string msg;
    string name = rsrc.get_name();

    for(i = 0; i < q.size(); i++) begin
      r = q.get(i);
      if(r == rsrc) break;
    end

    if(r != rsrc) begin
      $sformat(msg, "Handle for resource named %s is not in the name name; cannot change its priority", name);
      uvm_report_error("NORSRC", msg);
      return;
    end

    q.delete(i);

    case(pri)
      uvm_resource_types::PRI_HIGH: q.push_front(rsrc);
      uvm_resource_types::PRI_LOW:  q.push_back(rsrc);
    endcase

  endfunction

  function void set_priority_type(uvm_resource_base rsrc, uvm_resource_types::priority_e pri);

    uvm_resource_base type_handle;
    string msg;
    uvm_resource_types::rsrc_q_t q;

    if(rsrc == null) begin
      uvm_report_warning("NULLRASRC", "attempting to change the serach priority of a null resource");
      return;
    end

    type_handle = rsrc.get_type_handle();
    if(!ttab.exists(type_handle)) begin
      $sformat(msg, "Type handle for resrouce named %s not found in type map; cannot change its search priority", rsrc.get_name());
      uvm_report_error("RNFTYPE", msg);
      return;
    end

    q = ttab[type_handle];
    set_priority_queue(rsrc, q, pri);
  endfunction

  function void set_priority_name(uvm_resource_base rsrc, uvm_resource_types::priority_e pri);

    string name;
    string msg;
    uvm_resource_types::rsrc_q_t q;

    if(rsrc == null) begin
      uvm_report_warning("NULLRASRC", "attempting to change the serach priority of a null resource");
      return;
    end

    name = rsrc.get_name();
    if(!rtab.exists(name)) begin
      $sformat(msg, "Resrouce named %s not found in name map; cannot change its search priority", name);
      uvm_report_error("RNFNAME", msg);
      return;
    end

    q = rtab[name];
    set_priority_queue(rsrc, q, pri);

  endfunction

  function void set_priority (uvm_resource_base rsrc, uvm_resource_types::priority_e pri);
    set_priority_type(rsrc, pri);
    set_priority_name(rsrc, pri);
  endfunction

  function uvm_resource_types::rsrc_q_t find_unused_resources();

    uvm_resource_types::rsrc_q_t rq;
    uvm_resource_types::rsrc_q_t q = new;
    int unsigned i;
    uvm_resource_base r;
    uvm_resource_types::access_t a;
    int reads;
    int writes;

    foreach (rtab[name]) begin
      rq = rtab[name];
      for(int i=0; i<rq.size(); ++i) begin
        r = rq.get(i);
        reads = 0;
        writes = 0;
        foreach(r.access[str]) begin
          a = r.access[str];
          reads += a.read_count;
          writes += a.write_count;
        end
        if(writes > 0 && reads == 0)
          q.push_back(r);
      end
    end

    return q;

  endfunction

  function void print_resources(uvm_resource_types::rsrc_q_t rq, bit audit = 0);

    int unsigned i;
    uvm_resource_base r;
    static uvm_line_printer printer = new();

    printer.knobs.separator="";
    printer.knobs.full_name=0;
    printer.knobs.identifier=0;
    printer.knobs.type_name=0;
    printer.knobs.reference=0;

    if(rq == null || rq.size() == 0) begin
      `uvm_info("UVM/RESOURCE/PRINT","<none>",UVM_NONE)
      return;
    end

    for(int i=0; i<rq.size(); ++i) begin
      r = rq.get(i);
      r.print(printer);
      if(audit == 1)
        r.print_accessors();
    end

  endfunction

  function void dump(bit audit = 0);

    uvm_resource_types::rsrc_q_t rq;
    string name;

    `uvm_info("UVM/RESOURCE/DUMP","\n=== resource pool ===",UVM_NONE)

    foreach (rtab[name]) begin
      rq = rtab[name];
      print_resources(rq, audit);
    end

    `uvm_info("UVM/RESOURCE/DUMP","=== end of resource pool ===",UVM_NONE)

  endfunction
  
endclass

`ifdef UVM_USE_RESOURCE_CONVERTER
typedef class m_uvm_resource_converter;
`endif


class uvm_resource #(type T=int) extends uvm_resource_base;

  typedef uvm_resource#(T) this_type;

  static this_type my_type = get_type();

  protected T val;

`ifdef UVM_USE_RESOURCE_CONVERTER

  local static m_uvm_resource_converter#(T) m_r2s;

  static function m_uvm_resource_converter#(T) m_get_converter();
    if (m_r2s==null) m_r2s = new();
    return m_r2s;
  endfunction
    

  static function void m_set_converter(m_uvm_resource_converter#(T) r2s);
    m_r2s = r2s;
  endfunction
   
`endif

  function new(string name="", scope="");
    super.new(name, scope);
    
`ifndef UVM_NO_DEPRECATED
begin
	for(int i=0;i<name.len();i++) begin
		if(name.getc(i) inside {".","/","[","*","{"}) begin
			`uvm_warning("UVM/RSRC/NOREGEX", $sformatf("a resource with meta characters in the field name has been created \"%s\"",name))
			break;
		end	
	end	
end

`endif    
  endfunction

  function string convert2string();
`ifdef UVM_USE_RESOURCE_CONVERTER
    void'(m_get_converter());
    return m_r2s.convert2string(val);
`else
  	return $sformatf("(%s) %0p", `uvm_typename(val), val);
`endif
  endfunction

  static function this_type get_type();
    if(my_type == null)
      my_type = new();
    return my_type;
  endfunction


  function uvm_resource_base get_type_handle();
    return get_type();
  endfunction


  function void set();
    uvm_resource_pool rp = uvm_resource_pool::get();
    rp.set(this);
  endfunction

  function void set_override(uvm_resource_types::override_t override = 2'b11);
    uvm_resource_pool rp = uvm_resource_pool::get();
    rp.set(this, override);
  endfunction


  static function this_type get_by_name(string scope, string name, bit rpterr = 1);

    uvm_resource_pool rp = uvm_resource_pool::get();
    uvm_resource_base rsrc_base;
    this_type rsrc;
    string msg;

    rsrc_base = rp.get_by_name(scope, name, my_type, rpterr);
    if(rsrc_base == null)
      return null;

    if(!$cast(rsrc, rsrc_base)) begin
      if(rpterr) begin
        $sformat(msg, "Resource with name %s in scope %s has incorrect type", name, scope);
        `uvm_warning("RSRCTYPE", msg);
      end
      return null;
    end

    return rsrc;
    
  endfunction


  static function this_type get_by_type(string scope = "", uvm_resource_base type_handle);

    uvm_resource_pool rp = uvm_resource_pool::get();
    uvm_resource_base rsrc_base;
    this_type rsrc;
    string msg;

    if(type_handle == null)
      return null;

    rsrc_base = rp.get_by_type(scope, type_handle);
    if(rsrc_base == null)
      return null;

    if(!$cast(rsrc, rsrc_base)) begin
      $sformat(msg, "Resource with specified type handle in scope %s was not located", scope);
      `uvm_warning("RSRCNF", msg);
      return null;
    end

    return rsrc;

  endfunction
  


  function T read(uvm_object accessor = null);
    record_read_access(accessor);
    return val;
  endfunction


  function void write(T t, uvm_object accessor = null);

    if(is_read_only()) begin
      uvm_report_error("resource", $sformatf("resource %s is read only -- cannot modify", get_name()));
      return;
    end

    if(val == t)
      return;

    record_write_access(accessor);

    val = t;
    modified = 1;
  endfunction



  function void set_priority (uvm_resource_types::priority_e pri);
    uvm_resource_pool rp = uvm_resource_pool::get();
    rp.set_priority(this, pri);
  endfunction


  static function this_type get_highest_precedence(ref uvm_resource_types::rsrc_q_t q);

    this_type rsrc;
    this_type r;
    int unsigned i;
    int unsigned prec;
    int unsigned first;

    if(q.size() == 0)
      return null;

    first = 0;
    rsrc = null;
    prec = 0;

    for(first = 0; first < q.size() && !$cast(rsrc, q.get(first)); first++);

    if(rsrc == null)
      return null;

    prec = rsrc.precedence;

    for(int i = first+1; i < q.size(); ++i) begin
      if($cast(r, q.get(i))) begin
        if(r.precedence > prec) begin
          rsrc = r;
          prec = r.precedence;
        end
      end
    end

    return rsrc;

  endfunction

endclass

const uvm_resource_pool uvm_resources = uvm_resource_pool::get();

`ifdef UVM_USE_RESOURCE_CONVERTER


class m_uvm_resource_converter #(type T=int);

   virtual function string convert2string(T val);
        return {"(", `uvm_typename(val), ") ?"};
   endfunction
endclass


class m_uvm_resource_default_converter#(type T=int) extends m_uvm_resource_converter#(T);
   local static m_uvm_resource_default_converter#(T) m_singleton;
   local string m_name;
   
   virtual function string convert2string(T val);
      return $sformatf("(%s) %0p", (m_name=="")? `uvm_typename(val):m_name, val);
   endfunction

   local function new();
   endfunction
   

   static function bit register(string typename = "");
      if (m_singleton == null) begin
         m_singleton = new();
         m_singleton.m_name = typename;
      end
      uvm_resource#(T)::m_set_converter(m_singleton);
      return 1;
   endfunction
endclass



class m_uvm_resource_convert2string_converter#(type T=int) extends m_uvm_resource_converter#(T);
   local static m_uvm_resource_convert2string_converter #(T) m_singleton;
 
   virtual function string convert2string(T val);   
      return $sformatf("(%s) %0s", `uvm_typename(val), (val == null) ? "(null)" : val.convert2string());
   endfunction

   local function new();
   endfunction

   static function bit register();
      if (m_singleton == null) m_singleton = new();
      uvm_resource#(T)::m_set_converter(m_singleton);
      return 1;
   endfunction
endclass
    

class m_uvm_resource_sprint_converter#(type T=int) extends m_uvm_resource_converter#(T);
   local static m_uvm_resource_sprint_converter #(T) m_singleton;

   virtual function string convert2string(T val);
      return $sformatf("(%s) %0s", `uvm_typename(val), (val == null) ? "(null)" : {"\n",val.sprint()});
   endfunction
   
   local function new();
   endfunction

   static function bit register();
      if (m_singleton == null) m_singleton = new();
      uvm_resource#(T)::m_set_converter(m_singleton);
      return 1;
   endfunction
endclass


class m_uvm_resource_default_converters;
   
   local static bit m_singleton = register();
   local function new();
   endfunction

   static function bit register();
      if (!m_singleton) begin

         `define __built_in(T) void'(m_uvm_resource_default_converter#(T)::register(`"T`"))
            
         `__built_in(shortint);
         `__built_in(int);
         `__built_in(longint);
         `__built_in(byte);
         `__built_in(bit);
         `__built_in(logic);
         `__built_in(reg);
         `__built_in(integer);
         `__built_in(time);
         `__built_in(real);
         `__built_in(realtime);
         `__built_in(string);
         `__built_in(uvm_bitstream_t);
         `__built_in(bit[7:0]);
         `__built_in(bit[15:0]);
         `__built_in(bit[31:0]);

         `undef __built_in

         m_singleton = 1;
      end
      return 1;
   endfunction
endclass


`endif


`define UVM_RESOURCE_GET_FCNS(base_type)                                               \
  static function this_subtype get_by_name(string scope, string name, bit rpterr = 1); \
    this_subtype t;                                                                    \
    uvm_resource_base b = uvm_resource#(base_type)::get_by_name(scope, name, rpterr);  \
    if(!$cast(t, b))                                                                   \
      `uvm_fatal("BADCAST", "cannot cast resource to resource subtype");               \
    return t;                                                                          \
  endfunction                                                                          \
                                                                                       \
  static function this_subtype get_by_type(string scope = "",                          \
                                           uvm_resource_base type_handle);             \
    this_subtype t;                                                                    \
    uvm_resource_base b = uvm_resource#(base_type)::get_by_type(scope, type_handle);   \
    if(!$cast(t, b))                                                                   \
      `uvm_fatal("BADCAST", "cannot cast resource to resource subtype");               \
    return t;                                                                          \
  endfunction


class uvm_int_rsrc extends uvm_resource #(int);

  typedef uvm_int_rsrc this_subtype;

  function new(string name, string s = "*");
    super.new(name, s);
  endfunction

  function string convert2string();
    string s;
    $sformat(s, "%0d", read());
    return s;
  endfunction

  `UVM_RESOURCE_GET_FCNS(int)

endclass

class uvm_string_rsrc extends uvm_resource #(string);

  typedef uvm_string_rsrc this_subtype;

  function new(string name, string s = "*");
    super.new(name, s);
  endfunction

  function string convert2string();
    return read();
  endfunction

  `UVM_RESOURCE_GET_FCNS(string)

endclass

class uvm_obj_rsrc extends uvm_resource #(uvm_object);

  typedef uvm_obj_rsrc this_subtype;

  function new(string name, string s = "*");
    super.new(name, s);
  endfunction

  `UVM_RESOURCE_GET_FCNS(uvm_object)

endclass

class uvm_bit_rsrc #(int unsigned N=1) extends uvm_resource #(bit[N-1:0]);

  typedef uvm_bit_rsrc#(N) this_subtype;

  function new(string name, string s = "*");
    super.new(name, s);
  endfunction

  function string convert2string();
    string s;
    $sformat(s, "%0b", read());
    return s;
  endfunction

  `UVM_RESOURCE_GET_FCNS(bit[N-1:0])

endclass

class uvm_byte_rsrc #(int unsigned N=1) extends uvm_resource #(bit[7:0][N-1:0]);

  typedef uvm_byte_rsrc#(N) this_subtype;

  function new(string name, string s = "*");
    super.new(name, s);
  endfunction

  function string convert2string();
    string s;
    $sformat(s, "%0x", read());
    return s;
  endfunction

  `UVM_RESOURCE_GET_FCNS(bit[7:0][N-1:0])

endclass

typedef class uvm_resource_db_options;
typedef class uvm_cmdline_processor;

class uvm_resource_db #(type T=uvm_object);

  typedef uvm_resource #(T) rsrc_t;

  protected function new();
  endfunction

  static function rsrc_t get_by_type(string scope);
    return rsrc_t::get_by_type(scope, rsrc_t::get_type());
  endfunction

  static function rsrc_t get_by_name(string scope, string name, bit rpterr=1);

    return rsrc_t::get_by_name(scope, name, rpterr);
  endfunction


  static function rsrc_t set_default(string scope, string name);

    rsrc_t r;
    
    r = new(name, scope);
    r.set();
    return r;
  endfunction

  protected static function void m_show_msg( input string id, input string rtype, input string action, input string scope, input string name, input uvm_object accessor, input rsrc_t rsrc);

          T foo;
          string msg=`uvm_typename(foo);

          $sformat(msg, "%s '%s%s' (type %s) %s by %s = %s", rtype,scope, name=="" ? "" : {".",name}, msg,action, (accessor != null) ? accessor.get_full_name() : "<unknown>", rsrc==null?"null (failed lookup)":rsrc.convert2string());

          `uvm_info(id, msg, UVM_LOW)
  endfunction

  static function void set(input string scope, input string name, T val, input uvm_object accessor = null);

    rsrc_t rsrc = new(name, scope);
    rsrc.write(val, accessor);
    rsrc.set();

    if(uvm_resource_db_options::is_tracing())
      m_show_msg("RSRCDB/SET", "Resource","set", scope, name, accessor, rsrc);
  endfunction

  static function void set_anonymous(input string scope, T val, input uvm_object accessor = null);

    rsrc_t rsrc = new("", scope);
    rsrc.write(val, accessor);
    rsrc.set();

    if(uvm_resource_db_options::is_tracing())
      m_show_msg("RSRCDB/SETANON","Resource", "set", scope, "", accessor, rsrc);
  endfunction


  static function void set_override(input string scope, input string name, T val, uvm_object accessor = null);
    rsrc_t rsrc = new(name, scope);
    rsrc.write(val, accessor);
    rsrc.set_override();

    if(uvm_resource_db_options::is_tracing())
      m_show_msg("RSRCDB/SETOVRD", "Resource","set", scope, name, accessor, rsrc);
  endfunction

  static function void set_override_type(input string scope, input string name, T val, uvm_object accessor = null);
    rsrc_t rsrc = new(name, scope);
    rsrc.write(val, accessor);
    rsrc.set_override(uvm_resource_types::TYPE_OVERRIDE);

    if(uvm_resource_db_options::is_tracing())
      m_show_msg("RSRCDB/SETOVRDTYP","Resource", "set", scope, name, accessor, rsrc);
  endfunction


  static function void set_override_name(input string scope, input string name, T val, uvm_object accessor = null);
    rsrc_t rsrc = new(name, scope);
    rsrc.write(val, accessor);
    rsrc.set_override(uvm_resource_types::NAME_OVERRIDE);

    if(uvm_resource_db_options::is_tracing())
      m_show_msg("RSRCDB/SETOVRDNAM","Resource", "set", scope, name, accessor, rsrc);
  endfunction

  static function bit read_by_name(input string scope, input string name, inout T val, input uvm_object accessor = null);

    rsrc_t rsrc = get_by_name(scope, name);

    if(uvm_resource_db_options::is_tracing())
      m_show_msg("RSRCDB/RDBYNAM","Resource", "read", scope, name, accessor, rsrc);

    if(rsrc == null)
      return 0;

    val = rsrc.read(accessor);

    return 1;
  
  endfunction

  static function bit read_by_type(input string scope, inout T val, input uvm_object accessor = null);
    
    rsrc_t rsrc = get_by_type(scope);

    if(uvm_resource_db_options::is_tracing())
      m_show_msg("RSRCDB/RDBYTYP", "Resource","read", scope, "", accessor, rsrc);

    if(rsrc == null)
      return 0;

    val = rsrc.read(accessor);

    return 1;

  endfunction

  static function bit write_by_name(input string scope, input string name, input T val, input uvm_object accessor = null);

    rsrc_t rsrc = get_by_name(scope, name);

    if(uvm_resource_db_options::is_tracing())
      m_show_msg("RSRCDB/WR","Resource", "written", scope, name, accessor, rsrc);

    if(rsrc == null)
      return 0;

    rsrc.write(val, accessor);

    return 1;

  endfunction

  static function bit write_by_type(input string scope, input T val, input uvm_object accessor = null);

    rsrc_t rsrc = get_by_type(scope);

    if(uvm_resource_db_options::is_tracing())
      m_show_msg("RSRCDB/WRTYP", "Resource","written", scope, "", accessor, rsrc);

    if(rsrc == null)
      return 0;

    rsrc.write(val, accessor);

    return 1;
  endfunction


  static function void dump();
    uvm_resource_pool rp = uvm_resource_pool::get();
    rp.dump();
  endfunction

endclass



class uvm_resource_db_options;
   
  static local bit ready;
  static local bit tracing;


  static function void turn_on_tracing();
     if (!ready) init();
    tracing = 1;
  endfunction


  static function void turn_off_tracing();
     if (!ready) init();
    tracing = 0;
  endfunction


  static function bit is_tracing();
    if (!ready) init();
    return tracing;
  endfunction


  static local function void init();
     uvm_cmdline_processor clp;
     string trace_args[$];
     
     clp = uvm_cmdline_processor::get_inst();

     if (clp.get_arg_matches("+UVM_RESOURCE_DB_TRACE", trace_args)) begin
        tracing = 1;
     end

     ready = 1;
  endfunction

endclass


typedef class uvm_phase;

class m_uvm_waiter;
  string inst_name;
  string field_name;
  event trigger;
  function new (string inst_name, string field_name);
    this.inst_name = inst_name;
    this.field_name = field_name;
  endfunction
endclass

typedef class uvm_root;
typedef class uvm_config_db_options;

class uvm_config_db#(type T=int) extends uvm_resource_db#(T);

  static uvm_pool#(string,uvm_resource#(T)) m_rsc[uvm_component];
  static local uvm_queue#(m_uvm_waiter) m_waiters[string];

  static function bit get(uvm_component cntxt, string inst_name, string field_name, inout T value);
    int unsigned p;
    uvm_resource#(T) r, rt;
    uvm_resource_pool rp = uvm_resource_pool::get();
    uvm_resource_types::rsrc_q_t rq;
    uvm_coreservice_t cs = uvm_coreservice_t::get();

    if(cntxt == null) 
      cntxt = cs.get_root();
    if(inst_name == "") 
      inst_name = cntxt.get_full_name();
    else if(cntxt.get_full_name() != "") 
      inst_name = {cntxt.get_full_name(), ".", inst_name};
 
    rq = rp.lookup_regex_names(inst_name, field_name, uvm_resource#(T)::get_type());
    r = uvm_resource#(T)::get_highest_precedence(rq);
    
    if(uvm_config_db_options::is_tracing())
      m_show_msg("CFGDB/GET", "Configuration","read", inst_name, field_name, cntxt, r);

    if(r == null)
      return 0;

    value = r.read(cntxt);

    return 1;
  endfunction


  static function void set(uvm_component cntxt, string inst_name, string field_name, T value);

    uvm_root top;
    uvm_phase curr_phase;
    uvm_resource#(T) r;
    bit exists;
    string lookup;
    uvm_pool#(string,uvm_resource#(T)) pool;
    string rstate;
    uvm_coreservice_t cs = uvm_coreservice_t::get();
     
    process p = process::self();
    if(p != null) 
  		rstate = p.get_randstate();
  		
    top = cs.get_root();

    curr_phase = top.m_current_phase;

    if(cntxt == null) 
      cntxt = top;
    if(inst_name == "") 
      inst_name = cntxt.get_full_name();
    else if(cntxt.get_full_name() != "") 
      inst_name = {cntxt.get_full_name(), ".", inst_name};

    if(!m_rsc.exists(cntxt)) begin
      m_rsc[cntxt] = new;
    end
    pool = m_rsc[cntxt];

    lookup = {inst_name, "__M_UVM__", field_name};

    if(!pool.exists(lookup)) begin
       r = new(field_name, inst_name);
       pool.add(lookup, r);
    end
    else begin
      r = pool.get(lookup);
      exists = 1;
    end
      
    if(curr_phase != null && curr_phase.get_name() == "build")
      r.precedence = uvm_resource_base::default_precedence - (cntxt.get_depth());
    else
      r.precedence = uvm_resource_base::default_precedence;

    r.write(value, cntxt);

    if(exists) begin
      uvm_resource_pool rp = uvm_resource_pool::get();
      rp.set_priority_name(r, uvm_resource_types::PRI_HIGH);
    end
    else begin
      r.set_override();
    end

    if(m_waiters.exists(field_name)) begin
      m_uvm_waiter w;
      for(int i=0; i<m_waiters[field_name].size(); ++i) begin
        w = m_waiters[field_name].get(i);
        if(uvm_re_match(uvm_glob_to_re(inst_name),w.inst_name) == 0)
           ->w.trigger;  
      end
    end

    if(p != null)
    	p.set_randstate(rstate);

    if(uvm_config_db_options::is_tracing())
      m_show_msg("CFGDB/SET", "Configuration","set", inst_name, field_name, cntxt, r);
  endfunction



  static function bit exists(uvm_component cntxt, string inst_name, string field_name, bit spell_chk=0);
    uvm_coreservice_t cs = uvm_coreservice_t::get();

    if(cntxt == null)
      cntxt = cs.get_root();
    if(inst_name == "")
      inst_name = cntxt.get_full_name();
    else if(cntxt.get_full_name() != "")
      inst_name = {cntxt.get_full_name(), ".", inst_name};

    return (uvm_resource_db#(T)::get_by_name(inst_name,field_name,spell_chk) != null);
  endfunction



  static task wait_modified(uvm_component cntxt, string inst_name, string field_name);
    process p = process::self();
    string rstate = p.get_randstate();
    m_uvm_waiter waiter;
    uvm_coreservice_t cs = uvm_coreservice_t::get();

    if(cntxt == null)
      cntxt = cs.get_root();
    if(cntxt != cs.get_root()) begin
      if(inst_name != "")
        inst_name = {cntxt.get_full_name(),".",inst_name};
      else
        inst_name = cntxt.get_full_name();
    end

    waiter = new(inst_name, field_name);

    if(!m_waiters.exists(field_name))
      m_waiters[field_name] = new;
    m_waiters[field_name].push_back(waiter);

    p.set_randstate(rstate);

    @waiter.trigger;
  
    for(int i=0; i<m_waiters[field_name].size(); ++i) begin
      if(m_waiters[field_name].get(i) == waiter) begin
        m_waiters[field_name].delete(i);
        break;
      end
    end 
  endtask


endclass

   
typedef uvm_config_db#(uvm_bitstream_t) uvm_config_int;

typedef uvm_config_db#(string) uvm_config_string;

typedef uvm_config_db#(uvm_object) uvm_config_object;

typedef uvm_config_db#(uvm_object_wrapper) uvm_config_wrapper;



class uvm_config_db_options;
   
  static local bit ready;
  static local bit tracing;


  static function void turn_on_tracing();
     if (!ready) init();
    tracing = 1;
  endfunction


  static function void turn_off_tracing();
     if (!ready) init();
    tracing = 0;
  endfunction


  static function bit is_tracing();
    if (!ready) init();
    return tracing;
  endfunction


  static local function void init();
     uvm_cmdline_processor clp;
     string trace_args[$];
     
     clp = uvm_cmdline_processor::get_inst();

     if (clp.get_arg_matches("+UVM_CONFIG_DB_TRACE", trace_args)) begin
        tracing = 1;
     end

     ready = 1;
  endfunction

endclass

typedef class uvm_printer_knobs;

parameter UVM_STDOUT = 1;  

typedef struct {
  int    level;
  string name;
  string type_name;
  string size;
  string val;
} uvm_printer_row_info;


virtual class uvm_printer;

  uvm_printer_knobs knobs = new;

  virtual function void print_int (string          name, uvm_bitstream_t value, int    size, uvm_radix_enum radix=UVM_NORADIX, byte   scope_separator=".", string type_name="");
    print_field (name, value, size, radix, scope_separator, type_name);
  endfunction

  virtual function string format_header();
    return "";
  endfunction

  virtual function string format_footer();
    return "";
  endfunction

  protected bit m_array_stack[$];
  uvm_scope_stack m_scope = new;
  string m_string;
  protected uvm_printer_row_info m_rows[$];

  virtual function string emit (); 
    `uvm_error("NO_OVERRIDE","emit() method not overridden in printer subtype")
    return "";
  endfunction
  
  virtual function string format_row (uvm_printer_row_info row);
    return "";
  endfunction
  
  
  virtual function void print_array_header (string name, int size, string arraytype="array", byte scope_separator=".");
    uvm_printer_row_info row_info;
  
    if(name != "")
      m_scope.set_arg(name);
  
    row_info.level = m_scope.depth();
    row_info.name = adjust_name(m_scope.get(),scope_separator);
    row_info.type_name = arraytype;
    row_info.size = $sformatf("%0d",size);
    row_info.val = "-";
  
    m_rows.push_back(row_info);
  
    m_scope.down(name);
    m_array_stack.push_back(1);
  endfunction
  
  
  
  virtual function void  print_array_footer (int size=0);
    if(m_array_stack.size()) begin
      m_scope.up();
      void'(m_array_stack.pop_front());
    end
  endfunction
  
  
  
  virtual function void print_array_range(int min, int max);
    string tmpstr;
    if(min == -1 && max == -1)
       return;
    if(min == -1)
       min = max;
    if(max == -1)
       max = min;
    if(max < min)
       return;
    print_generic("...", "...", -2, "...");
  endfunction
  
  
  
  virtual function void print_object_header (string name, uvm_object value, byte scope_separator=".");
    uvm_printer_row_info row_info;
    uvm_component comp;
  
    if(name == "") begin
      if(value!=null) begin
        if((m_scope.depth()==0) && $cast(comp, value)) begin
          name = comp.get_full_name();
        end
        else begin
          name=value.get_name();
        end
      end
    end
          
    if(name == "")
      name = "<unnamed>";
  
    m_scope.set_arg(name);
  
    row_info.level = m_scope.depth();
  
    if(row_info.level == 0 && knobs.show_root==1)
  	row_info.name = value.get_full_name();
    else
  	row_info.name = adjust_name(m_scope.get(),scope_separator);
  
    row_info.type_name = (value != null) ?  value.get_type_name() : "object";
    row_info.size = "-";
    row_info.val = knobs.reference ? uvm_object_value_str(value) : "-";
  
    m_rows.push_back(row_info);
  
  endfunction
  
  
  
  virtual function void print_object (string name, uvm_object value, byte scope_separator=".");
    uvm_component comp, child_comp;
  
    print_object_header(name,value,scope_separator);
  
    if(value != null)  begin
      if((knobs.depth == -1 || (knobs.depth > m_scope.depth())) &&
            !value.__m_uvm_status_container.cycle_check.exists(value)) begin
  
        value.__m_uvm_status_container.cycle_check[value] = 1;
        if(name=="" && value!=null) 
          m_scope.down(value.get_name());
        else
          m_scope.down(name);
  
        if($cast(comp, value)) begin
          string name;
          if (comp.get_first_child(name))
            do begin
              child_comp = comp.get_child(name);
              if(child_comp.print_enabled)
                this.print_object("",child_comp);
            end while (comp.get_next_child(name));
        end
  
        void'(value.sprint(this));
  
        if(name != "" && name[0] == "[")
          m_scope.up("[");
        else
          m_scope.up(".");
        value.__m_uvm_status_container.cycle_check.delete(value);
      end
    end
  
  endfunction
  
  
  
  virtual function bit istop ();
    return (m_scope.depth() == 0);
  endfunction
  
  
  
  virtual protected function string adjust_name(string id, byte scope_separator=".");
    if (knobs.show_root && m_scope.depth()==0 || knobs.full_name || id == "...")
      return id;
    return uvm_leaf_scope(id, scope_separator);
  endfunction
  
  
  
  virtual function void print_generic (string name, string type_name,        int size, string value, byte scope_separator=".");
  
    uvm_printer_row_info row_info;
  
    if (name != "" && name != "...") begin
      m_scope.set_arg(name);
      name = m_scope.get();
    end
  
    row_info.level = m_scope.depth();
    row_info.name = adjust_name(name,scope_separator);
    row_info.type_name = type_name;
    row_info.size = (size == -2 ? "..." : $sformatf("%0d",size));
    row_info.val = (value == "" ? "\"\"" : value);
  
    m_rows.push_back(row_info);
  
  endfunction
  
  
  
  virtual function void print_field (string name, uvm_bitstream_t value, int size, uvm_radix_enum radix=UVM_NORADIX, byte scope_separator=".", string type_name="");
    
    uvm_printer_row_info row_info;
    string sz_str, val_str;
  
    if(name != "") begin
      m_scope.set_arg(name);
      name = m_scope.get();
    end
  
    if(type_name == "") begin
      if(radix == UVM_TIME)
        type_name ="time";
      else if(radix == UVM_STRING)
        type_name ="string";
      else
        type_name ="integral";
    end
  
    sz_str.itoa(size);
  
    if(radix == UVM_NORADIX)
      radix = knobs.default_radix;
  
    val_str = uvm_bitstream_to_string (value, size, radix, knobs.get_radix_str(radix));
  
    row_info.level = m_scope.depth();
    row_info.name = adjust_name(name,scope_separator);
    row_info.type_name = type_name;
    row_info.size = sz_str;
    row_info.val = val_str;
  
    m_rows.push_back(row_info);
  
  endfunction
    
  
  virtual function void print_field_int (string name, uvm_integral_t value, int          size, uvm_radix_enum radix=UVM_NORADIX, byte         scope_separator=".", string       type_name="");
    
    uvm_printer_row_info row_info;
    string sz_str, val_str;
  
    if(name != "") begin
      m_scope.set_arg(name);
      name = m_scope.get();
    end
  
    if(type_name == "") begin
      if(radix == UVM_TIME)
        type_name ="time";
      else if(radix == UVM_STRING)
        type_name ="string";
      else
        type_name ="integral";
    end
  
    sz_str.itoa(size);
  
    if(radix == UVM_NORADIX)
      radix = knobs.default_radix;
  
    val_str = uvm_integral_to_string (value, size, radix, knobs.get_radix_str(radix));
  
    row_info.level = m_scope.depth();
    row_info.name = adjust_name(name,scope_separator);
    row_info.type_name = type_name;
    row_info.size = sz_str;
    row_info.val = val_str;
  
    m_rows.push_back(row_info);
  
  endfunction
    
  
  
  virtual function void print_time (string name, time value, byte scope_separator=".");
    print_field_int(name, value, 64, UVM_TIME, scope_separator);
  endfunction
  
  
  
  virtual function void print_string (string name, string value, byte scope_separator=".");
  
    uvm_printer_row_info row_info;
  
    if(name != "")
      m_scope.set_arg(name);
  
    row_info.level = m_scope.depth();
    row_info.name = adjust_name(m_scope.get(),scope_separator);
    row_info.type_name = "string";
    row_info.size = $sformatf("%0d",value.len());
    row_info.val = (value == "" ? "\"\"" : value);
  
    m_rows.push_back(row_info);
  
  endfunction
  
  
  
  virtual function void print_real (string name, real value, byte scope_separator=".");
  
    uvm_printer_row_info row_info;
  
    if (name != "" && name != "...") begin
      m_scope.set_arg(name);
      name = m_scope.get();
    end
  
    row_info.level = m_scope.depth();
    row_info.name = adjust_name(m_scope.get(),scope_separator);
    row_info.type_name = "real";
    row_info.size = "64";
    row_info.val = $sformatf("%f",value);
  
    m_rows.push_back(row_info);
  
  endfunction
  
  
  
  virtual function string index_string(int index, string name="");
    index_string.itoa(index);
    index_string = { name, "[", index_string, "]" }; 
  endfunction

endclass

class uvm_table_printer extends uvm_printer;

  protected int m_max_name;
  protected int m_max_type;
  protected int m_max_size;
  protected int m_max_value;

  function new(); 
    super.new();
  endfunction
  
  virtual function void calculate_max_widths();
     m_max_name=4;
     m_max_type=4;
     m_max_size = 4;
     m_max_value= 5;
     foreach(m_rows[j]) begin
        int name_len;
        uvm_printer_row_info row = m_rows[j];
        name_len = knobs.indent*row.level + row.name.len();
        if (name_len > m_max_name)
          m_max_name = name_len;
        if (row.type_name.len() > m_max_type)
          m_max_type = row.type_name.len();
        if (row.size.len() > m_max_size)
          m_max_size = row.size.len();
        if (row.val.len() > m_max_value)
          m_max_value = row.val.len();
     end
  endfunction
  
  
  virtual function string emit();
  
    string s;
    string user_format;
    static string dash; 
    static string space; 
    string dashes;
  
    string linefeed = {"\n", knobs.prefix};
  
    calculate_max_widths(); 
  
     begin
        int q[5];
        int m;
        int qq[$];
        
        q = '{m_max_name,m_max_type,m_max_size,m_max_value,100};
        qq = q.max;
        m = qq[0];
    	if(dash.len()<m) begin
    		dash = {m{"-"}};
    		space = {m{" "}};
    	end
    end
    
    if (knobs.header) begin
      string header;
      user_format = format_header();
      if (user_format == "") begin
        string dash_id, dash_typ, dash_sz;
        string head_id, head_typ, head_sz;
        if (knobs.identifier) begin
          dashes = {dash.substr(1,m_max_name+2)};
          header = {"Name",space.substr(1,m_max_name-2)};
        end
        if (knobs.type_name) begin
          dashes = {dashes, dash.substr(1,m_max_type+2)};
          header = {header, "Type",space.substr(1,m_max_type-2)};
        end
        if (knobs.size) begin
          dashes = {dashes, dash.substr(1,m_max_size+2)};
          header = {header, "Size",space.substr(1,m_max_size-2)};
        end
        dashes = {dashes, dash.substr(1,m_max_value), linefeed};
        header = {header, "Value", space.substr(1,m_max_value-5), linefeed};
  
        s = {s, dashes, header, dashes};
      end
      else begin
        s = {s, user_format, linefeed};
      end
    end
  
    foreach (m_rows[i]) begin
      uvm_printer_row_info row = m_rows[i];
      user_format = format_row(row);
      if (user_format == "") begin
        string row_str;
        if (knobs.identifier)
          row_str = {space.substr(1,row.level * knobs.indent), row.name,
                     space.substr(1,m_max_name-row.name.len()-(row.level*knobs.indent)+2)};
        if (knobs.type_name)
          row_str = {row_str, row.type_name, space.substr(1,m_max_type-row.type_name.len()+2)};
        if (knobs.size)
          row_str = {row_str, row.size, space.substr(1,m_max_size-row.size.len()+2)};
        s = {s, row_str, row.val, space.substr(1,m_max_value-row.val.len()), linefeed};
      end
      else
        s = {s, user_format, linefeed};
    end
   
    if (knobs.footer) begin
      user_format = format_footer();
      if (user_format == "")
        s = {s, dashes};
      else
        s = {s, user_format, linefeed};
    end
  
    emit = {knobs.prefix, s};
    m_rows.delete();
  endfunction

endclass



class uvm_tree_printer extends uvm_printer;

  string newline = "\n";

  function new();
    super.new();
    knobs.size = 0;
    knobs.type_name = 0;
    knobs.header = 0;
    knobs.footer = 0;
  endfunction
  
  virtual function string emit();
  
    string s = knobs.prefix;
    string space= "                                                                                                   ";
    string user_format;
  
    string linefeed = newline == "" || newline == " " ? newline : {newline, knobs.prefix};
  
    if (knobs.header) begin
      user_format = format_header();
      if (user_format != "")
        s = {s, user_format, linefeed};
    end
  
    foreach (m_rows[i]) begin
      uvm_printer_row_info row = m_rows[i];
      user_format = format_row(row);
      if (user_format == "") begin
        string indent_str;
        indent_str = space.substr(1,row.level * knobs.indent); 
  
        if (knobs.identifier) begin
          s = {s,indent_str, row.name};
          if (row.name != "" && row.name != "...")
            s = {s, ": "};
        end
  
        if (row.val[0] == "@") 
          s = {s,"(",row.type_name,row.val,") "};
        else
          if (knobs.type_name &&
               (row.type_name != "" ||
                row.type_name != "-" ||
                row.type_name != "..."))
            s = {s,"(",row.type_name,") "};
          
        if (knobs.size) begin
          if (row.size != "" || row.size != "-")
              s = {s,"(",row.size,") "};
        end
  
        if (i < m_rows.size()-1) begin
          if (m_rows[i+1].level > row.level) begin
            s = {s, string'(knobs.separator[0]), linefeed};
            continue;
          end
        end
  
        s = {s, row.val, " ", linefeed};
  
        if (i <= m_rows.size()-1) begin
          int end_level;
          if (i == m_rows.size()-1)
            end_level = 0;
          else
            end_level = m_rows[i+1].level;
          if (end_level < row.level) begin
            string indent_str;
            for (int l=row.level-1; l >= end_level; l--) begin
              indent_str = space.substr(1,l * knobs.indent); 
              s = {s, indent_str, string'(knobs.separator[1]), linefeed};
            end
          end
        end
  
      end
      else
        s = {s, user_format};
    end
   
    if (knobs.footer) begin
      user_format = format_footer();
      if (user_format != "")
        s = {s, user_format, linefeed};
    end
  
    if (newline == "" || newline == " ")
      s = {s, "\n"};
  
    emit = s;
    m_rows.delete();
  endfunction

endclass


class uvm_line_printer extends uvm_tree_printer;

  function new(); 
    newline = " ";
    knobs.indent = 0;
  endfunction

endclass


class uvm_printer_knobs;

  bit header = 1;
  bit footer = 1;
  bit full_name = 0;
  bit identifier = 1;
  bit type_name = 1;
  bit size = 1;
  int depth = -1;
  bit reference = 1;
  int begin_elements = 5;
  int end_elements = 5;
  string prefix = ""; 
  int indent = 2;
  bit show_root = 0;
  int mcd = UVM_STDOUT; 
  string separator = "{}";
  bit show_radix = 1;
  uvm_radix_enum default_radix = UVM_HEX;
  string dec_radix = "'d";
  string bin_radix = "'b";
  string oct_radix = "'o";
  string unsigned_radix = "'d";
  string hex_radix = "'h";

  function string get_radix_str(uvm_radix_enum radix);
    if(show_radix == 0)
      return "";
    if(radix == UVM_NORADIX)
      radix = default_radix;
    case(radix)
      UVM_BIN: return bin_radix;
      UVM_OCT: return oct_radix;
      UVM_DEC: return dec_radix;
      UVM_HEX: return hex_radix;
      UVM_UNSIGNED: return unsigned_radix;
      default: return "";
    endcase
  endfunction

  int max_width = 999;
  string truncation = "+"; 
  int name_width = -1;
  int type_width = -1;
  int size_width = -1;
  int value_width = -1;
  bit sprint = 1;

endclass


typedef uvm_printer_knobs uvm_table_printer_knobs;
typedef uvm_printer_knobs uvm_tree_printer_knobs;


class uvm_comparer;

  uvm_recursion_policy_enum policy = UVM_DEFAULT_POLICY;
  int unsigned show_max = 1;
  int unsigned verbosity = UVM_LOW;
  uvm_severity sev = UVM_INFO;
  string miscompares = "";
  bit physical = 1;
  bit abstract = 1;
  bit check_type = 1;
  int unsigned result = 0;

  virtual function bit compare_field (string name, uvm_bitstream_t lhs, uvm_bitstream_t rhs, int size, uvm_radix_enum radix=UVM_NORADIX); 
    uvm_bitstream_t mask;
    string msg;
  
    if(size <= 64)
      return compare_field_int(name, lhs, rhs, size, radix);
  
    mask = -1;
    mask >>= (UVM_STREAMBITS-size);
    if((lhs & mask) !== (rhs & mask)) begin
      uvm_object::__m_uvm_status_container.scope.set_arg(name);
      case (radix)
        UVM_BIN: begin
              $swrite(msg, "lhs = 'b%0b : rhs = 'b%0b", lhs&mask, rhs&mask);
             end
        UVM_OCT: begin
              $swrite(msg, "lhs = 'o%0o : rhs = 'o%0o", lhs&mask, rhs&mask);
             end
        UVM_DEC: begin
              $swrite(msg, "lhs = %0d : rhs = %0d", lhs&mask, rhs&mask);
             end
        UVM_TIME: begin
            $swrite(msg, "lhs = %0t : rhs = %0t", lhs&mask, rhs&mask);
        end
        UVM_STRING: begin
              $swrite(msg, "lhs = %0s : rhs = %0s", lhs&mask, rhs&mask);
             end
        UVM_ENUM: begin
              $swrite(msg, "lhs = %0d : rhs = %0d", lhs&mask, rhs&mask);
              end
        default: begin
              $swrite(msg, "lhs = 'h%0x : rhs = 'h%0x", lhs&mask, rhs&mask);
             end
      endcase
      print_msg(msg);
      return 0;
    end
    return 1;
  endfunction

  
  

  virtual function bit compare_field_int (string name, uvm_integral_t lhs, uvm_integral_t rhs, int size, uvm_radix_enum radix=UVM_NORADIX); 
    logic [63:0] mask;
    string msg;
  
    mask = -1;
    mask >>= (64-size);
    if((lhs & mask) !== (rhs & mask)) begin
      uvm_object::__m_uvm_status_container.scope.set_arg(name);
      case (radix)
        UVM_BIN: begin
              $swrite(msg, "lhs = 'b%0b : rhs = 'b%0b", lhs&mask, rhs&mask);
             end
        UVM_OCT: begin
              $swrite(msg, "lhs = 'o%0o : rhs = 'o%0o", lhs&mask, rhs&mask);
             end
        UVM_DEC: begin
              $swrite(msg, "lhs = %0d : rhs = %0d", lhs&mask, rhs&mask);
             end
        UVM_TIME: begin
            $swrite(msg, "lhs = %0t : rhs = %0t", lhs&mask, rhs&mask);
        end
        UVM_STRING: begin
              $swrite(msg, "lhs = %0s : rhs = %0s", lhs&mask, rhs&mask);
             end
        UVM_ENUM: begin
              $swrite(msg, "lhs = %0d : rhs = %0d", lhs&mask, rhs&mask);
              end
        default: begin
              $swrite(msg, "lhs = 'h%0x : rhs = 'h%0x", lhs&mask, rhs&mask);
             end
      endcase
      print_msg(msg);
      return 0;
    end
    return 1;
  endfunction



  virtual function bit compare_field_real (string name, real lhs, real rhs);
    string msg;
  
    if(lhs != rhs) begin
      uvm_object::__m_uvm_status_container.scope.set_arg(name);
      $swrite(msg, "lhs = ", lhs, " : rhs = ", rhs);
      print_msg(msg);
      return 0;
    end
    return 1;
  endfunction



  virtual function bit compare_object (string name, uvm_object lhs, uvm_object rhs);
    if (rhs == lhs)
      return 1;

    if (policy == UVM_REFERENCE && lhs != rhs) begin
      uvm_object::__m_uvm_status_container.scope.set_arg(name);
      print_msg_object(lhs, rhs);
      return 0;
    end

    if (rhs == null || lhs == null) begin
      uvm_object::__m_uvm_status_container.scope.set_arg(name);
      print_msg_object(lhs, rhs);
      return 0;  
    end

    uvm_object::__m_uvm_status_container.scope.down(name);
    compare_object = lhs.compare(rhs, this);
    uvm_object::__m_uvm_status_container.scope.up();

  endfunction
  
  

  virtual function bit compare_string (string name, string lhs, string rhs);
    string msg;
    if(lhs != rhs) begin
      uvm_object::__m_uvm_status_container.scope.set_arg(name);
      msg = { "lhs = \"", lhs, "\" : rhs = \"", rhs, "\""};
      print_msg(msg);
      return 0;
    end
    return 1;
  endfunction



  function void print_msg (string msg);
    uvm_root root;
    uvm_coreservice_t cs;
    cs = uvm_coreservice_t::get();
    root = cs.get_root();
     
    result++;
    if(result <= show_max) begin
       msg = {"Miscompare for ", uvm_object::__m_uvm_status_container.scope.get(), ": ", msg};
       root.uvm_report(sev, "MISCMP", msg, verbosity, `uvm_file, `uvm_line);
    end
    miscompares = { miscompares, uvm_object::__m_uvm_status_container.scope.get(), ": ", msg, "\n" };
  endfunction





  function void print_rollup(uvm_object rhs, uvm_object lhs);
    uvm_root root;
    uvm_coreservice_t cs;

    string msg;
    cs = uvm_coreservice_t::get();
    root = cs.get_root();
    if(uvm_object::__m_uvm_status_container.scope.depth() == 0) begin
      if(result && (show_max || (uvm_severity'(sev) != UVM_INFO))) begin
        if(show_max < result) 
           $swrite(msg, "%0d Miscompare(s) (%0d shown) for object ", result, show_max);
        else begin
           $swrite(msg, "%0d Miscompare(s) for object ", result);
        end

        root.uvm_report(sev, "MISCMP", $sformatf("%s%s@%0d vs. %s@%0d", msg, lhs.get_name(), lhs.get_inst_id(), rhs.get_name(), rhs.get_inst_id()), verbosity, `uvm_file, `uvm_line);
      end
    end
  endfunction



  function void print_msg_object(uvm_object lhs, uvm_object rhs);
      uvm_root root;
  uvm_coreservice_t cs;
  cs = uvm_coreservice_t::get();
  root = cs.get_root();

    result++;
    if(result <= show_max) begin
       root.uvm_report(sev, "MISCMP",
         $sformatf("Miscompare for %0s: lhs = @%0d : rhs = @%0d", uvm_object::__m_uvm_status_container.scope.get(), (lhs!=null ? lhs.get_inst_id() : 0), 	(rhs != null ? rhs.get_inst_id() : 0)), verbosity, `uvm_file, `uvm_line);
    end
    $swrite(miscompares, "%s%s: lhs = @%0d : rhs = @%0d", miscompares, uvm_object::__m_uvm_status_container.scope.get(), (lhs != null ? lhs.get_inst_id() : 0), (rhs != null ? rhs.get_inst_id() : 0));
  endfunction

  static function uvm_comparer init();
    if(uvm_default_comparer==null) uvm_default_comparer=new;
    return uvm_default_comparer;
  endfunction
 
  int depth;                      
  uvm_object compare_map[uvm_object];
  uvm_scope_stack scope    = new;

endclass

typedef bit signed [(`UVM_PACKER_MAX_BYTES*8)-1:0] uvm_pack_bitstream_t;

class uvm_packer;

  bit physical = 1;
  bit abstract;
  bit use_metadata;
  bit big_endian = 1;
  static bit bitstream[];   
  static bit fabitstream[]; 
  int count;                
  uvm_scope_stack scope= new;
  bit   reverse_order;      
  byte  byte_size     = 8;  
  int   word_size     = 16; 
  bit   nopack;             
  uvm_recursion_policy_enum policy = UVM_DEFAULT_POLICY;
  uvm_pack_bitstream_t m_bits;
  int m_packed_size;

  virtual function void index_error(int index, string id, int sz);
      uvm_report_error("PCKIDX", $sformatf("index %0d for get_%0s too large; valid index range is 0-%0d.", index,id,((m_packed_size+sz-1)/sz)-1), UVM_NONE);
  endfunction
  
  virtual function bit enough_bits(int needed, string id);
    if ((m_packed_size - count) < needed) begin
      uvm_report_error("PCKSZ", $sformatf("%0d bits needed to unpack %0s, yet only %0d available.", needed, id, (m_packed_size - count)), UVM_NONE);
      return 0;
    end
    return 1;
  endfunction
  
  virtual function int get_packed_size();
    return m_packed_size;
  endfunction
  
  virtual function void set_packed_size();
    m_packed_size = count;
    count = 0;
  endfunction
  
  virtual function void reset();
    count = 0;
    m_bits = 0;
    m_packed_size = 0;
  endfunction
  
  virtual function uvm_pack_bitstream_t get_packed_bits();
    return m_bits;
  endfunction
  
  virtual function void get_bits(ref bit unsigned bits[]);
    bits = new[m_packed_size];
    for (int i=0;i<m_packed_size;i++)
      bits[i] = m_bits[i];
  endfunction
  
  virtual function void get_bytes(ref byte unsigned bytes[]);
    int sz;
    byte v;
    sz = (m_packed_size+7) / 8;
    bytes = new[sz];
    for (int i=0;i<sz;i++) begin
      if (i != sz-1 || (m_packed_size % 8) == 0) 
        v = m_bits[ i*8 +: 8 ];
      else
        v = m_bits[ i*8 +: 8 ] & ('hFF >> (8-(m_packed_size%8)));
      if(big_endian) begin
        byte tmp; tmp = v;
        for(int j=0; j<8; ++j) v[j] = tmp[7-j];
      end
      bytes[i] = v;
    end
  endfunction
  
  virtual function void get_ints(ref int unsigned ints[]);
    int sz, v;
    sz = (m_packed_size+31) / 32;
    ints = new[sz];
    for (int i=0;i<sz;i++) begin
      if (i != sz-1 || (m_packed_size % 32) == 0) 
        v = m_bits[ i*32 +: 32 ];
      else
        v = m_bits[ i*32 +: 32 ] & ('hFFFFFFFF >> (32-(m_packed_size%32)));
      if(big_endian) begin
        int tmp; tmp = v;
        for(int j=0; j<32; ++j) v[j] = tmp[31-j];
      end
      ints[i] = v;
    end
  endfunction
  
  virtual function void put_bits (ref bit bitstream []);
  
    int bit_size;
  
    bit_size = bitstream.size();
  
    if(big_endian)
      for (int i=bit_size-1;i>=0;i--)
        m_bits[i] = bitstream[i];
    else
      for (int i=0;i<bit_size;i++)
        m_bits[i] = bitstream[i];
  
    m_packed_size = bit_size;
    count = 0;
   
  endfunction
  
  virtual function void put_bytes (ref byte unsigned bytestream []);
  
    int byte_size;
    int index;
    byte unsigned b;
  
    byte_size = bytestream.size();
    index = 0;
    for (int i=0;i<byte_size;i++) begin
      b = bytestream[i];
      if(big_endian) begin
        byte unsigned tb; tb = b;
        for(int j=0;j<8;++j) b[j] = tb[7-j];
      end
      m_bits[index +:8] = b;
      index += 8;
    end
  
    m_packed_size = byte_size*8;
    count = 0;
  endfunction
  
  virtual function void put_ints (ref int unsigned intstream []);
  
    int int_size;
    int index;
    int unsigned v;
  
    int_size = intstream.size();
  
    index = 0;
    for (int i=0;i<int_size;i++) begin
      v = intstream[i];
      if(big_endian) begin
        int unsigned tv; tv = v;
        for(int j=0;j<32;++j) v[j] = tv[31-j];
      end
      m_bits[index +:32] = v;
      index += 32;
    end
  
    m_packed_size = int_size*32;
    count = 0;
  endfunction
  
  virtual function bit unsigned get_bit(int unsigned index);
    if (index >= m_packed_size)
      index_error(index, "bit",1);
    return m_bits[index];
  endfunction
  
  virtual function byte unsigned get_byte(int unsigned index);
    if (index >= (m_packed_size+7)/8)
      index_error(index, "byte",8);
    return m_bits[index*8 +: 8];
  endfunction
  
  virtual function int unsigned get_int(int unsigned index);
    if (index >= (m_packed_size+31)/32)
      index_error(index, "int",32);
    return m_bits[(index*32) +: 32];
  endfunction
  
  virtual function void pack_object(uvm_object value);
  
    if(value.__m_uvm_status_container.cycle_check.exists(value)) begin
      uvm_report_warning("CYCFND", $sformatf("Cycle detected for object @%0d during pack", value.get_inst_id()), UVM_NONE);
      return;
    end
    value.__m_uvm_status_container.cycle_check[value] = 1;
  
    if((policy != UVM_REFERENCE) && (value != null) ) begin
        if(use_metadata == 1) begin
          m_bits[count +: 4] = 1;
          count += 4; 
        end
        scope.down(value.get_name());
        value.__m_uvm_field_automation(null, UVM_PACK,"");
        value.do_pack(this);
        scope.up();
    end
    else if(use_metadata == 1) begin
      m_bits[count +: 4] = 0;
      count += 4;
    end
    value.__m_uvm_status_container.cycle_check.delete(value);
  endfunction
  
  virtual function void pack_real(real value);
    pack_field_int($realtobits(value), 64);
  endfunction
  
  virtual function void pack_time(time value);
    pack_field_int(value, 64);
  endfunction
  
  virtual function void pack_field(uvm_bitstream_t value, int size);
    for (int i=0; i<size; i++)
      if(big_endian == 1)
        m_bits[count+i] = value[size-1-i];
      else
        m_bits[count+i] = value[i];
    count += size;
  endfunction
  
  virtual function void pack_field_int(uvm_integral_t value, int size);
    for (int i=0; i<size; i++)
      if(big_endian == 1)
        m_bits[count+i] = value[size-1-i];
      else
        m_bits[count+i] = value[i];
    count += size;
  endfunction
  
  virtual function void pack_bits(ref bit value[], input int size = -1);
     if (size < 0)
       size = value.size();
  
     if (size > value.size()) begin
        `uvm_error("UVM/BASE/PACKER/BAD_SIZE", $sformatf("pack_bits called with size '%0d', which exceeds value.size() of '%0d'", size, value.size()))
        return;
     end
     
     for (int i=0; i<size; i++)
       if (big_endian == 1)
         m_bits[count+i] = value[size-1-i];
       else
         m_bits[count+i] = value[i];
     count += size;
  endfunction 
  
  virtual function void pack_bytes(ref byte value[], input int size = -1);
     int max_size = value.size() * $bits(byte);
     
     if (size < 0)
       size = max_size;
  
     if (size > max_size) begin
        `uvm_error("UVM/BASE/PACKER/BAD_SIZE", $sformatf("pack_bytes called with size '%0d', which exceeds value size of '%0d'", size, max_size))
        return;
     end
     else begin
        int idx_select;
  
        for (int i=0; i<size; i++) begin
           if (big_endian == 1)
             idx_select = size-1-i;
           else
             idx_select = i;
           
           m_bits[count+i] = value[idx_select / $bits(byte)][idx_select % $bits(byte)];
        end
     
        count += size;
     end
  endfunction 
  
  
  virtual function void pack_ints(ref int value[], input int size = -1);
     int max_size = value.size() * $bits(int);
     
     if (size < 0)
       size = max_size;
  
     if (size > max_size) begin
        `uvm_error("UVM/BASE/PACKER/BAD_SIZE", $sformatf("pack_ints called with size '%0d', which exceeds value size of '%0d'", size, max_size))
        return;
     end
     else begin
        int idx_select;
  
        for (int i=0; i<size; i++) begin
           if (big_endian == 1)
             idx_select = size-1-i;
           else
             idx_select = i;
           
           m_bits[count+i] = value[idx_select / $bits(int)][idx_select % $bits(int)];
        end
     
        count += size;
     end
  endfunction 
  
  virtual function void pack_string(string value);
    byte b;
    foreach (value[index]) begin
      if(big_endian == 0)
        m_bits[count +: 8] = value[index];
      else begin
        b = value[index];
        for(int i=0; i<8; ++i)
          m_bits[count+i] = b[7-i];
      end 
      count += 8;
    end
    if(use_metadata == 1) begin
      m_bits[count +: 8] = 0;
      count += 8;
    end
  endfunction 
  
  virtual function bit is_null();
    return (m_bits[count+:4]==0);
  endfunction
  
  virtual function void unpack_object_ext(inout uvm_object value);
    unpack_object(value);
  endfunction
  
  virtual function void unpack_object(uvm_object value);
  
    byte is_non_null; is_non_null = 1;
  
    if(value.__m_uvm_status_container.cycle_check.exists(value)) begin
      uvm_report_warning("CYCFND", $sformatf("Cycle detected for object @%0d during unpack", value.get_inst_id()), UVM_NONE);
      return;
    end
    value.__m_uvm_status_container.cycle_check[value] = 1;
  
    if(use_metadata == 1) begin
      is_non_null = m_bits[count +: 4];
      count+=4;
    end
  
    if (value != null)begin
      if (is_non_null > 0) begin
        scope.down(value.get_name());
        value.__m_uvm_field_automation(null, UVM_UNPACK,"");
        value.do_unpack(this);
        scope.up();
      end
      else begin
      end
    end
    else if ((is_non_null != 0) && (value == null)) begin
       uvm_report_error("UNPOBJ","cannot unpack into null object", UVM_NONE);
    end
    value.__m_uvm_status_container.cycle_check.delete(value);
  
  endfunction
  
  virtual function real unpack_real();
    if (enough_bits(64,"real")) begin
      return $bitstoreal(unpack_field_int(64));
    end
  endfunction
  
  virtual function time unpack_time();
    if (enough_bits(64,"time")) begin
      return unpack_field_int(64);
    end
  endfunction
  
  virtual function uvm_bitstream_t unpack_field(int size);
    unpack_field = 'b0;
    if (enough_bits(size,"integral")) begin
      count += size;
      for (int i=0; i<size; i++)
        if(big_endian == 1)
          unpack_field[i] = m_bits[count-i-1];
        else
          unpack_field[i] = m_bits[count-size+i];
    end
  endfunction
  
  virtual function uvm_integral_t unpack_field_int(int size);
    unpack_field_int = 'b0;
    if (enough_bits(size,"integral")) begin
      count += size;
      for (int i=0; i<size; i++)
        if(big_endian == 1)
          unpack_field_int[i] = m_bits[count-i-1];
        else
          unpack_field_int[i] = m_bits[count-size+i];
    end
  endfunction
  
  virtual function void unpack_bits(ref bit value[], input int size = -1);
     if (size < 0)
       size = value.size();
  
     if (size > value.size()) begin
        `uvm_error("UVM/BASE/PACKER/BAD_SIZE", $sformatf("unpack_bits called with size '%0d', which exceeds value.size() of '%0d'", size, value.size()))
        return;
     end
     
     if (enough_bits(size, "integral")) begin
        count += size;
        for (int i=0; i<size; i++)
          if (big_endian == 1)
            value[i] = m_bits[count-i-1];
          else
            value[i] = m_bits[count-size+i];
     end
  endfunction
  
  virtual function void unpack_bytes(ref byte value[], input int size = -1);
     int max_size = value.size() * $bits(byte);
     if (size < 0)
       size = max_size;
  
     if (size > max_size) begin
        `uvm_error("UVM/BASE/PACKER/BAD_SIZE", $sformatf("unpack_bytes called with size '%0d', which exceeds value size of '%0d'", size, value.size()))
        return;
     end
     else begin
        if (enough_bits(size, "integral")) begin
           count += size;
  
           for (int i=0; i<size; i++) begin
              if (big_endian == 1)
                value[ i / $bits(byte) ][ i % $bits(byte) ] = m_bits[count-i-1];
              else
                value[ i / $bits(byte) ][ i % $bits(byte) ] = m_bits[count-size+i];
           
           end
        end 
     end
  endfunction
  
  
  virtual function void unpack_ints(ref int value[], input int size = -1);
     int max_size = value.size() * $bits(int);
     if (size < 0)
       size = max_size;
  
     if (size > max_size) begin
        `uvm_error("UVM/BASE/PACKER/BAD_SIZE", $sformatf("unpack_ints called with size '%0d', which exceeds value size of '%0d'", size, value.size()))
        return;
     end
     else begin
        if (enough_bits(size, "integral")) begin
           count += size;
  
           for (int i=0; i<size; i++) begin
              if (big_endian == 1)
                value[ i / $bits(int) ][ i % $bits(int) ] = m_bits[count-i-1];
              else
                value[ i / $bits(int) ][ i % $bits(int) ] = m_bits[count-size+i];
           end   
        end
     end
  endfunction
  
  virtual function string unpack_string(int num_chars=-1);
    byte b;
    bit  is_null_term; 
    int i; i=0;
    if(num_chars == -1) is_null_term = 1;
    else is_null_term = 0;
  
    while(enough_bits(8,"string") && 
          ((m_bits[count+:8] != 0) || (is_null_term == 0)) &&
          ((i<num_chars)||(is_null_term==1)) )
    begin
      unpack_string = {unpack_string," "};
      if(big_endian == 0)
        unpack_string[i] = m_bits[count +: 8];
      else begin
        for(int j=0; j<8; ++j)
          b[7-j] = m_bits[count+j];
        unpack_string[i] = b;
      end 
      count += 8;
      ++i;
    end
    if(enough_bits(8,"string"))
      count += 8;
  endfunction

endclass

virtual class uvm_link_base extends uvm_object;

   function new(string name="unnamed-uvm_link_base");
      super.new(name);
   endfunction : new

   function void set_lhs(uvm_object lhs);
      do_set_lhs(lhs);
   endfunction : set_lhs

   function uvm_object get_lhs();
      return do_get_lhs();
   endfunction : get_lhs

   function void set_rhs(uvm_object rhs);
      do_set_rhs(rhs);
   endfunction : set_rhs

   function uvm_object get_rhs();
      return do_get_rhs();
   endfunction : get_rhs

   function void set(uvm_object lhs, rhs);
      do_set_lhs(lhs);
      do_set_rhs(rhs);
   endfunction : set

   pure virtual function void do_set_lhs(uvm_object lhs);
   pure virtual function uvm_object do_get_lhs();
   pure virtual function void do_set_rhs(uvm_object rhs);
   pure virtual function uvm_object do_get_rhs();

endclass : uvm_link_base


class uvm_parent_child_link extends uvm_link_base;

   local uvm_object m_lhs;
   local uvm_object m_rhs;

   `uvm_object_utils_begin(uvm_parent_child_link)
   `uvm_object_utils_end

   function new(string name="unnamed-uvm_parent_child_link");
      super.new(name);
   endfunction : new

   static function uvm_parent_child_link get_link(uvm_object lhs, uvm_object rhs, string name="pc_link");
      uvm_parent_child_link pc_link = new(name);
      pc_link.set(lhs, rhs);
      return pc_link;
   endfunction : get_link
   
   virtual function void do_set_lhs(uvm_object lhs);
      m_lhs = lhs;
   endfunction : do_set_lhs

   virtual function uvm_object do_get_lhs();
      return m_lhs;
   endfunction : do_get_lhs

   virtual function void do_set_rhs(uvm_object rhs);
      m_rhs = rhs;
   endfunction : do_set_rhs

   virtual function uvm_object do_get_rhs();
      return m_rhs;
   endfunction : do_get_rhs

endclass : uvm_parent_child_link


class uvm_cause_effect_link extends uvm_link_base;

   local uvm_object m_lhs;
   local uvm_object m_rhs;

   `uvm_object_utils_begin(uvm_cause_effect_link)
   `uvm_object_utils_end

   function new(string name="unnamed-uvm_cause_effect_link");
      super.new(name);
   endfunction : new

   static function uvm_cause_effect_link get_link(uvm_object lhs, uvm_object rhs, string name="ce_link");
      uvm_cause_effect_link ce_link = new(name);
      ce_link.set(lhs, rhs);
      return ce_link;
   endfunction : get_link

   virtual function void do_set_lhs(uvm_object lhs);
      m_lhs = lhs;
   endfunction : do_set_lhs

   virtual function uvm_object do_get_lhs();
      return m_lhs;
   endfunction : do_get_lhs

   virtual function void do_set_rhs(uvm_object rhs);
      m_rhs = rhs;
   endfunction : do_set_rhs

   virtual function uvm_object do_get_rhs();
      return m_rhs;
   endfunction : do_get_rhs

endclass : uvm_cause_effect_link


class uvm_related_link extends uvm_link_base;

   local uvm_object m_lhs;
   local uvm_object m_rhs;

   `uvm_object_utils_begin(uvm_related_link)
   `uvm_object_utils_end

   function new(string name="unnamed-uvm_related_link");
      super.new(name);
   endfunction : new

   static function uvm_related_link get_link(uvm_object lhs, uvm_object rhs, string name="ce_link");
      uvm_related_link ce_link = new(name);
      ce_link.set(lhs, rhs);
      return ce_link;
   endfunction : get_link
   
   virtual function void do_set_lhs(uvm_object lhs);
      m_lhs = lhs;
   endfunction : do_set_lhs

   virtual function uvm_object do_get_lhs();
      return m_lhs;
   endfunction : do_get_lhs

   virtual function void do_set_rhs(uvm_object rhs);
      m_rhs = rhs;
   endfunction : do_set_rhs

   virtual function uvm_object do_get_rhs();
      return m_rhs;
   endfunction : do_get_rhs

endclass : uvm_related_link

typedef class uvm_recorder;
typedef class uvm_tr_stream;
typedef class uvm_link_base;
typedef class uvm_simple_lock_dap;
typedef class uvm_text_tr_stream;

virtual class uvm_tr_database extends uvm_object;

   local bit m_is_opened;
   local bit m_streams[uvm_tr_stream];
   
   function new(string name="unnamed-uvm_tr_database");
      super.new(name);
   endfunction : new
   
   function bit open_db();
      if (!m_is_opened)
        m_is_opened = do_open_db();
      return m_is_opened;
   endfunction : open_db

   function bit close_db();
      if (m_is_opened) begin
         if (do_close_db())
           m_is_opened = 0;
      end
      return (m_is_opened == 0);
   endfunction : close_db

   function bit is_open();
      return m_is_opened;
   endfunction : is_open
   
   function uvm_tr_stream open_stream(string name, string scope="", string type_name="");
      if (!open_db()) begin
         return null;
      end
      else begin
         process p = process::self();
         string s;

         if (p != null)
           s = p.get_randstate();

         open_stream = do_open_stream(name, scope, type_name);


         if (open_stream != null) begin
            m_streams[open_stream] = 1;
            open_stream.m_do_open(this, scope, type_name);
         end
         
         if (p != null)
           p.set_randstate(s);

      end
   endfunction : open_stream

   function void m_free_stream(uvm_tr_stream stream);
      if (m_streams.exists(stream))
        m_streams.delete(stream);
   endfunction : m_free_stream
   
   function unsigned get_streams(ref uvm_tr_stream q[$]);
      q.delete();
      foreach (m_streams[idx])
        q.push_back(idx);
      return q.size();
   endfunction : get_streams
   
   
   function void establish_link(uvm_link_base link);
      uvm_tr_stream s_lhs, s_rhs;
      uvm_recorder r_lhs, r_rhs;
      uvm_object lhs = link.get_lhs();
      uvm_object rhs = link.get_rhs();
      uvm_tr_database db;

      if (lhs == null) begin
         `uvm_warning("UVM/TR_DB/BAD_LINK", "left hand side '<null>' is not supported in links for 'uvm_tr_database'")
         return;
      end
      if (rhs == null) begin
         `uvm_warning("UVM/TR_DB/BAD_LINK", "right hand side '<null>' is not supported in links for 'uvm_tr_database'")
         return;
      end
      
      if (!$cast(s_lhs, lhs) && 
          !$cast(r_lhs, lhs)) begin
         `uvm_warning("UVM/TR_DB/BAD_LINK", $sformatf("left hand side of type '%s' not supported in links for 'uvm_tr_database'", lhs.get_type_name()))
         return;
      end
      if (!$cast(s_rhs, rhs) && 
          !$cast(r_rhs, rhs)) begin
         `uvm_warning("UVM/TR_DB/BAD_LINK", $sformatf("right hand side of type '%s' not supported in links for 'uvm_record_datbasae'", rhs.get_type_name()))
         return;
      end
      
      if (r_lhs != null) begin
         s_lhs = r_lhs.get_stream();
      end
      if (r_rhs != null) begin
         s_rhs = r_rhs.get_stream();
      end

      if ((s_lhs != null) && (s_lhs.get_db() != this)) begin
         db = s_lhs.get_db();
         `uvm_warning("UVM/TR_DB/BAD_LINK", $sformatf("attempt to link stream from '%s' into '%s'", db.get_name(), this.get_name())) return;
      end
      if ((s_rhs != null) && (s_rhs.get_db() != this)) begin
         db = s_rhs.get_db();
         `uvm_warning("UVM/TR_DB/BAD_LINK", $sformatf("attempt to link stream from '%s' into '%s'", db.get_name(), this.get_name()))
         return;
      end

      do_establish_link(link);
   endfunction : establish_link
      

   pure virtual protected function bit do_open_db();

   pure virtual protected function bit do_close_db();

   pure virtual protected function uvm_tr_stream do_open_stream(string name, string scope, string type_name);

   pure virtual protected function void do_establish_link(uvm_link_base link);

endclass : uvm_tr_database

   
class uvm_text_tr_database extends uvm_tr_database;

   local uvm_simple_lock_dap#(string) m_filename_dap;
   UVM_FILE m_file;

   `uvm_object_utils_begin(uvm_text_tr_database)
   `uvm_object_utils_end

   function new(string name="unnamed-uvm_text_tr_database");
      super.new(name);

      m_filename_dap = new("filename_dap");
      m_filename_dap.set("tr_db.log");
   endfunction : new

   
   protected virtual function bit do_open_db();
      if (m_file == 0) begin
         m_file = $fopen(m_filename_dap.get(), "a+");
         if (m_file != 0)
           m_filename_dap.lock();
      end
      return (m_file != 0);
   endfunction : do_open_db
   
   protected virtual function bit do_close_db();
      if (m_file != 0) begin
         fork 
            $fclose(m_file);
         join_none
         m_filename_dap.unlock();
      end
      return 1;
   endfunction : do_close_db
   
   protected virtual function uvm_tr_stream do_open_stream(string name, string scope, string type_name);
      uvm_text_tr_stream m_stream = uvm_text_tr_stream::type_id::create(name);
      return m_stream;
   endfunction : do_open_stream

   protected virtual function void do_establish_link(uvm_link_base link);
      uvm_recorder r_lhs, r_rhs;
      uvm_object lhs = link.get_lhs();
      uvm_object rhs = link.get_rhs();
      
      void'($cast(r_lhs, lhs));
      void'($cast(r_rhs, rhs));
      
      if ((r_lhs == null) ||
          (r_rhs == null))
        return;
      else begin
         uvm_parent_child_link pc_link;
         uvm_related_link re_link;
         if ($cast(pc_link, link)) begin
            $fdisplay(m_file,"  LINK @%0t {TXH1:%0d TXH2:%0d RELATION=%0s}", $time, r_lhs.get_handle(), r_rhs.get_handle(), "child");
            
         end
         else if ($cast(re_link, link)) begin
            $fdisplay(m_file,"  LINK @%0t {TXH1:%0d TXH2:%0d RELATION=%0s}", $time, r_lhs.get_handle(), r_rhs.get_handle(), "");
            
         end
      end
   endfunction : do_establish_link

   
   function void set_file_name(string filename);
      if (filename == "") begin
        `uvm_warning("UVM/TXT_DB/EMPTY_NAME", "Ignoring attempt to set file name to ''!")
	return;
      end

      if (!m_filename_dap.try_set(filename)) begin
         `uvm_warning("UVM/TXT_DB/SET_AFTER_OPEN", "Ignoring attempt to change file name after opening the db!")
         return;
      end
   endfunction : set_file_name

endclass : uvm_text_tr_database


class m_uvm_tr_stream_cfg;
   uvm_tr_database db;
   string scope;
   string stream_type_name;
endclass : m_uvm_tr_stream_cfg

typedef class uvm_set_before_get_dap;
typedef class uvm_text_recorder;
   
virtual class uvm_tr_stream extends uvm_object;

   local uvm_set_before_get_dap#(m_uvm_tr_stream_cfg) m_cfg_dap;
   local bit m_records[uvm_recorder];
   local bit m_warn_null_cfg;
   local bit m_is_opened;
   local bit m_is_closed;
   local static integer m_ids_by_stream[uvm_tr_stream];
   
   function new(string name="unnamed-uvm_tr_stream");
      super.new(name);
      m_cfg_dap = new("cfg_dap");
   endfunction : new
   
   function uvm_tr_database get_db();
      m_uvm_tr_stream_cfg m_cfg;
      if (!m_cfg_dap.try_get(m_cfg)) begin
         if (m_warn_null_cfg == 1)
           `uvm_warning("UVM/REC_STR/NO_CFG", $sformatf("attempt to retrieve DB from '%s' before it was set!", get_name()))
         m_warn_null_cfg = 0;
         return null;
      end
      return m_cfg.db;
   endfunction : get_db
      
   function string get_scope();
      m_uvm_tr_stream_cfg m_cfg;
      if (!m_cfg_dap.try_get(m_cfg)) begin
         if (m_warn_null_cfg == 1)
           `uvm_warning("UVM/REC_STR/NO_CFG", $sformatf("attempt to retrieve scope from '%s' before it was set!", get_name()))
         m_warn_null_cfg = 0;
         return "";
      end
      return m_cfg.scope;
   endfunction : get_scope
      
   function string get_stream_type_name();
      m_uvm_tr_stream_cfg m_cfg;
      if (!m_cfg_dap.try_get(m_cfg)) begin
         if (m_warn_null_cfg == 1)
           `uvm_warning("UVM/REC_STR/NO_CFG", $sformatf("attempt to retrieve STREAM_TYPE_NAME from '%s' before it was set!", get_name()))
         m_warn_null_cfg = 0;
         return "";
      end
      return m_cfg.stream_type_name;
   endfunction : get_stream_type_name


   function void close();
      if (!is_open())
        return;

      do_close();

      foreach (m_records[idx])
        if (idx.is_open())
          idx.close();

      m_is_opened = 0;
      m_is_closed = 1;
   endfunction : close

   function void free();
	   process p;
	   string s;
      uvm_tr_database db;
      if (!is_open() && !is_closed())
        return;

      if (is_open())
        close();

      do_free();
      
      foreach (m_records[idx])
        idx.free();

      db = get_db();
      m_is_closed = 0;
      p = process::self();
      if(p != null)
      	s = p.get_randstate();
      m_cfg_dap = new("cfg_dap");
      if(p != null)
      	p.set_randstate(s);
      m_warn_null_cfg = 1;
      if (m_ids_by_stream.exists(this))
        m_free_id(m_ids_by_stream[this]);

      if (db != null)
        db.m_free_stream(this);
   endfunction : free
   
   function void m_do_open(uvm_tr_database db, string scope="", string stream_type_name="");
      
      m_uvm_tr_stream_cfg m_cfg;
      uvm_tr_database m_db;
      if (db == null) begin
         `uvm_error("UVM/REC_STR/NULL_DB", $sformatf("Illegal attempt to set DB for '%s' to '<null>'", this.get_full_name()))
         return;
      end

      if (m_cfg_dap.try_get(m_cfg)) begin
         `uvm_error("UVM/REC_STR/RE_CFG", $sformatf("Illegal attempt to re-open '%s'", this.get_full_name()))
      end
      else begin
         m_cfg = new();
         m_cfg.db = db;
         m_cfg.scope = scope;
         m_cfg.stream_type_name = stream_type_name;
         m_cfg_dap.set(m_cfg);
         m_is_opened = 1;

         do_open(db, scope, stream_type_name);
      end
      
   endfunction : m_do_open

   function bit is_open();
      return m_is_opened;
   endfunction : is_open

   function bit is_closed();
      return m_is_closed;
   endfunction : is_closed

   
   function uvm_recorder open_recorder(string name, time   open_time = 0, string type_name="");
      time m_time = (open_time == 0) ? $time : open_time;

      if (!is_open())
        return null;
      else begin
         process p = process::self();
         string s;

         if (p != null)
           s = p.get_randstate();
         
         open_recorder = do_open_recorder(name, m_time, type_name);


         
         if (open_recorder != null) begin
            m_records[open_recorder] = 1;
            open_recorder.m_do_open(this, m_time, type_name);
         end
         if (p != null)
           p.set_randstate(s); 
      end
   endfunction : open_recorder

   function void m_free_recorder(uvm_recorder recorder);
      if (m_records.exists(recorder))
        m_records.delete(recorder);
   endfunction : m_free_recorder

   function unsigned get_recorders(ref uvm_recorder q[$]);
      q.delete();
      foreach (m_records[idx])
        q.push_back(idx);
      return q.size();
   endfunction : get_recorders
   

   local static uvm_tr_stream m_streams_by_id[integer];

   function integer get_handle();
      if (!is_open() && !is_closed()) begin
        return 0;
      end
      else begin
         integer handle = get_inst_id();
         
         if (m_ids_by_stream.exists(this) && m_ids_by_stream[this] != handle)
           m_streams_by_id.delete(m_ids_by_stream[this]);

         m_streams_by_id[handle] = this;
         m_ids_by_stream[this] = handle;

         return handle;
      end
   endfunction : get_handle
   
   virtual function integer m_get_handle();
      return get_handle();
   endfunction : m_get_handle
   
   static function uvm_tr_stream get_stream_from_handle(integer id);
      if (id == 0)
        return null;

      if ($isunknown(id) || !m_streams_by_id.exists(id))
        return null;

      return m_streams_by_id[id];
   endfunction : get_stream_from_handle
        
   static function void m_free_id(integer id);
      uvm_tr_stream stream;
      if (!$isunknown(id) && m_streams_by_id.exists(id))
        stream = m_streams_by_id[id];

      if (stream != null) begin
         m_streams_by_id.delete(id);
         m_ids_by_stream.delete(stream);
      end
   endfunction : m_free_id


   protected virtual function void do_open(uvm_tr_database db, string scope, string stream_type_name);
   endfunction : do_open

   protected virtual function void do_close();
   endfunction : do_close
      
   protected virtual function void do_free();
   endfunction : do_free

   protected virtual function uvm_recorder do_open_recorder(string name, time   open_time, string type_name);
      return null;
   endfunction : do_open_recorder

endclass : uvm_tr_stream


class uvm_text_tr_stream extends uvm_tr_stream;

   local uvm_text_tr_database m_text_db;
   
   `uvm_object_utils_begin(uvm_text_tr_stream)
   `uvm_object_utils_end

   function new(string name="unnamed-uvm_text_tr_stream");
      super.new(name);
   endfunction : new


   protected virtual function void do_open(uvm_tr_database db, string scope, string stream_type_name);
      $cast(m_text_db, db);
      if (m_text_db.open_db())
        $fdisplay(m_text_db.m_file, "  CREATE_STREAM @%0t {NAME:%s T:%s SCOPE:%s STREAM:%0d}", $time, this.get_name(), stream_type_name, scope, this.get_handle());
   endfunction : do_open

   protected virtual function void do_close();
      if (m_text_db.open_db())
        $fdisplay(m_text_db.m_file, "  CLOSE_STREAM @%0t {NAME:%s T:%s SCOPE:%s STREAM:%0d}", $time, this.get_name(), this.get_stream_type_name(), this.get_scope(), this.get_handle());
   endfunction : do_close
      
   protected virtual function void do_free();
      if (m_text_db.open_db())
        $fdisplay(m_text_db.m_file, "  FREE_STREAM @%0t {NAME:%s T:%s SCOPE:%s STREAM:%0d}", $time, this.get_name(), this.get_stream_type_name(), this.get_scope(), this.get_handle());
      m_text_db = null;
      return;
   endfunction : do_free
   
   protected virtual function uvm_recorder do_open_recorder(string name, time   open_time, string type_name);
      if (m_text_db.open_db()) begin
         return uvm_text_recorder::type_id::create(name);
      end

      return null;
   endfunction : do_open_recorder

endclass : uvm_text_tr_stream


typedef class uvm_report_message;



virtual class uvm_recorder extends uvm_object;

   local uvm_set_before_get_dap#(uvm_tr_stream) m_stream_dap;
   local bit m_warn_null_stream;
   local bit m_is_opened;
   local bit m_is_closed;
   local time m_open_time;
   local time m_close_time;
   int recording_depth;
   uvm_radix_enum default_radix = UVM_HEX;
   bit physical = 1;
   bit abstract = 1;
   bit identifier = 1;
   uvm_recursion_policy_enum policy = UVM_DEFAULT_POLICY;
   local static integer m_ids_by_recorder[uvm_recorder];

   function new(string name = "uvm_recorder");
      super.new(name);
      m_stream_dap = new("stream_dap");
      m_warn_null_stream = 1;
   endfunction
    
   function uvm_tr_stream get_stream();
       if (!m_stream_dap.try_get(get_stream)) begin
          if (m_warn_null_stream == 1) 
            `uvm_warning("UVM/REC/NO_CFG", $sformatf("attempt to retrieve STREAM from '%s' before it was set!", get_name()))
          m_warn_null_stream = 0;
       end
   endfunction : get_stream

   function void close(time close_time = 0);
       if (close_time == 0)
         close_time = $realtime;

       if (!is_open())
         return;

       do_close(close_time);
       
       m_is_opened = 0;
       m_is_closed = 1;
       m_close_time = close_time;
   endfunction : close

   function void free(time close_time = 0);
	   process p=process::self();
	   string s;
	
       uvm_tr_stream stream;
       
      if (!is_open() && !is_closed())
        return;

      if (is_open()) begin
         close(close_time);
      end

      do_free();

      stream = get_stream();
      
      m_is_closed = 0;
      if(p != null)
      	s=p.get_randstate();
      m_stream_dap = new("stream_dap");
      if(p != null)
      	p.set_randstate(s);
      m_warn_null_stream = 1;
      if (m_ids_by_recorder.exists(this))
        m_free_id(m_ids_by_recorder[this]);

      if (stream != null)
        stream.m_free_recorder(this);
   endfunction : free
      
   function bit is_open();
      return m_is_opened;
   endfunction : is_open

   function time get_open_time();
      return m_open_time;
   endfunction : get_open_time

   function bit is_closed();
      return m_is_closed;
   endfunction : is_closed
    
   function time get_close_time();
      return m_close_time;
   endfunction : get_close_time

  function void m_do_open(uvm_tr_stream stream, time open_time, string type_name);
     uvm_tr_stream m_stream;
     if (stream == null) begin
        `uvm_error("UVM/REC/NULL_STREAM", $sformatf("Illegal attempt to set STREAM for '%s' to '<null>'", this.get_name()))
        return;
     end

     if (m_stream_dap.try_get(m_stream)) begin
        `uvm_error("UVM/REC/RE_INIT", $sformatf("Illegal attempt to re-initialize '%s'", this.get_name()))
        return;
     end

     m_stream_dap.set(stream);
     m_open_time = open_time;
     m_is_opened = 1;
     
     do_open(stream, open_time, type_name);
  endfunction : m_do_open



   local static uvm_recorder m_recorders_by_id[integer];

   local static integer m_id;

   static function void m_free_id(integer id);
      uvm_recorder recorder;
      if ((!$isunknown(id)) && (m_recorders_by_id.exists(id)))
        recorder = m_recorders_by_id[id];

      if (recorder != null) begin
         m_recorders_by_id.delete(id);
         m_ids_by_recorder.delete(recorder);
      end
   endfunction : m_free_id
            
   function integer get_handle();
      if (!is_open() && !is_closed()) begin
         return 0;
      end
      else begin
         integer handle = get_inst_id();

         if (m_ids_by_recorder.exists(this) && m_ids_by_recorder[this] != handle)
           m_recorders_by_id.delete(m_ids_by_recorder[this]);
           
         m_recorders_by_id[handle] = this;
         m_ids_by_recorder[this] = handle;

         return handle;
      end
   endfunction : get_handle

   static function uvm_recorder get_recorder_from_handle(integer id);
      if (id == 0)
        return null;

      if (($isunknown(id)) || (!m_recorders_by_id.exists(id)))
        return null;

      return m_recorders_by_id[id];
   endfunction : get_recorder_from_handle

   
   function void record_field(string name, uvm_bitstream_t value, int size, uvm_radix_enum radix=UVM_NORADIX);
      if (get_stream() == null) begin
         return;
      end
      do_record_field(name, value, size, radix);
   endfunction : record_field

   function void record_field_int(string name, uvm_integral_t value, int size, uvm_radix_enum radix=UVM_NORADIX);
        if (get_stream() == null) begin
         return;
      end
      do_record_field_int(name, value, size, radix);
   endfunction : record_field_int

   function void record_field_real(string name, real value);
      if (get_stream() == null) begin
         return;
      end
      do_record_field_real(name, value);
   endfunction : record_field_real

   function void record_object(string name, uvm_object value);
      if (get_stream() == null) begin
         return;
      end
      
      do_record_object(name, value);
   endfunction : record_object

   function void record_string(string name, string value);
      if (get_stream() == null) begin
         return;
      end

      do_record_string(name, value);
   endfunction : record_string
   
   function void record_time(string name, time value);
      if (get_stream() == null) begin
         return;
      end

      do_record_time(name, value);
   endfunction : record_time
   
   function void record_generic(string name, string value, string type_name="");
      if (get_stream() == null) begin
         return;
      end

      do_record_generic(name, value, type_name);
   endfunction : record_generic

  virtual function bit use_record_attribute();
     return 0;
  endfunction : use_record_attribute

   virtual function integer get_record_attribute_handle();
      return get_handle();
   endfunction : get_record_attribute_handle
   

   protected virtual function void do_open(uvm_tr_stream stream, time open_time, string type_name);
   endfunction : do_open

   protected virtual function void do_close(time close_time);
   endfunction : do_close

   protected virtual function void do_free();
   endfunction : do_free
   
   pure virtual protected function void do_record_field(string name, uvm_bitstream_t value, int size, uvm_radix_enum radix);

   pure virtual protected function void do_record_field_int(string name, uvm_integral_t value, int          size, uvm_radix_enum radix);
   
   pure virtual protected function void do_record_field_real(string name, real value);

   pure virtual protected function void do_record_object(string name, uvm_object value);

   pure virtual protected function void do_record_string(string name, string value);

   pure virtual protected function void do_record_time(string name, time value);

   pure virtual protected function void do_record_generic(string name, string value, string type_name);

  virtual function bit open_file();
     return 0;
  endfunction

  virtual function integer create_stream (string name, string t, string scope);
     return -1;
  endfunction

   
  virtual function void m_set_attribute (integer txh, string nm, string value);
  endfunction
  
  
  virtual function void set_attribute (integer txh, string nm, logic [1023:0] value, uvm_radix_enum radix, integer numbits=1024);
  endfunction
  
  
  virtual function integer check_handle_kind (string htype, integer handle);
     return 0;
  endfunction
  
  
  virtual function integer begin_tr(string txtype, integer stream, string nm, string label="", string desc="", time begin_time=0);
    return -1;
  endfunction
  
  
  virtual function void end_tr (integer handle, time end_time=0);
  endfunction
  
  
  virtual function void link_tr(integer h1, integer h2, string relation="");
  endfunction
  
  
  
  virtual function void free_tr(integer handle);
  endfunction
  
endclass 


class uvm_text_recorder extends uvm_recorder;

   `uvm_object_utils(uvm_text_recorder)

   uvm_text_tr_database m_text_db;

   uvm_scope_stack scope = new;

   function new(string name="unnamed-uvm_text_recorder");
      super.new(name);
   endfunction : new


   protected virtual function void do_open(uvm_tr_stream stream,
                                             time open_time,
                                             string type_name);
      $cast(m_text_db, stream.get_db());
      if (m_text_db.open_db())
        $fdisplay(m_text_db.m_file, "    OPEN_RECORDER @%0t {TXH:%0d STREAM:%0d NAME:%s TIME:%0t TYPE=\"%0s\"}", $realtime, this.get_handle(), stream.get_handle(), this.get_name(), open_time, type_name);
   endfunction : do_open

   protected virtual function void do_close(time close_time);
      if (m_text_db.open_db()) begin
         $fdisplay(m_text_db.m_file, "    CLOSE_RECORDER @%0t {TXH:%0d TIME=%0t}", $realtime, this.get_handle(), close_time); 
      end
   endfunction : do_close

   protected virtual function void do_free();
      if (m_text_db.open_db()) begin
         $fdisplay(m_text_db.m_file, "    FREE_RECORDER @%0t {TXH:%0d}", $realtime, this.get_handle());
      end
      m_text_db = null;
   endfunction : do_free
   
   protected virtual function void do_record_field(string name, uvm_bitstream_t value, int size, uvm_radix_enum radix);
      scope.set_arg(name);
      if (!radix)
        radix = default_radix;

      write_attribute(scope.get(), value, radix, size);

   endfunction : do_record_field
  
   
   protected virtual function void do_record_field_int(string name, uvm_integral_t value, int          size, uvm_radix_enum radix);
      scope.set_arg(name);
      if (!radix)
        radix = default_radix;

      write_attribute_int(scope.get(), value, radix, size);

   endfunction : do_record_field_int


   protected virtual function void do_record_field_real(string name, real value);
      bit [63:0] ival = $realtobits(value);
      scope.set_arg(name);

      write_attribute_int(scope.get(), ival, UVM_REAL, 64);
   endfunction : do_record_field_real

   protected virtual function void do_record_object(string name, uvm_object value);
      int            v;
      string         str;
      
      if(identifier) begin 
         if(value != null) begin
            $swrite(str, "%0d", value.get_inst_id());
            v = str.atoi(); 
         end
         scope.set_arg(name);
         write_attribute_int(scope.get(), v, UVM_DEC, 32);
      end
 
      if(policy != UVM_REFERENCE) begin
         if(value!=null) begin
            if(value.__m_uvm_status_container.cycle_check.exists(value)) return;
            value.__m_uvm_status_container.cycle_check[value] = 1;
            scope.down(name);
            value.record(this);
            scope.up();
            value.__m_uvm_status_container.cycle_check.delete(value);
         end
      end
   endfunction : do_record_object

   protected virtual function void do_record_string(string name, string value);
      scope.set_arg(name);
      if (m_text_db.open_db()) begin
         $fdisplay(m_text_db.m_file, "      SET_ATTR @%0t {TXH:%0d NAME:%s VALUE:%s   RADIX:%s BITS=%0d}", $realtime, this.get_handle(), scope.get(), value, "UVM_STRING", 8+value.len());
      end
   endfunction : do_record_string

   protected virtual function void do_record_time(string name, time value);
      scope.set_arg(name);
      write_attribute_int(scope.get(), value, UVM_TIME, 64);
   endfunction : do_record_time

   protected virtual function void do_record_generic(string name, string value, string type_name);
      scope.set_arg(name);
      write_attribute(scope.get(), uvm_string_to_bits(value), UVM_STRING, 8+value.len());
   endfunction : do_record_generic

   
   function void write_attribute(string nm, uvm_bitstream_t value, uvm_radix_enum radix, integer numbits=$bits(uvm_bitstream_t));
      if (m_text_db.open_db()) begin
         $fdisplay(m_text_db.m_file, "      SET_ATTR @%0t {TXH:%0d NAME:%s VALUE:%s   RADIX:%s BITS=%0d}", $realtime, this.get_handle(), nm, uvm_bitstream_to_string(value, numbits, radix), radix.name(), numbits);
      end
   endfunction : write_attribute

   function void write_attribute_int(string  nm, uvm_integral_t value, uvm_radix_enum radix, integer numbits=$bits(uvm_bitstream_t));
      if (m_text_db.open_db()) begin
         $fdisplay(m_text_db.m_file, "      SET_ATTR @%0t {TXH:%0d NAME:%s VALUE:%s   RADIX:%s BITS=%0d}", $realtime, this.get_handle(), nm, uvm_integral_to_string(value, numbits, radix), radix.name(), numbits);
      end
   endfunction : write_attribute_int

   string                                                   filename;
   bit                                                      filename_set;

  virtual function bit open_file();
     if (!filename_set) begin
        m_text_db.set_file_name(filename);
     end
     return m_text_db.open_db();
  endfunction


  virtual function integer create_stream (string name, string t, string scope);
     uvm_text_tr_stream stream;
     if (open_file()) begin
        $cast(stream,m_text_db.open_stream(name, scope, t));
        return stream.get_handle();
     end
     return 0;
  endfunction

   
  virtual function void m_set_attribute (integer txh, string nm, string value);
     if (open_file()) begin
        UVM_FILE file = m_text_db.m_file;
        $fdisplay(file,"      SET_ATTR @%0t {TXH:%0d NAME:%s VALUE:%s}", $realtime,txh,nm,value);
     end
  endfunction
  
  
  virtual function void set_attribute (integer txh, string nm, logic [1023:0] value, uvm_radix_enum radix, integer numbits=1024);
     if (open_file()) begin
        UVM_FILE file = m_text_db.m_file;
         $fdisplay(file, "      SET_ATTR @%0t {TXH:%0d NAME:%s VALUE:%s   RADIX:%s BITS=%0d}", $realtime, txh, nm, uvm_bitstream_to_string(value, numbits, radix), radix.name(), numbits);
        
     end
  endfunction
  
  
  virtual function integer check_handle_kind (string htype, integer handle);
     return ((uvm_recorder::get_recorder_from_handle(handle) != null) || (uvm_tr_stream::get_stream_from_handle(handle) != null));
  endfunction
  
  
  virtual function integer begin_tr(string txtype, integer stream, string nm, string label="", string desc="", time begin_time=0);
  if (open_file()) begin
        uvm_tr_stream stream_obj = uvm_tr_stream::get_stream_from_handle(stream);
        uvm_recorder recorder;
  
        if (stream_obj == null)
          return -1;

        recorder = stream_obj.open_recorder(nm, begin_time, txtype);

        return recorder.get_handle();
     end
     return -1;
  endfunction
  
  
  virtual function void end_tr (integer handle, time end_time=0);
     if (open_file()) begin
        uvm_recorder record = uvm_recorder::get_recorder_from_handle(handle);
        if (record != null) begin
           record.close(end_time);
        end
     end
  endfunction
  
  
  virtual function void link_tr(integer h1, integer h2, string relation="");
    if (open_file())
      $fdisplay(m_text_db.m_file,"  LINK @%0t {TXH1:%0d TXH2:%0d RELATION=%0s}", $realtime,h1,h2,relation);
  endfunction
  
  virtual function void free_tr(integer handle);
     if (open_file()) begin
        uvm_recorder record = uvm_recorder::get_recorder_from_handle(handle);
        if (record != null) begin
           record.free();
        end
     end
  endfunction

endclass : uvm_text_recorder

typedef class uvm_object;
typedef class uvm_event;


virtual class uvm_event_callback#(type T=uvm_object) extends uvm_object;

  function new (string name=""); 
    super.new(name);
  endfunction

  virtual function bit pre_trigger (uvm_event#(T) e, T data);
    return 0;
  endfunction

  virtual function void post_trigger (uvm_event#(T) e, T data);
    return;
  endfunction

  virtual function uvm_object create (string name=""); 
    return null;
  endfunction

endclass

virtual class uvm_event_base extends uvm_object;
	const static string type_name = "uvm_event_base";
	protected event      m_event;
	protected int        num_waiters;
	protected bit        on;
	protected time       trigger_time=0;
	protected uvm_event_callback  callbacks[$];

	function new (string name="");
		super.new(name);
	endfunction  

	virtual task wait_on (bit delta = 0);
		if (on) begin
			if (delta)
				#0;
			return;
		end
		num_waiters++;
		@on;
	endtask

	virtual task wait_off (bit delta = 0);
		if (!on) begin
			if (delta)
				#0;
			return;
		end
		num_waiters++;
		@on;
	endtask

	virtual task wait_trigger ();
		num_waiters++;
		@m_event;
	endtask

	virtual task wait_ptrigger ();
		if (m_event.triggered)
			return;
		num_waiters++;
		@m_event;
	endtask

	virtual function time get_trigger_time ();
		return trigger_time;
	endfunction

	virtual function bit is_on ();
		return (on == 1);
	endfunction

	virtual function bit is_off ();
		return (on == 0);
	endfunction

	virtual function void reset (bit wakeup = 0);
		event e;
		if (wakeup)
			->m_event;
		m_event = e;
		num_waiters = 0;
		on = 0;
		trigger_time = 0;
	endfunction

	virtual function void cancel ();
		if (num_waiters > 0)
			num_waiters--;
	endfunction

	virtual function int get_num_waiters ();
		return num_waiters;
	endfunction

	virtual function string get_type_name();
		return type_name;
	endfunction

	virtual function void do_print (uvm_printer printer);
		printer.print_field_int("num_waiters", num_waiters, $bits(num_waiters), UVM_DEC, ".", "int");
		printer.print_field_int("on", on, $bits(on), UVM_BIN, ".", "bit");
		printer.print_time("trigger_time", trigger_time);
		printer.m_scope.down("callbacks");
		foreach(callbacks[e]) begin
			printer.print_object($sformatf("[%0d]",e), callbacks[e], "[");
		end
		printer.m_scope.up();
	endfunction

	virtual function void do_copy (uvm_object rhs);
		uvm_event_base e;
		super.do_copy(rhs);
		if(!$cast(e, rhs) || (e==null)) return;

		m_event = e.m_event;
		num_waiters = e.num_waiters;
		on = e.on;
		trigger_time = e.trigger_time;
		callbacks.delete();
		callbacks = e.callbacks;   

	endfunction

endclass


class uvm_event#(type T=uvm_object) extends uvm_event_base;

	const static string type_name = "uvm_event";
	local T trigger_data;


	function new (string name="");
		super.new(name);
	endfunction  

	virtual task wait_trigger_data (output T data);
		wait_trigger();
		data = get_trigger_data();
	endtask

	virtual task wait_ptrigger_data (output T data);
		wait_ptrigger();
		data = get_trigger_data();
	endtask


	virtual function void trigger (T data=null);
		int skip;
		skip=0;
		if (callbacks.size()) begin
			for (int i=0;i<callbacks.size();i++) begin
				uvm_event_callback#(T) tmp=callbacks[i];
				skip = skip + tmp.pre_trigger(this,data);
			end
		end
		if (skip==0) begin
			->m_event;
			if (callbacks.size()) begin
				for (int i=0;i<callbacks.size();i++) begin
					uvm_event_callback#(T) tmp=callbacks[i];
					tmp.post_trigger(this,data);
				end
			end
			num_waiters = 0;
			on = 1;
			trigger_time = $realtime;
			trigger_data = data;
		end
	endfunction

	virtual function T get_trigger_data ();
		return trigger_data;
	endfunction

	virtual function string get_type_name();
		return type_name;
	endfunction

	virtual function void add_callback (uvm_event_callback#(T) cb, bit append=1);
		for (int i=0;i<callbacks.size();i++) begin
			if (cb == callbacks[i]) begin
				uvm_report_warning("CBRGED","add_callback: Callback already registered. Ignoring.", UVM_NONE);
				return;
			end
		end
		if (append)
			callbacks.push_back(cb);
		else
			callbacks.push_front(cb);
	endfunction

	virtual function void delete_callback (uvm_event_callback#(T) cb);
		for (int i=0;i<callbacks.size();i++) begin
			if (cb == callbacks[i]) begin
				callbacks.delete(i);
				return;
			end
		end
		uvm_report_warning("CBNTFD", "delete_callback: Callback not found. Ignoring delete request.", UVM_NONE);
	endfunction

	virtual function void do_print (uvm_printer printer);
		super.do_print(printer);
		printer.print_object("trigger_data", trigger_data);
	endfunction
	
	virtual function void do_copy (uvm_object rhs);
		uvm_event#(T) e;
		super.do_copy(rhs);
		if(!$cast(e, rhs) || (e==null)) return;
		trigger_data = e.trigger_data;
	endfunction 

   	virtual function uvm_object create(string name=""); 
		uvm_event#(T) v;
		v=new(name);
		return v;
	endfunction

endclass


class uvm_barrier extends uvm_object;

  local  int       threshold;
  local  int       num_waiters;
  local  bit       at_threshold;
  local  bit       auto_reset;
  local  uvm_event#(uvm_object) m_event;

  function new (string name="", int threshold=0);
    super.new(name);
    m_event = new({"barrier_",name});
    this.threshold = threshold;
    num_waiters = 0;
    auto_reset = 1;
    at_threshold = 0;
  endfunction

  virtual task wait_for();

    if (at_threshold)
      return;

    num_waiters++;

    if (num_waiters >= threshold) begin
      if (!auto_reset)
        at_threshold=1;
      m_trigger();
      return;
    end

    m_event.wait_trigger();

  endtask

  virtual function void reset (bit wakeup=1);
    at_threshold = 0;
    if (num_waiters) begin
      if (wakeup)
        m_event.trigger();
      else
        m_event.reset();
    end
    num_waiters = 0;
  endfunction

  virtual function void set_auto_reset (bit value=1);
    at_threshold = 0;
    auto_reset = value;
  endfunction

  virtual function void set_threshold (int threshold);
    this.threshold = threshold;
    if (threshold <= num_waiters)
      reset(1);
  endfunction

  virtual function int get_threshold ();
    return threshold;
  endfunction

  virtual function int get_num_waiters ();
    return num_waiters;
  endfunction

  virtual function void cancel ();
    m_event.cancel();
    num_waiters = m_event.get_num_waiters();
  endfunction

  const static string type_name = "uvm_barrier";

  virtual  function uvm_object create(string name=""); 
    uvm_barrier v;
    v=new(name);
    return v;
  endfunction

  virtual  function string get_type_name();
    return type_name;
  endfunction

  local task m_trigger();
    m_event.trigger();
    num_waiters=0;
    #0; 
  endtask

  virtual function void do_print (uvm_printer printer);
    printer.print_field_int("threshold", threshold, $bits(threshold), UVM_DEC, ".", "int");
    printer.print_field_int("num_waiters", num_waiters, $bits(num_waiters), UVM_DEC, ".", "int");
    printer.print_field_int("at_threshold", at_threshold, $bits(at_threshold), UVM_BIN, ".", "bit");
    printer.print_field_int("auto_reset", auto_reset, $bits(auto_reset), UVM_BIN, ".", "bit");
  endfunction

  virtual function void do_copy (uvm_object rhs);
    uvm_barrier b;
    super.do_copy(rhs);
    if(!$cast(b, rhs) || (b==null)) return;

    threshold = b.threshold;
    num_waiters = b.num_waiters;
    at_threshold = b.at_threshold;
    auto_reset = b.auto_reset;
    m_event = b.m_event;
  endfunction  

endclass


`ifndef UVM_CALLBACK_SVH
`define UVM_CALLBACK_SVH


typedef class uvm_root;
typedef class uvm_callback;
typedef class uvm_callbacks_base;

class uvm_typeid_base;
  static string typename;
  static uvm_callbacks_base typeid_map[uvm_typeid_base];
  static uvm_typeid_base type_map[uvm_callbacks_base];
endclass

class uvm_typeid#(type T=uvm_object) extends uvm_typeid_base;
  static uvm_typeid#(T) m_b_inst;
  static function uvm_typeid#(T) get();
    if(m_b_inst == null)
      m_b_inst = new;
    return m_b_inst;
  endfunction
endclass

class uvm_callbacks_base extends uvm_object;

  typedef uvm_callbacks_base this_type;

  static bit m_tracing = 1;
  static this_type m_b_inst;

  static uvm_pool#(uvm_object,uvm_queue#(uvm_callback)) m_pool;

  static function this_type m_initialize();
    if(m_b_inst == null) begin
      m_b_inst = new;
      m_pool = new;
    end
    return m_b_inst;
  endfunction

  this_type       m_this_type[$];     
  uvm_typeid_base m_super_type;       
  uvm_typeid_base m_derived_types[$]; 

  virtual function bit m_am_i_a(uvm_object obj);
    return 0;
  endfunction

  virtual function bit m_is_for_me(uvm_callback cb);
    return 0;
  endfunction

  virtual function bit m_is_registered(uvm_object obj, uvm_callback cb);
    return 0;
  endfunction

  virtual function uvm_queue#(uvm_callback) m_get_tw_cb_q(uvm_object obj);
    return null;
  endfunction

  virtual function void m_add_tw_cbs(uvm_callback cb, uvm_apprepend ordering);
  endfunction

  virtual function bit m_delete_tw_cbs(uvm_callback cb);
    return 0;
  endfunction

  function bit check_registration(uvm_object obj, uvm_callback cb);
    this_type st, dt;

    if (m_is_registered(obj,cb))
      return 1;

    foreach(m_this_type[i])
      if(m_b_inst != m_this_type[i] && m_this_type[i].m_is_registered(obj,cb))
        return 1;

    if(obj == null) begin
      foreach(m_derived_types[i]) begin
        dt = uvm_typeid_base::typeid_map[m_derived_types[i] ];
        if(dt != null && dt.check_registration(null,cb))
          return 1;
      end
    end

    return 0;
  endfunction

endclass

class uvm_typed_callbacks#(type T=uvm_object) extends uvm_callbacks_base;

  static uvm_queue#(uvm_callback) m_tw_cb_q;
  static string m_typename;

  typedef uvm_typed_callbacks#(T) this_type;
  typedef uvm_callbacks_base      super_type;

  static this_type m_t_inst;

  static function this_type m_initialize();
    if(m_t_inst == null) begin
      void'(super_type::m_initialize());
      m_t_inst = new;
      m_t_inst.m_tw_cb_q = new("typewide_queue");
    end
    return m_t_inst;
  endfunction

  virtual function bit m_am_i_a(uvm_object obj);
    T this_type;
    if (obj == null)
      return 1;
    return($cast(this_type,obj));
  endfunction

  virtual function uvm_queue#(uvm_callback) m_get_tw_cb_q(uvm_object obj);
    if(m_am_i_a(obj)) begin
      foreach(m_derived_types[i]) begin
        super_type dt;
        dt = uvm_typeid_base::typeid_map[m_derived_types[i] ];
        if(dt != null && dt != this) begin
          m_get_tw_cb_q = dt.m_get_tw_cb_q(obj);
          if(m_get_tw_cb_q != null)
            return m_get_tw_cb_q;
        end
      end
      return m_t_inst.m_tw_cb_q;
    end
    else
      return null;
  endfunction

  static function int m_cb_find(uvm_queue#(uvm_callback) q, uvm_callback cb);
    for(int i=0; i<q.size(); ++i)
      if(q.get(i) == cb)
        return i;
    return -1;
  endfunction

  static function int m_cb_find_name(uvm_queue#(uvm_callback) q, string name, string where);
    uvm_callback cb;
    for(int i=0; i<q.size(); ++i) begin
      cb = q.get(i);
      if(cb.get_name() == name) begin
         `uvm_warning("UVM/CB/NAM/SAM", {"A callback named \"", name, "\" is already registered with ", where})
         return 1;
      end
    end
    return 0;
  endfunction

  virtual function void m_add_tw_cbs(uvm_callback cb, uvm_apprepend ordering);
    super_type cb_pair;
    uvm_object obj;
    T me;
    bit warned;
    uvm_queue#(uvm_callback) q;
    if(m_cb_find(m_t_inst.m_tw_cb_q,cb) == -1) begin
       warned = m_cb_find_name(m_t_inst.m_tw_cb_q, cb.get_name(), "type");
       if(ordering == UVM_APPEND)
          m_t_inst.m_tw_cb_q.push_back(cb);
       else
          m_t_inst.m_tw_cb_q.push_front(cb);
    end
    if(m_t_inst.m_pool.first(obj)) begin
      do begin
        if($cast(me,obj)) begin
          q = m_t_inst.m_pool.get(obj);
          if(q==null) begin
            q=new;
            m_t_inst.m_pool.add(obj,q);
          end
          if(m_cb_find(q,cb) == -1) begin
            if (!warned) begin
               void'(m_cb_find_name(q, cb.get_name(), {"object instance ", me.get_full_name()}));
            end
            if(ordering == UVM_APPEND)
              q.push_back(cb);
            else
              q.push_front(cb);
          end
        end
      end while(m_t_inst.m_pool.next(obj));
    end
    foreach(m_derived_types[i]) begin
      cb_pair = uvm_typeid_base::typeid_map[m_derived_types[i] ];
      if(cb_pair != this)
        cb_pair.m_add_tw_cbs(cb,ordering);
    end
  endfunction

  virtual function bit m_delete_tw_cbs(uvm_callback cb);
    super_type cb_pair;
    uvm_object obj;
    uvm_queue#(uvm_callback) q;
    int pos = m_cb_find(m_t_inst.m_tw_cb_q,cb);

    if(pos != -1) begin
      m_t_inst.m_tw_cb_q.delete(pos);
      m_delete_tw_cbs = 1;
    end

    if(m_t_inst.m_pool.first(obj)) begin
      do begin
        q = m_t_inst.m_pool.get(obj);
        if(q==null) begin
          q=new;
          m_t_inst.m_pool.add(obj,q);
        end
        pos = m_cb_find(q,cb);
        if(pos != -1) begin
          q.delete(pos);
          m_delete_tw_cbs = 1;
        end
      end while(m_t_inst.m_pool.next(obj));
    end
    foreach(m_derived_types[i]) begin
      cb_pair = uvm_typeid_base::typeid_map[m_derived_types[i] ];
      if(cb_pair != this)
        m_delete_tw_cbs |= cb_pair.m_delete_tw_cbs(cb);
    end
  endfunction

  static function void display(T obj=null);
    T me;
    super_type ib = m_t_inst;
    string cbq[$];
    string inst_q[$];
    string mode_q[$];
    uvm_callback cb;
    string blanks = "                             ";
    uvm_object bobj = obj;
    string qs[$];

    uvm_queue#(uvm_callback) q;
    string tname, str;

    int max_cb_name=0, max_inst_name=0;

    m_tracing = 0; 

    if(m_typename != "") tname = m_typename;
    else if(obj != null) tname = obj.get_type_name();
    else tname = "*";

    q = m_t_inst.m_tw_cb_q;
    for(int i=0; i<q.size(); ++i) begin
      cb = q.get(i);
      cbq.push_back(cb.get_name());
      inst_q.push_back("(*)");
      if(cb.is_enabled()) mode_q.push_back("ON");
      else mode_q.push_back("OFF");

      str = cb.get_name();
      max_cb_name = max_cb_name > str.len() ? max_cb_name : str.len();
      str = "(*)";
      max_inst_name = max_inst_name > str.len() ? max_inst_name : str.len();
    end

    if(obj ==null) begin
      if(m_t_inst.m_pool.first(bobj)) begin
        do
          if($cast(me,bobj)) break;
        while(m_t_inst.m_pool.next(bobj));
      end
      if(me != null || m_t_inst.m_tw_cb_q.size()) begin
        qs.push_back($sformatf("Registered callbacks for all instances of %s\n", tname)); 
        qs.push_back("---------------------------------------------------------------\n");
      end
      if(me != null) begin
        do begin
          if($cast(me,bobj)) begin
            q = m_t_inst.m_pool.get(bobj);
            if (q==null) begin
              q=new;
              m_t_inst.m_pool.add(bobj,q);
            end
            for(int i=0; i<q.size(); ++i) begin
              cb = q.get(i);
              cbq.push_back(cb.get_name());
              inst_q.push_back(bobj.get_full_name());
              if(cb.is_enabled()) mode_q.push_back("ON");
              else mode_q.push_back("OFF");
  
              str = cb.get_name();
              max_cb_name = max_cb_name > str.len() ? max_cb_name : str.len();
              str = bobj.get_full_name();
              max_inst_name = max_inst_name > str.len() ? max_inst_name : str.len();
            end
          end
        end while (m_t_inst.m_pool.next(bobj));
      end
      else begin
        qs.push_back($sformatf("No callbacks registered for any instances of type %s\n", tname));
      end
    end
    else begin
      if(m_t_inst.m_pool.exists(bobj) || m_t_inst.m_tw_cb_q.size()) begin
       qs.push_back($sformatf("Registered callbacks for instance %s of %s\n", obj.get_full_name(), tname)); 
       qs.push_back("---------------------------------------------------------------\n");
      end
      if(m_t_inst.m_pool.exists(bobj)) begin
        q = m_t_inst.m_pool.get(bobj);
        if(q==null) begin
          q=new;
          m_t_inst.m_pool.add(bobj,q);
        end
        for(int i=0; i<q.size(); ++i) begin
          cb = q.get(i);
          cbq.push_back(cb.get_name());
          inst_q.push_back(bobj.get_full_name());
          if(cb.is_enabled()) mode_q.push_back("ON");
          else mode_q.push_back("OFF");

          str = cb.get_name();
          max_cb_name = max_cb_name > str.len() ? max_cb_name : str.len();
          str = bobj.get_full_name();
          max_inst_name = max_inst_name > str.len() ? max_inst_name : str.len();
        end
      end
    end
    if(!cbq.size()) begin
      if(obj == null) str = "*";
      else str = obj.get_full_name();
      qs.push_back($sformatf("No callbacks registered for instance %s of type %s\n", str, tname));
    end

    foreach (cbq[i]) begin
      qs.push_back($sformatf("%s  %s %s on %s  %s\n", cbq[i], blanks.substr(0,max_cb_name-cbq[i].len()-1), inst_q[i], blanks.substr(0,max_inst_name - inst_q[i].len()-1), mode_q[i]));
    end
    `uvm_info("UVM/CB/DISPLAY",`UVM_STRING_QUEUE_STREAMING_PACK(qs),UVM_NONE)

    m_tracing = 1; 
  endfunction

endclass


class uvm_callbacks #(type T=uvm_object, type CB=uvm_callback) extends uvm_typed_callbacks#(T);
  
  typedef uvm_typed_callbacks#(T) super_type;
  typedef uvm_callbacks#(T,CB) this_type;
  local static this_type m_inst;
  static uvm_typeid_base m_typeid;
  static uvm_typeid_base m_cb_typeid;
  static string m_typename;
  static string m_cb_typename;
  static uvm_report_object reporter = new("cb_tracer");
  static uvm_callbacks#(T,uvm_callback) m_base_inst;
  bit m_registered;

  static function this_type get();

    if (m_inst == null) begin
      uvm_typeid_base cb_base_type;

      void'(super_type::m_initialize());
    
      cb_base_type = uvm_typeid#(uvm_callback)::get();
      m_cb_typeid  = uvm_typeid#(CB)::get();
      m_typeid     = uvm_typeid#(T)::get();

      m_inst = new;

      if (cb_base_type == m_cb_typeid) begin
        $cast(m_base_inst, m_inst);
        m_t_inst = m_base_inst;
        uvm_typeid_base::typeid_map[m_typeid] = m_inst; 
        uvm_typeid_base::type_map[m_b_inst] = m_typeid;
      end
      else begin
        m_base_inst = uvm_callbacks#(T,uvm_callback)::get();
        m_base_inst.m_this_type.push_back(m_inst);
      end

      if (m_inst == null)
        `uvm_fatal("CB/INTERNAL","get(): m_inst is null")
    end

    return m_inst;
  endfunction

  static function bit m_register_pair(string tname="", cbname="");
    this_type inst = get();

    m_typename = tname;
    super_type::m_typename = tname;
    m_typeid.typename = tname;

    m_cb_typename = cbname;
    m_cb_typeid.typename = cbname;

    inst.m_registered = 1; 

    return 1;
  endfunction

  virtual function bit m_is_registered(uvm_object obj, uvm_callback cb);
    if(m_is_for_me(cb) && m_am_i_a(obj)) begin
      return m_registered;
    end
  endfunction

  virtual function bit m_is_for_me(uvm_callback cb);
    CB this_cb;
    return($cast(this_cb,cb));
  endfunction

  static function void add(T obj, uvm_callback cb, uvm_apprepend ordering=UVM_APPEND);
    uvm_queue#(uvm_callback) q;
    string nm,tnm; 

    void'(get());

    if (cb==null) begin
       if (obj==null)
         nm = "(*)";
       else
         nm = obj.get_full_name();

       if (m_base_inst.m_typename!="")
         tnm = m_base_inst.m_typename;
       else if (obj != null)
         tnm = obj.get_type_name();
       else
         tnm = "uvm_object";

       uvm_report_error("CBUNREG", {"Null callback object cannot be registered with object ", nm, " (", tnm, ")"}, UVM_NONE);
       return;
    end

    if (!m_base_inst.check_registration(obj,cb)) begin

       if (obj==null)
         nm = "(*)";
       else
         nm = obj.get_full_name();

       if (m_base_inst.m_typename!="")
         tnm = m_base_inst.m_typename;
       else if(obj != null)
         tnm = obj.get_type_name();
       else
         tnm = "uvm_object";

       uvm_report_warning("CBUNREG", {"Callback ", cb.get_name(), " cannot be registered with object ", nm, " because callback type ", cb.get_type_name(), " is not registered with object type ", tnm }, UVM_NONE);
    end

    if(obj == null) begin

      if (m_cb_find(m_t_inst.m_tw_cb_q,cb) != -1) begin

        if (m_base_inst.m_typename!="")
          tnm = m_base_inst.m_typename;
        else tnm = "uvm_object";

        uvm_report_warning("CBPREG", {"Callback object ", cb.get_name(), " is already registered with type ", tnm }, UVM_NONE);
      end
      else begin
        `uvm_cb_trace_noobj(cb,$sformatf("Add (%s) typewide callback %0s for type %s", ordering.name(), cb.get_name(), m_base_inst.m_typename)) m_t_inst.m_add_tw_cbs(cb,ordering);
      end
    end

    else begin

      `uvm_cb_trace_noobj(cb,$sformatf("Add (%s) callback %0s to object %0s ", ordering.name(), cb.get_name(), obj.get_full_name()))

      q = m_base_inst.m_pool.get(obj);

      if (q==null) begin
        q=new;
        m_base_inst.m_pool.add(obj,q);
      end

      if(q.size() == 0) begin
        uvm_report_object o; 

        if($cast(o,obj)) begin
          uvm_queue#(uvm_callback) qr;
	  void'(uvm_callbacks#(uvm_report_object, uvm_callback)::get());
          qr = uvm_callbacks#(uvm_report_object,uvm_callback)::m_t_inst.m_tw_cb_q;
          for(int i=0; i<qr.size(); ++i)
              q.push_back(qr.get(i)); 
        end

        for(int i=0; i<m_t_inst.m_tw_cb_q.size(); ++i)
          q.push_back(m_t_inst.m_tw_cb_q.get(i)); 
      end

      if(m_cb_find(q,cb) != -1) begin
        uvm_report_warning("CBPREG", { "Callback object ", cb.get_name(), " is already registered", " with object ", obj.get_full_name() }, UVM_NONE);
      end
      else begin
        void'(m_cb_find_name(q, cb.get_name(), {"object instance ", obj.get_full_name()}));
        if(ordering == UVM_APPEND)
          q.push_back(cb);
        else
          q.push_front(cb);
      end
    end
  endfunction


  static function void add_by_name(string name, uvm_callback cb, uvm_component root, uvm_apprepend ordering=UVM_APPEND);
    uvm_component cq[$];
    uvm_root top;
    uvm_coreservice_t cs;
    T t;
    void'(get());
    cs = uvm_coreservice_t::get();
    top = cs.get_root();

    if(cb==null) begin
       uvm_report_error("CBUNREG", { "Null callback object cannot be registered with object(s) ", name }, UVM_NONE);
       return;
    end
    `uvm_cb_trace_noobj(cb,$sformatf("Add (%s) callback %0s by name to object(s) %0s ", ordering.name(), cb.get_name(), name))
    top.find_all(name,cq,root);
    if(cq.size() == 0) begin
      uvm_report_warning("CBNOMTC", { "add_by_name failed to find any components matching the name ", name, ", callback ", cb.get_name(), " will not be registered." }, UVM_NONE);
    end
    foreach(cq[i]) begin
      if($cast(t,cq[i])) begin 
        add(t,cb,ordering); 
      end
    end
  endfunction


  static function void delete(T obj, uvm_callback cb);
    uvm_object b_obj = obj;
    uvm_queue#(uvm_callback) q;
    bit found;
    int pos;
    void'(get());

    if(obj == null) begin
      `uvm_cb_trace_noobj(cb,$sformatf("Delete typewide callback %0s for type %s", cb.get_name(), m_base_inst.m_typename))
      found = m_t_inst.m_delete_tw_cbs(cb);
    end
    else begin
      `uvm_cb_trace_noobj(cb,$sformatf("Delete callback %0s from object %0s ", cb.get_name(), obj.get_full_name()))
      q = m_base_inst.m_pool.get(b_obj);
      pos = m_cb_find(q,cb);
      if(pos != -1) begin
        q.delete(pos);
        found = 1;
      end
    end
    if(!found) begin
      string nm;
      if(obj==null) nm = "(*)"; else nm = obj.get_full_name();
      uvm_report_warning("CBUNREG", { "Callback ", cb.get_name(), " cannot be removed from object ", nm, " because it is not currently registered to that object." }, UVM_NONE);
    end
  endfunction


  static function void delete_by_name(string name, uvm_callback cb,
    uvm_component root);
    uvm_component cq[$];
    uvm_root top;
    T t;
    uvm_coreservice_t cs;
    void'(get());
    cs = uvm_coreservice_t::get();
    top = cs.get_root();

    `uvm_cb_trace_noobj(cb,$sformatf("Delete callback %0s by name from object(s) %0s ", cb.get_name(), name))
    top.find_all(name,cq,root);
    if(cq.size() == 0) begin
      uvm_report_warning("CBNOMTC", { "delete_by_name failed to find any components matching the name ", name, ", callback ", cb.get_name(), " will not be unregistered." }, UVM_NONE);
    end
    foreach(cq[i]) begin
      if($cast(t,cq[i])) begin 
        delete(t,cb); 
      end
    end
  endfunction

  static function void m_get_q (ref uvm_queue #(uvm_callback) q, input T obj);
    if(!m_base_inst.m_pool.exists(obj)) begin 
      q = (obj == null) ? m_t_inst.m_tw_cb_q : m_t_inst.m_get_tw_cb_q(obj);
    end 
    else begin
      q = m_base_inst.m_pool.get(obj);
      if(q==null) begin
        q=new;
        m_base_inst.m_pool.add(obj,q);
      end
    end
  endfunction

  static function CB get_first (ref int itr, input T obj);
    uvm_queue#(uvm_callback) q;
    CB cb;
    void'(get());
    m_get_q(q,obj);
    for(itr = 0; itr<q.size(); ++itr)
      if($cast(cb, q.get(itr)) && cb.callback_mode())
         return cb;
    return null;
  endfunction

  static function CB get_last (ref int itr, input T obj);
    uvm_queue#(uvm_callback) q;
    CB cb;
    void'(get());
    m_get_q(q,obj);
    for(itr = q.size()-1; itr>=0; --itr)
      if ($cast(cb, q.get(itr)) && cb.callback_mode())
         return cb;
    return null;
  endfunction

  static function CB get_next (ref int itr, input T obj);
    uvm_queue#(uvm_callback) q;
    CB cb;
    void'(get());
    m_get_q(q,obj);
    for(itr = itr+1; itr<q.size(); ++itr)
      if ($cast(cb, q.get(itr)) && cb.callback_mode())
         return cb;
    return null;
  endfunction

  static function CB get_prev (ref int itr, input T obj);
    uvm_queue#(uvm_callback) q;
    CB cb;
    void'(get());
    m_get_q(q,obj);
    for(itr = itr-1; itr>= 0; --itr)
      if($cast(cb, q.get(itr)) && cb.callback_mode())
         return cb;
    return null;
  endfunction

  static function void display(T obj=null);
    void'(get());
    super_type::display(obj);
  endfunction

endclass


class uvm_derived_callbacks#(type T=uvm_object, type ST=uvm_object, type CB=uvm_callback)
    extends uvm_callbacks#(T,CB);

  typedef uvm_derived_callbacks#(T,ST,CB) this_type;
  typedef uvm_callbacks#(T)            this_user_type;
  typedef uvm_callbacks#(ST)           this_super_type;
  static this_type m_d_inst;
  static this_user_type m_user_inst;
  static this_super_type m_super_inst;
  static uvm_typeid_base m_s_typeid;

  static function this_type get();
    m_user_inst = this_user_type::get();
    m_super_inst = this_super_type::get();
    m_s_typeid = uvm_typeid#(ST)::get();
    if(m_d_inst == null) begin
      m_d_inst = new;
    end
    return m_d_inst;
  endfunction

  static function bit register_super_type(string tname="", sname="");
    this_user_type u_inst = this_user_type::get();
    this_type      inst = this_type::get();
    uvm_callbacks_base s_obj;

    this_user_type::m_t_inst.m_typename = tname;

    if(sname != "") m_s_typeid.typename = sname;

    if(u_inst.m_super_type != null) begin
      if(u_inst.m_super_type == m_s_typeid) return 1;
      uvm_report_warning("CBTPREG", { "Type ", tname, " is already registered to super type ", this_super_type::m_t_inst.m_typename, ". Ignoring attempt to register to super type ", sname}, UVM_NONE); 
      return 1;
    end
    if(this_super_type::m_t_inst.m_typename == "")
      this_super_type::m_t_inst.m_typename = sname;
    u_inst.m_super_type = m_s_typeid;
    u_inst.m_base_inst.m_super_type = m_s_typeid;
    s_obj = uvm_typeid_base::typeid_map[m_s_typeid];
    s_obj.m_derived_types.push_back(m_typeid);
    return 1;
  endfunction

endclass

class uvm_callback_iter#(type T = uvm_object, type CB = uvm_callback);

   local int m_i;
   local T   m_obj;
   local CB  m_cb;


   function new(T obj);
      m_obj = obj;
   endfunction


   function CB first();
      m_cb = uvm_callbacks#(T,CB)::get_first(m_i, m_obj);
      return m_cb;
   endfunction


   function CB last();
      m_cb = uvm_callbacks#(T,CB)::get_last(m_i, m_obj);
      return m_cb;
   endfunction


   function CB next();
      m_cb = uvm_callbacks#(T,CB)::get_next(m_i, m_obj);
      return m_cb;
   endfunction


   function CB prev();
      m_cb = uvm_callbacks#(T,CB)::get_prev(m_i, m_obj);
      return m_cb;
   endfunction


   function CB get_cb();
      return m_cb;
   endfunction


endclass


class uvm_callback extends uvm_object;

  static uvm_report_object reporter = new("cb_tracer");
  protected bit m_enabled = 1;


  function new(string name="uvm_callback");
    super.new(name);
  endfunction



  function bit callback_mode(int on=-1);
    if(on == 0 || on == 1) begin
      `uvm_cb_trace_noobj(this,$sformatf("Setting callback mode for %s to %s", get_name(), ((on==1) ? "ENABLED":"DISABLED")))
    end
    else begin
      `uvm_cb_trace_noobj(this,$sformatf("Callback mode for %s is %s", get_name(), ((m_enabled==1) ? "ENABLED":"DISABLED")))
    end
    callback_mode = m_enabled;
    if(on==0) m_enabled=0;
    if(on==1) m_enabled=1;
  endfunction



  function bit is_enabled();
    return callback_mode();
  endfunction

  static string type_name = "uvm_callback";



  virtual function string get_type_name();
     return type_name;
  endfunction

endclass


`endif 


`ifndef UVM_REPORT_MESSAGE_SVH
`define UVM_REPORT_MESSAGE_SVH


typedef class uvm_report_server;
typedef class uvm_report_handler;
typedef class uvm_root;

virtual class uvm_report_message_element_base;
   protected uvm_action _action;
   protected string          _name;



   virtual function string get_name();
     return _name;
   endfunction


   virtual function void set_name(string name);
     _name = name;
   endfunction
     


   virtual function uvm_action get_action();
     return _action;
   endfunction


   virtual function void set_action(uvm_action action);
     _action = action;
   endfunction
     
     
   function void print(uvm_printer printer);
      if (_action & (UVM_LOG | UVM_DISPLAY))
        do_print(printer);
   endfunction : print
   function void record(uvm_recorder recorder);
      if (_action & UVM_RM_RECORD)
        do_record(recorder);
   endfunction : record
   function void copy(uvm_report_message_element_base rhs);
      do_copy(rhs);
   endfunction : copy
   function uvm_report_message_element_base clone();
      return do_clone();
   endfunction : clone

   pure virtual function void do_print(uvm_printer printer);
   pure virtual function void do_record(uvm_recorder recorder);
   pure virtual function void do_copy(uvm_report_message_element_base rhs);
   pure virtual function uvm_report_message_element_base do_clone();
   
endclass : uvm_report_message_element_base



class uvm_report_message_int_element extends uvm_report_message_element_base;
   typedef uvm_report_message_int_element this_type;
   
   protected uvm_bitstream_t _val;
   protected int             _size;
   protected uvm_radix_enum  _radix;


   virtual function uvm_bitstream_t get_value(output int size, output uvm_radix_enum radix);
     size = _size;
     radix = _radix;
     return _val;
   endfunction


   virtual function void set_value(uvm_bitstream_t value, int size, uvm_radix_enum radix);
     _size = size;
     _radix = radix;
     _val = value;
   endfunction


   virtual function void do_print(uvm_printer printer);
      printer.print_int(_name, _val, _size, _radix);
   endfunction : do_print

   virtual function void do_record(uvm_recorder recorder);
      recorder.record_field(_name, _val, _size, _radix);
   endfunction : do_record

   virtual function void do_copy(uvm_report_message_element_base rhs);
      this_type _rhs;
      $cast(_rhs, rhs);
      _name = _rhs._name;
      _val = _rhs._val;
      _size = _rhs._size;
      _radix = _rhs._radix;
      _action = rhs._action;
   endfunction : do_copy

   virtual function uvm_report_message_element_base do_clone(); 
     this_type tmp = new; 
     tmp.copy(this); 
     return tmp; 
   endfunction : do_clone
endclass : uvm_report_message_int_element



class uvm_report_message_string_element extends uvm_report_message_element_base;
   typedef uvm_report_message_string_element this_type;
   protected string  _val;

   virtual function string get_value();
     return _val;
   endfunction


   virtual function void set_value(string value);
     _val = value;
   endfunction


   virtual function void do_print(uvm_printer printer);
      printer.print_string(_name, _val);
   endfunction : do_print

   virtual function void do_record(uvm_recorder recorder);
      recorder.record_string(_name, _val);
   endfunction : do_record

   virtual function void do_copy(uvm_report_message_element_base rhs);
      this_type _rhs;
      $cast(_rhs, rhs);
      _name = _rhs._name;
      _val = _rhs._val;
      _action = rhs._action;
   endfunction : do_copy
   
   virtual function uvm_report_message_element_base do_clone(); 
     this_type tmp = new; 
     tmp.copy(this); 
     return tmp; 
   endfunction : do_clone
endclass : uvm_report_message_string_element



class uvm_report_message_object_element extends uvm_report_message_element_base;
   typedef uvm_report_message_object_element this_type;
   protected uvm_object _val;



   virtual function uvm_object get_value();
     return _val;
   endfunction


   virtual function void set_value(uvm_object value);
     _val = value;
   endfunction


   virtual function void do_print(uvm_printer printer);
      printer.print_object(_name, _val);
   endfunction : do_print

   virtual function void do_record(uvm_recorder recorder);
      recorder.record_object(_name, _val);
   endfunction : do_record

   virtual function void do_copy(uvm_report_message_element_base rhs);
      this_type _rhs;
      $cast(_rhs, rhs);
      _name = _rhs._name;
      _val = _rhs._val;
      _action = rhs._action;
   endfunction : do_copy
   
   virtual function uvm_report_message_element_base do_clone(); 
     this_type tmp = new; 
     tmp.copy(this); 
     return tmp; 
   endfunction : do_clone
endclass : uvm_report_message_object_element


class uvm_report_message_element_container extends uvm_object;

  protected uvm_report_message_element_base elements[$];

  `uvm_object_utils(uvm_report_message_element_container)


  function new(string name = "element_container");
    super.new(name);
  endfunction



  virtual function int size();
    return elements.size();
  endfunction



  virtual function void delete(int index);
    elements.delete(index);
  endfunction



  virtual function void delete_elements();
    elements.delete();
  endfunction



  typedef uvm_report_message_element_base queue_of_element[$];
  virtual function queue_of_element get_elements();
    return elements;
  endfunction



  virtual function void add_int(string name, uvm_bitstream_t value, int size, uvm_radix_enum radix, uvm_action action = (UVM_LOG|UVM_RM_RECORD));
     process p;
     string rand_state;
     uvm_report_message_int_element urme;

     p = process::self();
     if (p != null)
       rand_state = p.get_randstate();
     urme = new();
     if (p != null)
       p.set_randstate(rand_state);

     urme.set_name(name);
     urme.set_value(value, size, radix);
     urme.set_action(action);
     elements.push_back(urme);
  endfunction



  virtual function void add_string(string name, string value, uvm_action action = (UVM_LOG|UVM_RM_RECORD));
     process p;
     string rand_state;
     uvm_report_message_string_element urme;

     p = process::self();
     if (p != null)
       rand_state = p.get_randstate();
     urme = new();
     if (p != null)
       p.set_randstate(rand_state);

     urme.set_name(name);
     urme.set_value(value);
     urme.set_action(action);
     elements.push_back(urme);
  endfunction



  virtual function void add_object(string name, uvm_object obj, uvm_action action = (UVM_LOG|UVM_RM_RECORD));
     process p;
     string rand_state;
     uvm_report_message_object_element urme;

     p = process::self();
     if (p != null)
       rand_state = p.get_randstate();
     urme = new();
     if (p != null)
       p.set_randstate(rand_state);

     urme.set_name(name);
     urme.set_value(obj);
     urme.set_action(action);
     elements.push_back(urme);
  endfunction

  virtual function void do_print(uvm_printer printer);
    super.do_print(printer);
    for(int i = 0; i < elements.size(); i++) begin
       elements[i].print(printer);
    end 
  endfunction

  virtual function void do_record(uvm_recorder recorder);
    super.do_record(recorder);
    for(int i = 0; i < elements.size(); i++) begin
       elements[i].record(recorder);
    end
  endfunction

  virtual function void do_copy(uvm_object rhs);
    uvm_report_message_element_container urme_container;

    super.do_copy(rhs);

    if(!$cast(urme_container, rhs) || (rhs==null))
      return;

    delete_elements();
    foreach (urme_container.elements[i])
      elements.push_back(urme_container.elements[i].clone());

  endfunction

endclass




class uvm_report_message extends uvm_object;

  protected uvm_report_object _report_object;
  protected uvm_report_handler _report_handler;
  protected uvm_report_server _report_server;

  protected uvm_severity _severity; 
  protected string _id;
  protected string _message;
  protected int _verbosity;
  protected string _filename;
  protected int _line;
  protected string _context_name;
  protected uvm_action _action; 
  protected UVM_FILE _file;

  protected uvm_report_message_element_container _report_message_element_container;



  function new(string name = "uvm_report_message");
    super.new(name);
    _report_message_element_container = new();
  endfunction



  static function uvm_report_message new_report_message(string name = "uvm_report_message");
    process p;
    string rand_state;

    p = process::self();

    if (p != null)
      rand_state = p.get_randstate();
    new_report_message = new(name);
    if (p != null)
      p.set_randstate(rand_state);

  endfunction




  virtual function void do_print(uvm_printer printer);
    uvm_verbosity l_verbosity;

    super.do_print(printer);

    printer.print_generic("severity", "uvm_severity", $bits(_severity), _severity.name());
    printer.print_string("id", _id);
    printer.print_string("message",_message);
    if ($cast(l_verbosity, _verbosity))
      printer.print_generic("verbosity", "uvm_verbosity", $bits(l_verbosity), l_verbosity.name());
    else
      printer.print_int("verbosity", _verbosity, $bits(_verbosity), UVM_HEX);
    printer.print_string("filename", _filename);
    printer.print_int("line", _line, $bits(_line), UVM_UNSIGNED);
    printer.print_string("context_name", _context_name);

    if (_report_message_element_container.size() != 0)
      _report_message_element_container.print(printer);
  endfunction


  `uvm_object_utils(uvm_report_message)





  virtual function void do_copy (uvm_object rhs);
    uvm_report_message report_message;

    super.do_copy(rhs);

    if(!$cast(report_message, rhs) || (rhs==null))
      return;

    _report_object = report_message.get_report_object();
    _report_handler = report_message.get_report_handler();
    _report_server = report_message.get_report_server();
    _context_name = report_message.get_context();
    _file = report_message.get_file();
    _filename = report_message.get_filename();
    _line = report_message.get_line();
    _action = report_message.get_action();
    _severity = report_message.get_severity();
    _id = report_message.get_id();
    _message = report_message.get_message();
    _verbosity = report_message.get_verbosity();

    _report_message_element_container.copy(report_message._report_message_element_container);
  endfunction





  virtual function uvm_report_object get_report_object();
    return _report_object;
  endfunction


  virtual function void set_report_object(uvm_report_object ro);
    _report_object = ro;
  endfunction



  virtual function uvm_report_handler get_report_handler();
    return _report_handler;
  endfunction


  virtual function void set_report_handler(uvm_report_handler rh);
    _report_handler = rh;
  endfunction

  

  virtual function uvm_report_server get_report_server();
    return _report_server;
  endfunction


  virtual function void set_report_server(uvm_report_server rs);
    _report_server = rs;
  endfunction





  virtual function uvm_severity get_severity();
    return _severity;
  endfunction


  virtual function void set_severity(uvm_severity sev);
    _severity = sev;
  endfunction



  virtual function string get_id();
    return _id;
  endfunction


  virtual function void set_id(string id);
    _id = id;
  endfunction



  virtual function string get_message();
    return _message;
  endfunction


  virtual function void set_message(string msg);
    _message = msg;
  endfunction



  virtual function int get_verbosity();
    return _verbosity;
  endfunction


  virtual function void set_verbosity(int ver);
    _verbosity = ver;
  endfunction



  virtual function string get_filename();
    return _filename;
  endfunction


  virtual function void set_filename(string fname);
    _filename = fname;
  endfunction



  virtual function int get_line();
    return _line;
  endfunction


  virtual function void set_line(int ln);
    _line = ln;
  endfunction



  virtual function string get_context();
    return _context_name;
  endfunction


  virtual function void set_context(string cn);
    _context_name = cn;
  endfunction
 


  virtual function uvm_action get_action();
    return _action;
  endfunction


  virtual function void set_action(uvm_action act);
    _action = act;
  endfunction



  virtual function UVM_FILE get_file();
    return _file;
  endfunction


  virtual function void set_file(UVM_FILE fl);
    _file = fl;
  endfunction



  virtual function uvm_report_message_element_container get_element_container();
    return _report_message_element_container;
  endfunction



  virtual function void set_report_message(uvm_severity severity, string id, string message, int verbosity, string filename, int line, string context_name);
    this._context_name = context_name;
    this._filename = filename;
    this._line = line;
    this._severity = severity;
    this._id = id;
    this._message = message;
    this._verbosity = verbosity;
  endfunction



  virtual function void m_record_message(uvm_recorder recorder);
    recorder.record_string("message", _message);
  endfunction


  virtual function void m_record_core_properties(uvm_recorder recorder);

    string l_string;
    uvm_verbosity l_verbosity;

    if (_context_name != "")
      recorder.record_string("context_name", _context_name);
    recorder.record_string("filename", _filename);
    recorder.record_field("line", _line, $bits(_line), UVM_UNSIGNED);
    recorder.record_string("severity", _severity.name());
    if ($cast(l_verbosity, _verbosity))
      recorder.record_string("verbosity", l_verbosity.name());
    else begin
      l_string.itoa(_verbosity);
      recorder.record_string("verbosity", l_string);
    end

    recorder.record_string("id", _id);
    m_record_message(recorder);
  endfunction

  virtual function void do_record(uvm_recorder recorder);

    super.do_record(recorder);

    m_record_core_properties(recorder);
    _report_message_element_container.record(recorder);

  endfunction





  virtual function void add_int(string name, uvm_bitstream_t value, int size, uvm_radix_enum radix, uvm_action action = (UVM_LOG|UVM_RM_RECORD));
    _report_message_element_container.add_int(name, value, size, radix, action);
  endfunction



  virtual function void add_string(string name, string value, uvm_action action = (UVM_LOG|UVM_RM_RECORD));
    _report_message_element_container.add_string(name, value, action);
  endfunction



  virtual function void add_object(string name, uvm_object obj, uvm_action action = (UVM_LOG|UVM_RM_RECORD));
    _report_message_element_container.add_object(name, obj, action);
  endfunction

endclass


`endif


`ifndef UVM_REPORT_CATCHER_SVH
`define UVM_REPORT_CATCHER_SVH

typedef class uvm_report_object;
typedef class uvm_report_handler;
typedef class uvm_report_server;
typedef class uvm_report_catcher;

typedef uvm_callbacks    #(uvm_report_object, uvm_report_catcher) uvm_report_cb;
typedef uvm_callback_iter#(uvm_report_object, uvm_report_catcher) uvm_report_cb_iter;

class sev_id_struct;
  bit sev_specified ;
  bit id_specified ;
  uvm_severity sev ;
  string  id ;
  bit is_on ;
endclass


virtual class uvm_report_catcher extends uvm_callback;

  `uvm_register_cb(uvm_report_object,uvm_report_catcher)

  typedef enum { UNKNOWN_ACTION, THROW, CAUGHT} action_e;

  local static uvm_report_message m_modified_report_message;
  local static uvm_report_message m_orig_report_message;

  local static bit m_set_action_called;

  local static int m_demoted_fatal;
  local static int m_demoted_error;
  local static int m_demoted_warning;
  local static int m_caught_fatal;
  local static int m_caught_error;
  local static int m_caught_warning;

  const static int DO_NOT_CATCH      = 1; 
  const static int DO_NOT_MODIFY     = 2; 
  local static int m_debug_flags;

  local static  bit do_report;

  

  function new(string name = "uvm_report_catcher");
    super.new(name);
    do_report = 1;
  endfunction    



  function uvm_report_object get_client();
    return m_modified_report_message.get_report_object(); 
  endfunction


  function uvm_severity get_severity();
    return this.m_modified_report_message.get_severity();
  endfunction
  

  function string get_context();
    string context_str;
    
    context_str = this.m_modified_report_message.get_context();
    if (context_str == "") begin
      uvm_report_handler rh = this.m_modified_report_message.get_report_handler();
      context_str = rh.get_full_name();
    end

    return context_str;
  endfunction
  
  
  function int get_verbosity();
    return this.m_modified_report_message.get_verbosity();
  endfunction
  
  
  function string get_id();
    return this.m_modified_report_message.get_id();
  endfunction
  
  
  function string get_message();
     return this.m_modified_report_message.get_message();
  endfunction
  
  
  function uvm_action get_action();
    return this.m_modified_report_message.get_action();
  endfunction
  
  
  function string get_fname();
    return this.m_modified_report_message.get_filename();
  endfunction             


  function int get_line();
    return this.m_modified_report_message.get_line();
  endfunction


  function uvm_report_message_element_container get_element_container();
    return this.m_modified_report_message.get_element_container();
  endfunction

  

  
  protected function void set_severity(uvm_severity severity);
    this.m_modified_report_message.set_severity(severity);
  endfunction
  

  protected function void set_verbosity(int verbosity);
    this.m_modified_report_message.set_verbosity(verbosity);
  endfunction      


  protected function void set_id(string id);
    this.m_modified_report_message.set_id(id);
  endfunction
  

  protected function void set_message(string message);
    this.m_modified_report_message.set_message(message);
  endfunction
  
  
  protected function void set_action(uvm_action action);
    this.m_modified_report_message.set_action(action);
    this.m_set_action_called = 1;
  endfunction


  protected function void set_context(string context_str);
    this.m_modified_report_message.set_context(context_str);
  endfunction


  protected function void add_int(string name, uvm_bitstream_t value, int size, uvm_radix_enum radix, uvm_action action = (UVM_LOG|UVM_RM_RECORD));
    this.m_modified_report_message.add_int(name, value, size, radix, action);
  endfunction



  protected function void add_string(string name, string value, uvm_action action = (UVM_LOG|UVM_RM_RECORD));
    this.m_modified_report_message.add_string(name, value, action);
  endfunction



  protected function void add_object(string name, uvm_object obj, uvm_action action = (UVM_LOG|UVM_RM_RECORD));
    this.m_modified_report_message.add_object(name, obj, action);
  endfunction

  
     
  
  static function uvm_report_catcher get_report_catcher(string name);
    static uvm_report_cb_iter iter = new(null);
    get_report_catcher = iter.first();
    while(get_report_catcher != null) begin
      if(get_report_catcher.get_name() == name)
        return get_report_catcher;
      get_report_catcher = iter.next();
    end
    return null;
  endfunction



  static function void print_catcher(UVM_FILE file = 0);
	  string msg;
	  string enabled;
	  uvm_report_catcher catcher;
	  static uvm_report_cb_iter iter = new(null);
	  string q[$];

	  q.push_back("-------------UVM REPORT CATCHERS----------------------------\n");

	  catcher = iter.first();
	  while(catcher != null) begin
		  if(catcher.callback_mode())
			  enabled = "ON";        
		  else
			  enabled = "OFF";        

		  q.push_back($sformatf("%20s : %s\n", catcher.get_name(),enabled));
		  catcher = iter.next();
	  end
	  q.push_back("--------------------------------------------------------------\n");

	  `uvm_info_context("UVM/REPORT/CATCHER",`UVM_STRING_QUEUE_STREAMING_PACK(q),UVM_LOW,uvm_top)
  endfunction
  

  static function void debug_report_catcher(int what= 0);
    m_debug_flags = what;
  endfunction        
  
 

  pure virtual function action_e catch();
     


   
   protected function void uvm_report_fatal(string id, string message, int verbosity, string fname = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);

     this.uvm_report(UVM_FATAL, id, message, UVM_NONE, fname, line, context_name, report_enabled_checked);
   endfunction  


   
   protected function void uvm_report_error(string id, string message, int verbosity, string fname = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);

     this.uvm_report(UVM_ERROR, id, message, UVM_NONE, fname, line, context_name, report_enabled_checked);
   endfunction  
     

   
   protected function void uvm_report_warning(string id, string message, int verbosity, string fname = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);

     this.uvm_report(UVM_WARNING, id, message, UVM_NONE, fname, line, context_name, report_enabled_checked);
   endfunction  


   
   protected function void uvm_report_info(string id, string message, int verbosity, string fname = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);

     this.uvm_report(UVM_INFO, id, message, verbosity, fname, line, context_name, report_enabled_checked);
   endfunction  


   protected function void uvm_report(uvm_severity severity, string id, string message, int verbosity, string fname = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);

     uvm_report_message l_report_message;
     if (report_enabled_checked == 0) begin
       if (!uvm_report_enabled(verbosity, severity, id))
         return;
     end

     l_report_message = uvm_report_message::new_report_message();
     l_report_message.set_report_message(severity, id, message, verbosity, fname, line, context_name);
     this.uvm_process_report_message(l_report_message);
   endfunction

   protected function void uvm_process_report_message(uvm_report_message msg);
     uvm_report_object ro = m_modified_report_message.get_report_object();
     uvm_action a = ro.get_report_action(msg.get_severity(), msg.get_id());

     if(a) begin
       string composed_message;
       uvm_report_server rs = m_modified_report_message.get_report_server();

       msg.set_report_object(ro);
       msg.set_report_handler(m_modified_report_message.get_report_handler());
       msg.set_report_server(rs);
       msg.set_file(ro.get_report_file_handle(msg.get_severity(), msg.get_id()));
       msg.set_action(a);

       if (a & (UVM_LOG|UVM_DISPLAY))
         composed_message = rs.compose_report_message(msg);
       rs.execute_report_message(msg, composed_message);
     end
   endfunction



  protected function void issue();
     string composed_message;
     uvm_report_server rs = m_modified_report_message.get_report_server();

     if(uvm_action_type'(m_modified_report_message.get_action()) != UVM_NO_ACTION)
     begin
       if (m_modified_report_message.get_action() & (UVM_LOG|UVM_DISPLAY))
         composed_message = rs.compose_report_message(m_modified_report_message);
       rs.execute_report_message(m_modified_report_message, composed_message);
     end
  endfunction



  static function int process_all_report_catchers(uvm_report_message rm);
    int iter;
    uvm_report_catcher catcher;
    int thrown = 1;
    uvm_severity orig_severity;
    static bit in_catcher;
    uvm_report_object l_report_object = rm.get_report_object();

    if(in_catcher == 1) begin
        return 1;
    end
    in_catcher = 1;    
    uvm_callbacks_base::m_tracing = 0;  

    orig_severity = uvm_severity'(rm.get_severity());
    m_modified_report_message = rm;

    catcher = uvm_report_cb::get_first(iter,l_report_object);
    if (catcher != null) begin
      if(m_debug_flags & DO_NOT_MODIFY) begin
        process p = process::self(); 
        string randstate;
        if (p != null)
          randstate = p.get_randstate();
        $cast(m_orig_report_message, rm.clone()); 
        if (p != null)
          p.set_randstate(randstate);
      end
    end
    while(catcher != null) begin
      uvm_severity prev_sev;

      if (!catcher.callback_mode()) begin
        catcher = uvm_report_cb::get_next(iter,l_report_object);
        continue;
      end

      prev_sev = m_modified_report_message.get_severity();
      m_set_action_called = 0;
      thrown = catcher.process_report_catcher();

      if (!m_set_action_called && 
          m_modified_report_message.get_severity() != prev_sev && m_modified_report_message.get_action() == l_report_object.get_report_action(prev_sev, "*@&*^*^*#")) begin

         m_modified_report_message.set_action( l_report_object.get_report_action(m_modified_report_message.get_severity(), "*@&*^*^*#"));
      end

      if(thrown == 0) begin 
        case(orig_severity)
          UVM_FATAL:   m_caught_fatal++;
          UVM_ERROR:   m_caught_error++;
          UVM_WARNING: m_caught_warning++;
         endcase   
         break;
      end 
      catcher = uvm_report_cb::get_next(iter,l_report_object);
    end 

    case(orig_severity)
      UVM_FATAL:    
        if(m_modified_report_message.get_severity() < orig_severity)
          m_demoted_fatal++;
      UVM_ERROR:
        if(m_modified_report_message.get_severity() < orig_severity)
          m_demoted_error++;
      UVM_WARNING:
        if(m_modified_report_message.get_severity() < orig_severity)
          m_demoted_warning++;
    endcase

    in_catcher = 0;
    uvm_callbacks_base::m_tracing = 1;  

    return thrown; 
  endfunction



  local function int process_report_catcher();

    action_e act;

    act = this.catch();

    if(act == UNKNOWN_ACTION)
      this.uvm_report_error("RPTCTHR", {"uvm_report_this.catch() in catcher instance ",
        this.get_name(), " must return THROW or CAUGHT"}, UVM_NONE, `uvm_file, `uvm_line);

    if(m_debug_flags & DO_NOT_MODIFY) begin
      m_modified_report_message.copy(m_orig_report_message);
    end     

    if(act == CAUGHT  && !(m_debug_flags & DO_NOT_CATCH)) begin
      return 0;
    end  

    return 1;

  endfunction




  static function void summarize();
    string s;
    string q[$];
    if(do_report) begin
      q.push_back("\n--- UVM Report catcher Summary ---\n\n\n");
      q.push_back($sformatf("Number of demoted UVM_FATAL reports  :%5d\n", m_demoted_fatal));
      q.push_back($sformatf("Number of demoted UVM_ERROR reports  :%5d\n", m_demoted_error));
      q.push_back($sformatf("Number of demoted UVM_WARNING reports:%5d\n", m_demoted_warning));
      q.push_back($sformatf("Number of caught UVM_FATAL reports   :%5d\n", m_caught_fatal));
      q.push_back($sformatf("Number of caught UVM_ERROR reports   :%5d\n", m_caught_error));
      q.push_back($sformatf("Number of caught UVM_WARNING reports :%5d\n", m_caught_warning));

 	 `uvm_info_context("UVM/REPORT/CATCHER",`UVM_STRING_QUEUE_STREAMING_PACK(q),UVM_LOW,uvm_top)
    end
  endfunction

endclass

`endif 


`ifndef UVM_REPORT_SERVER_SVH
`define UVM_REPORT_SERVER_SVH

typedef class uvm_report_object;

   

typedef class uvm_default_report_server;
virtual class uvm_report_server extends uvm_object;
        function string get_type_name();
                return "uvm_report_server";
        endfunction
        function new(string name="base");
                super.new(name);
        endfunction

        pure virtual  function void set_max_quit_count(int count, bit overridable = 1);

        pure virtual  function int get_max_quit_count();

        pure virtual  function void set_quit_count(int quit_count);

        pure virtual  function int get_quit_count();

        pure virtual  function void set_severity_count(uvm_severity severity, int count);
        pure virtual  function int get_severity_count(uvm_severity severity);

        pure virtual  function void set_id_count(string id, int count);

        pure virtual  function int get_id_count(string id);


        pure virtual function void get_id_set(output string q[$]);

        pure virtual function void get_severity_set(output uvm_severity q[$]);

        pure virtual function void set_message_database(uvm_tr_database database);

        pure virtual function uvm_tr_database get_message_database();

        function void do_copy (uvm_object rhs);
                uvm_report_server rhs_;

                super.do_copy(rhs);
                if(!$cast(rhs_,rhs)) `uvm_error("UVM/REPORT/SERVER/RPTCOPY","cannot copy to report_server from the given datatype")

                begin
                        uvm_severity q[$];
                        rhs_.get_severity_set(q);
                        foreach(q[s])
                                set_severity_count(q[s],rhs_.get_severity_count(q[s]));
                end

                begin
                        string q[$];
                        rhs_.get_id_set(q);
                        foreach(q[s])
                                set_id_count(q[s],rhs_.get_id_count(q[s]));
                end

                set_message_database(rhs_.get_message_database());
                set_max_quit_count(rhs_.get_max_quit_count());
                set_quit_count(rhs_.get_quit_count());
        endfunction



        pure virtual function void process_report_message(uvm_report_message report_message);



        pure virtual function void execute_report_message(uvm_report_message report_message, string composed_message);



        pure virtual function string compose_report_message(uvm_report_message report_message, string report_object_name = "");



        pure virtual function void report_summarize(UVM_FILE file = 0);


`ifndef UVM_NO_DEPRECATED 


        virtual function void summarize(UVM_FILE file=0);
          report_summarize(file);
        endfunction

`endif

   
        static function void set_server(uvm_report_server server);
	        uvm_coreservice_t cs = uvm_coreservice_t::get();
                server.copy(cs.get_report_server());
                cs.set_report_server(server);
        endfunction



        static function uvm_report_server get_server();
	        uvm_coreservice_t cs = uvm_coreservice_t::get();
                return cs.get_report_server();
        endfunction
endclass


class uvm_default_report_server extends uvm_report_server;

  local int m_quit_count;
  local int m_max_quit_count; 
  bit max_quit_overridable = 1;
  local int m_severity_count[uvm_severity];
  protected int m_id_count[string];
   protected uvm_tr_database m_message_db;
   protected uvm_tr_stream m_streams[string][string]; 
   

  bit enable_report_id_count_summary=1;


  bit record_all_messages = 0;

  
  bit show_verbosity = 0;


  bit show_terminator = 0;

  function string get_type_name();
    return "uvm_default_report_server";
  endfunction



  function new(string name = "uvm_report_server");
    super.new(name);
    set_max_quit_count(0);
    reset_quit_count();
    reset_severity_counts();
  endfunction




  virtual function void do_print (uvm_printer printer);

    uvm_severity l_severity_count_index;
    string l_id_count_index;

    printer.print_int("quit_count", m_quit_count, $bits(m_quit_count), UVM_DEC, ".", "int");
    printer.print_int("max_quit_count", m_max_quit_count, $bits(m_max_quit_count), UVM_DEC, ".", "int");
    printer.print_int("max_quit_overridable", max_quit_overridable, $bits(max_quit_overridable), UVM_BIN, ".", "bit");

    if (m_severity_count.first(l_severity_count_index)) begin
      printer.print_array_header("severity_count",m_severity_count.size(),"severity counts");
      do
        printer.print_int($sformatf("[%s]",l_severity_count_index.name()), m_severity_count[l_severity_count_index], 32, UVM_DEC);
      while (m_severity_count.next(l_severity_count_index));
      printer.print_array_footer();
    end

    if (m_id_count.first(l_id_count_index)) begin
      printer.print_array_header("id_count",m_id_count.size(),"id counts");
      do
        printer.print_int($sformatf("[%s]",l_id_count_index), m_id_count[l_id_count_index], 32, UVM_DEC);
      while (m_id_count.next(l_id_count_index));
      printer.print_array_footer();
    end

    printer.print_int("enable_report_id_count_summary", enable_report_id_count_summary, $bits(enable_report_id_count_summary), UVM_BIN, ".", "bit");
    printer.print_int("record_all_messages", record_all_messages, $bits(record_all_messages), UVM_BIN, ".", "bit");
    printer.print_int("show_verbosity", show_verbosity, $bits(show_verbosity), UVM_BIN, ".", "bit");
    printer.print_int("show_terminator", show_terminator, $bits(show_terminator), UVM_BIN, ".", "bit");

  endfunction





  function int get_max_quit_count();
    return m_max_quit_count;
  endfunction


  function void set_max_quit_count(int count, bit overridable = 1);
    if (max_quit_overridable == 0) begin
      uvm_report_info("NOMAXQUITOVR", $sformatf("The max quit count setting of %0d is not overridable to %0d due to a previous setting.", m_max_quit_count, count), UVM_NONE);
      return;
    end
    max_quit_overridable = overridable;
    m_max_quit_count = count < 0 ? 0 : count;
  endfunction



  function int get_quit_count();
    return m_quit_count;
  endfunction


  function void set_quit_count(int quit_count);
    m_quit_count = quit_count < 0 ? 0 : quit_count;
  endfunction


  function void incr_quit_count();
    m_quit_count++;
  endfunction


  function void reset_quit_count();
    m_quit_count = 0;
  endfunction


  function bit is_quit_count_reached();
    return (m_quit_count >= m_max_quit_count);
  endfunction


 


  function int get_severity_count(uvm_severity severity);
    return m_severity_count[severity];
  endfunction


  function void set_severity_count(uvm_severity severity, int count);
    m_severity_count[severity] = count < 0 ? 0 : count;
  endfunction


  function void incr_severity_count(uvm_severity severity);
    m_severity_count[severity]++;
  endfunction


  function void reset_severity_counts();
    uvm_severity s;
    s = s.first();
    forever begin
      m_severity_count[s] = 0;
      if(s == s.last()) break;
      s = s.next();
    end
  endfunction





  function int get_id_count(string id);
    if(m_id_count.exists(id))
      return m_id_count[id];
    return 0;
  endfunction


  function void set_id_count(string id, int count);
    m_id_count[id] = count < 0 ? 0 : count;
  endfunction


  function void incr_id_count(string id);
    if(m_id_count.exists(id))
      m_id_count[id]++;
    else
      m_id_count[id] = 1;
  endfunction


   virtual function void set_message_database(uvm_tr_database database);
      m_message_db = database;
   endfunction : set_message_database

   virtual function uvm_tr_database get_message_database();
      return m_message_db;
   endfunction : get_message_database


  virtual function void get_severity_set(output uvm_severity q[$]);
    foreach(m_severity_count[idx])
      q.push_back(idx);
  endfunction


  virtual function void get_id_set(output string q[$]);
    foreach(m_id_count[idx])
      q.push_back(idx);
  endfunction



  function void f_display(UVM_FILE file, string str);
    if (file == 0)
      $display("%s", str);
    else
      $fdisplay(file, "%s", str);
  endfunction



  virtual function void process_report_message(uvm_report_message report_message);

    uvm_report_handler l_report_handler = report_message.get_report_handler();
    	process p = process::self();
    bit report_ok = 1;

    report_message.set_report_server(this);

`ifndef UVM_NO_DEPRECATED 


    if(report_message.get_action() & UVM_CALL_HOOK)
      report_ok = l_report_handler.run_hooks( report_message.get_report_object(), report_message.get_severity(), report_message.get_id(), report_message.get_message(), report_message.get_verbosity(), report_message.get_filename(), report_message.get_line());

`endif

    if(report_ok)
      report_ok = uvm_report_catcher::process_all_report_catchers(report_message);

    if(uvm_action_type'(report_message.get_action()) == UVM_NO_ACTION)
      report_ok = 0;

    if(report_ok) begin	
      string m;
      uvm_coreservice_t cs = uvm_coreservice_t::get();
      uvm_report_server svr = cs.get_report_server();

`ifdef UVM_DEPRECATED_REPORTING

      if (report_message.get_action() & (UVM_LOG|UVM_DISPLAY))
        m = compose_message(report_message.get_severity(), l_report_handler.get_full_name(), report_message.get_id(), report_message.get_message(), report_message.get_filename(), report_message.get_line()); 

      process_report(report_message.get_severity(), l_report_handler.get_full_name(), report_message.get_id(), report_message.get_message(), report_message.get_action(), report_message.get_file(), report_message.get_filename(), report_message.get_line(), m, report_message.get_verbosity(), report_message.get_report_object());

`else

      if (report_message.get_action() & (UVM_LOG|UVM_DISPLAY))
        m = svr.compose_report_message(report_message);

      svr.execute_report_message(report_message, m);

`endif
    end

  endfunction




 
  virtual function void execute_report_message(uvm_report_message report_message, string composed_message); 
                                               process p = process::self();
                                               
    incr_severity_count(report_message.get_severity());
    incr_id_count(report_message.get_id());

    if (record_all_messages)
      report_message.set_action(report_message.get_action() | UVM_RM_RECORD);

    if(report_message.get_action() & UVM_RM_RECORD) begin
       uvm_tr_stream stream;
       uvm_report_object ro = report_message.get_report_object();
       uvm_report_handler rh = report_message.get_report_handler();

       if (m_streams.exists(ro.get_name()) && (m_streams[ro.get_name()].exists(rh.get_name())))
         stream = m_streams[ro.get_name()][rh.get_name()];

       if (stream == null) begin
          uvm_tr_database db;

          db = get_message_database();

          if (db == null) begin
             uvm_coreservice_t cs = uvm_coreservice_t::get();
             db = cs.get_default_tr_database();
          end
          if (db != null) begin
             stream = db.open_stream(ro.get_name(), rh.get_name(), "MESSAGES");
             m_streams[ro.get_name()][rh.get_name()] = stream;
          end
       end
       if (stream != null) begin
          uvm_recorder recorder = stream.open_recorder(report_message.get_name(),,report_message.get_type_name());
             if (recorder != null) begin
             report_message.record(recorder);
             recorder.free();
          end
       end
    end

    if(report_message.get_action() & UVM_DISPLAY)
      $display("%s", composed_message);

    if(report_message.get_action() & UVM_LOG)
      if( (report_message.get_file() == 0) || (report_message.get_file() != 32'h8000_0001) ) begin 
        UVM_FILE tmp_file = report_message.get_file();
        if((report_message.get_file() & 32'h8000_0000) == 0) begin 
          tmp_file = report_message.get_file() & 32'hffff_fffe;
        end
      f_display(tmp_file, composed_message);
    end    

    if(report_message.get_action() & UVM_COUNT) begin
      if(get_max_quit_count() != 0) begin
        incr_quit_count();
        if(is_quit_count_reached()) begin
          report_message.set_action(report_message.get_action() | UVM_EXIT);
        end
      end  
    end

    if(report_message.get_action() & UVM_EXIT) begin
       uvm_root l_root;
       uvm_coreservice_t cs;
       cs = uvm_coreservice_t::get();
       l_root = cs.get_root();
       l_root.die();
    end

    if (report_message.get_action() & UVM_STOP) 
      $stop;

  endfunction



  virtual function string compose_report_message(uvm_report_message report_message, string report_object_name = "");

    string sev_string;
    uvm_severity l_severity;
    uvm_verbosity l_verbosity;
    string filename_line_string;
    string time_str;
    string line_str;
    string context_str;
    string verbosity_str;
    string terminator_str;
    string msg_body_str;
    uvm_report_message_element_container el_container;
    string prefix;
    uvm_report_handler l_report_handler;

    l_severity = report_message.get_severity();
    sev_string = l_severity.name();

    if (report_message.get_filename() != "") begin
      line_str.itoa(report_message.get_line());
      filename_line_string = {report_message.get_filename(), "(", line_str, ") "};
    end

    $swrite(time_str, "%0t", $time);
 
    if (report_message.get_context() != "")
      context_str = {"@@", report_message.get_context()};

    if (show_verbosity) begin
      if ($cast(l_verbosity, report_message.get_verbosity()))
        verbosity_str = l_verbosity.name();
      else
        verbosity_str.itoa(report_message.get_verbosity());
      verbosity_str = {"(", verbosity_str, ")"};
    end

    if (show_terminator)
      terminator_str = {" -",sev_string};

    el_container = report_message.get_element_container();
    if (el_container.size() == 0)
      msg_body_str = report_message.get_message();
    else begin
      prefix = uvm_default_printer.knobs.prefix;
      uvm_default_printer.knobs.prefix = " +";
      msg_body_str = {report_message.get_message(), "\n", el_container.sprint()};
      uvm_default_printer.knobs.prefix = prefix;
    end

    if (report_object_name == "") begin
      l_report_handler = report_message.get_report_handler();
      report_object_name = l_report_handler.get_full_name();
    end

    compose_report_message = {sev_string, verbosity_str, " ", filename_line_string, "@ ", 
      time_str, ": ", report_object_name, context_str,
      " [", report_message.get_id(), "] ", msg_body_str, terminator_str};

  endfunction 



  virtual function void report_summarize(UVM_FILE file = 0);
    string id;
    string name;
    string output_str;
    string q[$];

    uvm_report_catcher::summarize();
    q.push_back("\n--- UVM Report Summary ---\n\n");

    if(m_max_quit_count != 0) begin
      if ( m_quit_count >= m_max_quit_count )
        q.push_back("Quit count reached!\n");
      q.push_back($sformatf("Quit count : %5d of %5d\n",m_quit_count, m_max_quit_count));
    end

    q.push_back("** Report counts by severity\n");
    foreach(m_severity_count[s]) begin
      q.push_back($sformatf("%s :%5d\n", s.name(), m_severity_count[s]));
    end

    if (enable_report_id_count_summary) begin
      q.push_back("** Report counts by id\n");
      foreach(m_id_count[id])
        q.push_back($sformatf("[%s] %5d\n", id, m_id_count[id]));
    end

    `uvm_info("UVM/REPORT/SERVER",`UVM_STRING_QUEUE_STREAMING_PACK(q),UVM_LOW)
  endfunction


`ifndef UVM_NO_DEPRECATED


  virtual function void process_report( uvm_severity severity, string name, string id, string message, uvm_action action, UVM_FILE file, string filename, int line, string composed_message, int verbosity_level, uvm_report_object client);
    uvm_report_message l_report_message;

    l_report_message = uvm_report_message::new_report_message();
    l_report_message.set_report_message(severity, id, message, 
					verbosity_level, filename, line, "");
    l_report_message.set_report_object(client);
    l_report_message.set_report_handler(client.get_report_handler());
    l_report_message.set_file(file);
    l_report_message.set_action(action);
    l_report_message.set_report_server(this);

    execute_report_message(l_report_message, composed_message);
  endfunction

  

  virtual function string compose_message( uvm_severity severity, string name, string id, string message, string filename, int    line);
    uvm_report_message l_report_message;

    l_report_message = uvm_report_message::new_report_message();
    l_report_message.set_report_message(severity, id, message, 
					UVM_NONE, filename, line, "");

    return compose_report_message(l_report_message, name);
  endfunction 


`endif


endclass


`endif 


`ifndef UVM_REPORT_HANDLER_SVH
`define UVM_REPORT_HANDLER_SVH

typedef class uvm_report_object;
typedef class uvm_report_server;
typedef uvm_pool#(string, uvm_action) uvm_id_actions_array;
typedef uvm_pool#(string, UVM_FILE) uvm_id_file_array;
typedef uvm_pool#(string, int) uvm_id_verbosities_array;
typedef uvm_pool#(uvm_severity, uvm_severity) uvm_sev_override_array;


class uvm_report_handler extends uvm_object;


  int m_max_verbosity_level;

  uvm_id_verbosities_array id_verbosities;
  uvm_id_verbosities_array severity_id_verbosities[uvm_severity];

  uvm_id_actions_array id_actions;
  uvm_action severity_actions[uvm_severity];
  uvm_id_actions_array severity_id_actions[uvm_severity];

  uvm_sev_override_array sev_overrides;
  uvm_sev_override_array sev_id_overrides [string];

  UVM_FILE default_file_handle;
  uvm_id_file_array id_file_handles;
  UVM_FILE severity_file_handles[uvm_severity];
  uvm_id_file_array severity_id_file_handles[uvm_severity];


  `uvm_object_utils(uvm_report_handler)



  function new(string name = "uvm_report_handler");
    super.new(name);
    initialize();
  endfunction



  virtual function void do_print (uvm_printer printer);

    uvm_verbosity l_verbosity;
    uvm_severity l_severity;
    string idx;
    int l_int;

    if ($cast(l_verbosity, m_max_verbosity_level))
      printer.print_generic("max_verbosity_level", "uvm_verbosity", 32, l_verbosity.name());
    else
      printer.print_int("max_verbosity_level", m_max_verbosity_level, 32, UVM_DEC, ".", "int");

    if(id_verbosities.first(idx)) begin
      printer.print_array_header("id_verbosities",id_verbosities.num(), "uvm_pool");
      do begin
        l_int = id_verbosities.get(idx);
        if ($cast(l_verbosity, l_int)) printer.print_generic($sformatf("[%s]", idx), "uvm_verbosity", 32, l_verbosity.name());
        else begin
          string l_str;
          l_str.itoa(l_int);
          printer.print_generic($sformatf("[%s]", idx), "int", 32, l_str);
        end
      end while(id_verbosities.next(idx));
      printer.print_array_footer();
    end

    if(severity_id_verbosities.size() != 0) begin
      int _total_cnt;
      foreach (severity_id_verbosities[l_severity])
        _total_cnt += severity_id_verbosities[l_severity].num();
      printer.print_array_header("severity_id_verbosities", _total_cnt, "array");
      if(severity_id_verbosities.first(l_severity)) begin
        do begin
          uvm_id_verbosities_array id_v_ary = severity_id_verbosities[l_severity];
          if(id_v_ary.first(idx))
          do begin
            l_int = id_v_ary.get(idx);
            if ($cast(l_verbosity, l_int))
              printer.print_generic($sformatf("[%s:%s]", l_severity.name(), idx), "uvm_verbosity", 32, l_verbosity.name());
            else begin
              string l_str;
              l_str.itoa(l_int);
              printer.print_generic($sformatf("[%s:%s]", l_severity.name(), idx), "int", 32, l_str);
            end
          end while(id_v_ary.next(idx));
        end while(severity_id_verbosities.next(l_severity));
      end
      printer.print_array_footer();
    end

    if(id_actions.first(idx)) begin
      printer.print_array_header("id_actions",id_actions.num(), "uvm_pool");
      do begin
        l_int = id_actions.get(idx);
        printer.print_generic($sformatf("[%s]", idx), "uvm_action", 32, format_action(l_int));
      end while(id_actions.next(idx));
      printer.print_array_footer();
    end

    if(severity_actions.first(l_severity)) begin
      printer.print_array_header("severity_actions",4,"array");
      do begin
        printer.print_generic($sformatf("[%s]", l_severity.name()), "uvm_action", 32, format_action(severity_actions[l_severity]));
      end while(severity_actions.next(l_severity));
      printer.print_array_footer();
    end

    if(severity_id_actions.size() != 0) begin
      int _total_cnt;
      foreach (severity_id_actions[l_severity])
        _total_cnt += severity_id_actions[l_severity].num();
      printer.print_array_header("severity_id_actions", _total_cnt, "array");
      if(severity_id_actions.first(l_severity)) begin
        do begin
          uvm_id_actions_array id_a_ary = severity_id_actions[l_severity];
          if(id_a_ary.first(idx))
          do begin
            printer.print_generic($sformatf("[%s:%s]", l_severity.name(), idx), "uvm_action", 32, format_action(id_a_ary.get(idx)));
          end while(id_a_ary.next(idx));
        end while(severity_id_actions.next(l_severity));
      end
      printer.print_array_footer();
    end

    if(sev_overrides.first(l_severity)) begin
      printer.print_array_header("sev_overrides",sev_overrides.num(), "uvm_pool");
      do begin
        uvm_severity l_severity_new = sev_overrides.get(l_severity);
        printer.print_generic($sformatf("[%s]", l_severity.name()), "uvm_severity", 32, l_severity_new.name());
      end while(sev_overrides.next(l_severity));
      printer.print_array_footer();
    end

    if(sev_id_overrides.size() != 0) begin
      int _total_cnt;
      foreach (sev_id_overrides[idx])
        _total_cnt += sev_id_overrides[idx].num();
      printer.print_array_header("sev_id_overrides", _total_cnt, "array");
      if(sev_id_overrides.first(idx)) begin
        do begin
          uvm_sev_override_array sev_o_ary = sev_id_overrides[idx];
          if(sev_o_ary.first(l_severity))
          do begin
            uvm_severity new_sev = sev_o_ary.get(l_severity);
            printer.print_generic($sformatf("[%s:%s]", l_severity.name(), idx), "uvm_severity", 32, new_sev.name());
          end while(sev_o_ary.next(l_severity));
        end while(sev_id_overrides.next(idx));
      end
      printer.print_array_footer();
    end

    printer.print_int("default_file_handle", default_file_handle, 32, UVM_HEX, ".", "int");

    if(id_file_handles.first(idx)) begin
      printer.print_array_header("id_file_handles",id_file_handles.num(), "uvm_pool");
      do begin
        printer.print_int($sformatf("[%s]", idx), id_file_handles.get(idx), 32, UVM_HEX, ".", "UVM_FILE");
      end while(id_file_handles.next(idx));
      printer.print_array_footer();
    end

    if(severity_file_handles.first(l_severity)) begin
      printer.print_array_header("severity_file_handles",4,"array");
      do begin
        printer.print_int($sformatf("[%s]", l_severity.name()), severity_file_handles[l_severity], 32, UVM_HEX, ".", "UVM_FILE");
      end while(severity_file_handles.next(l_severity));
      printer.print_array_footer();
    end

    if(severity_id_file_handles.size() != 0) begin
      int _total_cnt;
      foreach (severity_id_file_handles[l_severity])
        _total_cnt += severity_id_file_handles[l_severity].num();
      printer.print_array_header("severity_id_file_handles", _total_cnt, "array");
      if(severity_id_file_handles.first(l_severity)) begin
        do begin
          uvm_id_file_array id_f_ary = severity_id_file_handles[l_severity];
          if(id_f_ary.first(idx))
          do begin
            printer.print_int($sformatf("[%s:%s]", l_severity.name(), idx), id_f_ary.get(idx), 32, UVM_HEX, ".", "UVM_FILE");
          end while(id_f_ary.next(idx));
        end while(severity_id_file_handles.next(l_severity));
      end
      printer.print_array_footer();
    end

  endfunction

  



  virtual function void process_report_message(uvm_report_message report_message);
    process p = process::self();
    uvm_report_server srvr = uvm_report_server::get_server();
    string id = report_message.get_id();
    uvm_severity severity = report_message.get_severity();

    if(sev_id_overrides.exists(id)) begin
      if(sev_id_overrides[id].exists(uvm_severity'(severity))) begin
        severity = sev_id_overrides[id].get(severity);
        report_message.set_severity(severity);
      end
    end
    else begin
      if(sev_overrides.exists(severity)) begin
        severity = sev_overrides.get(severity);
        report_message.set_severity(severity);
      end
    end
    report_message.set_file(get_file_handle(severity, id));
    report_message.set_report_handler(this);
    report_message.set_action(get_action(severity, id));
    srvr.process_report_message(report_message);
    
  endfunction





  static function string format_action(uvm_action action);
    string s;

    if(uvm_action_type'(action) == UVM_NO_ACTION) begin
      s = "NO ACTION";
    end
    else begin
      s = "";
      if(action & UVM_DISPLAY)   s = {s, "DISPLAY "};
      if(action & UVM_LOG)       s = {s, "LOG "};
      if(action & UVM_RM_RECORD) s = {s, "RM_RECORD "};
      if(action & UVM_COUNT)     s = {s, "COUNT "};
      if(action & UVM_CALL_HOOK) s = {s, "CALL_HOOK "};
      if(action & UVM_EXIT)      s = {s, "EXIT "};
      if(action & UVM_STOP)      s = {s, "STOP "};
    end

    return s;
  endfunction



  function void initialize();

    set_default_file(0);
    m_max_verbosity_level = UVM_MEDIUM;

    id_actions=new();
    id_verbosities=new();
    id_file_handles=new();
    sev_overrides=new();

    set_severity_action(UVM_INFO,    UVM_DISPLAY);
    set_severity_action(UVM_WARNING, UVM_DISPLAY);
    set_severity_action(UVM_ERROR,   UVM_DISPLAY | UVM_COUNT);
    set_severity_action(UVM_FATAL,   UVM_DISPLAY | UVM_EXIT);

    set_severity_file(UVM_INFO, default_file_handle);
    set_severity_file(UVM_WARNING, default_file_handle);
    set_severity_file(UVM_ERROR,   default_file_handle);
    set_severity_file(UVM_FATAL,   default_file_handle);

  endfunction

  

  local function UVM_FILE get_severity_id_file(uvm_severity severity, string id);

    uvm_id_file_array array;

    if(severity_id_file_handles.exists(severity)) begin
      array = severity_id_file_handles[severity];      
      if(array.exists(id))
        return array.get(id);
    end


    if(id_file_handles.exists(id))
      return id_file_handles.get(id);

    if(severity_file_handles.exists(severity))
      return severity_file_handles[severity];

    return default_file_handle;

  endfunction



  function void set_verbosity_level(int verbosity_level);
    m_max_verbosity_level = verbosity_level;
  endfunction



  function int get_verbosity_level(uvm_severity severity=UVM_INFO, string id="" );

    uvm_id_verbosities_array array;
    if(severity_id_verbosities.exists(severity)) begin
      array = severity_id_verbosities[severity];
      if(array.exists(id)) begin
        return array.get(id);
      end
    end

    if(id_verbosities.exists(id)) begin
      return id_verbosities.get(id);
    end

    return m_max_verbosity_level;

  endfunction



  function uvm_action get_action(uvm_severity severity, string id);

    uvm_id_actions_array array;
    if(severity_id_actions.exists(severity)) begin
      array = severity_id_actions[severity];
      if(array.exists(id))
        return array.get(id);
    end

    if(id_actions.exists(id))
      return id_actions.get(id);

    return severity_actions[severity];

  endfunction



  function UVM_FILE get_file_handle(uvm_severity severity, string id);
    UVM_FILE file;
  
    file = get_severity_id_file(severity, id);
    if (file != 0)
      return file;
  
    if (id_file_handles.exists(id)) begin
      file = id_file_handles.get(id);
      if (file != 0)
        return file;
    end

    if (severity_file_handles.exists(severity)) begin
      file = severity_file_handles[severity];
      if(file != 0)
        return file;
    end

    return default_file_handle;
  endfunction



  function void set_severity_action(input uvm_severity severity, input uvm_action action);
    severity_actions[severity] = action;
  endfunction

  function void set_id_action(input string id, input uvm_action action);
    id_actions.add(id, action);
  endfunction

  function void set_severity_id_action(uvm_severity severity, string id, uvm_action action);
    if(!severity_id_actions.exists(severity))
      severity_id_actions[severity] = new;
    severity_id_actions[severity].add(id,action);
  endfunction
  
  function void set_id_verbosity(input string id, input int verbosity);
    id_verbosities.add(id, verbosity);
  endfunction

  function void set_severity_id_verbosity(uvm_severity severity, string id, int verbosity);
    if(!severity_id_verbosities.exists(severity))
      severity_id_verbosities[severity] = new;
    severity_id_verbosities[severity].add(id,verbosity);
  endfunction


  function void set_default_file (UVM_FILE file);
    default_file_handle = file;
  endfunction

  function void set_severity_file (uvm_severity severity, UVM_FILE file);
    severity_file_handles[severity] = file;
  endfunction

  function void set_id_file (string id, UVM_FILE file);
    id_file_handles.add(id, file);
  endfunction

  function void set_severity_id_file(uvm_severity severity, string id, UVM_FILE file);
    if(!severity_id_file_handles.exists(severity))
      severity_id_file_handles[severity] = new;
    severity_id_file_handles[severity].add(id, file);
  endfunction

  function void set_severity_override(uvm_severity cur_severity, uvm_severity new_severity);
    sev_overrides.add(cur_severity, new_severity);
  endfunction

  function void set_severity_id_override(uvm_severity cur_severity, string id, uvm_severity new_severity);
    uvm_sev_override_array arr;
    if(!sev_id_overrides.exists(id))
      sev_id_overrides[id] = new;
 
    sev_id_overrides[id].add(cur_severity, new_severity);
  endfunction

  


  virtual function void report( uvm_severity severity, string name, string id, string message, int verbosity_level=UVM_MEDIUM, string filename="", int line=0, uvm_report_object client=null);

    bit l_report_enabled = 0;
    uvm_report_message l_report_message;
    uvm_coreservice_t cs;
    cs = uvm_coreservice_t::get();
    if (!uvm_report_enabled(verbosity_level, UVM_INFO, id))
      return;

    if (client==null) 
      client = cs.get_root();

    l_report_message = uvm_report_message::new_report_message();
    l_report_message.set_report_message(severity, id, message, verbosity_level, filename, line, name);
    l_report_message.set_report_object(client);
    l_report_message.set_action(get_action(severity,id));
    process_report_message(l_report_message);

  endfunction

`ifndef UVM_NO_DEPRECATED



  virtual function bit run_hooks(uvm_report_object client, uvm_severity severity, string id, string message, int verbosity, string filename, int line);

    bit ok;

    ok = client.report_hook(id, message, verbosity, filename, line);

    case(severity)
      UVM_INFO:
       ok &= client.report_info_hook   (id, message, verbosity, filename, line);
      UVM_WARNING:
       ok &= client.report_warning_hook(id, message, verbosity, filename, line);
      UVM_ERROR:
       ok &= client.report_error_hook  (id, message, verbosity, filename, line);
      UVM_FATAL:
       ok &= client.report_fatal_hook  (id, message, verbosity, filename, line);
    endcase

    return ok;

  endfunction



  function void dump_state();

    string s;
    UVM_FILE file;
    uvm_action a;
    string idx;
    string q[$];
 
    uvm_id_actions_array id_a_ary;
    uvm_id_verbosities_array id_v_ary;
    uvm_id_file_array id_f_ary;

    q.push_back("\n----------------------------------------------------------------------\n");
    q.push_back("report handler state dump \n\n");


    q.push_back("\n+-----------------+\n");
    q.push_back("|   Verbosities   |\n");
    q.push_back("+-----------------+\n\n"); 

    q.push_back($sformatf("max verbosity level = %d\n", m_max_verbosity_level));
    q.push_back("*** verbosities by id\n");

    if(id_verbosities.first(idx))
    do begin
      uvm_verbosity v = uvm_verbosity'(id_verbosities.get(idx));
      q.push_back($sformatf("[%s] --> %s\n", idx, v.name()));
    end while(id_verbosities.next(idx));


    q.push_back("*** verbosities by id and severity\n");

    foreach( severity_id_verbosities[severity] ) begin
      uvm_severity sev = uvm_severity'(severity);
      id_v_ary = severity_id_verbosities[severity];
      if(id_v_ary.first(idx))
      do begin
        uvm_verbosity v = uvm_verbosity'(id_v_ary.get(idx));
        q.push_back($sformatf("%s:%s --> %s\n",sev.name(), idx, v.name()));    
      end while(id_v_ary.next(idx));
    end


    q.push_back("\n+-------------+\n");
    q.push_back("|   actions   |\n");
    q.push_back("+-------------+\n\n");
    
    q.push_back("*** actions by severity\n");
    foreach( severity_actions[severity] ) begin
      uvm_severity sev = uvm_severity'(severity);
      q.push_back($sformatf("%s = %s\n",sev.name(), format_action(severity_actions[severity])));
    end

    q.push_back("\n*** actions by id\n");

    if(id_actions.first(idx))
    do begin
      q.push_back($sformatf("[%s] --> %s\n", idx, format_action(id_actions.get(idx))));
    end while(id_actions.next(idx));

    q.push_back("\n*** actions by id and severity\n");

    foreach( severity_id_actions[severity] ) begin
      uvm_severity sev = uvm_severity'(severity);
      id_a_ary = severity_id_actions[severity];
      if(id_a_ary.first(idx))
      do begin
        q.push_back($sformatf("%s:%s --> %s\n",sev.name(), idx, format_action(id_a_ary.get(idx))));   
      end while(id_a_ary.next(idx));
    end


    q.push_back("\n+-------------+\n");
    q.push_back("|    files    |\n");
    q.push_back("+-------------+\n\n");

    q.push_back($sformatf("default file handle = %d\n\n", default_file_handle));

    q.push_back("*** files by severity\n");
    foreach( severity_file_handles[severity] ) begin
      uvm_severity sev = uvm_severity'(severity);
      file = severity_file_handles[severity];
      q.push_back($sformatf("%s = %d\n", sev.name(), file));
    end

    q.push_back("\n*** files by id\n");

    if(id_file_handles.first(idx))
    do begin
      file = id_file_handles.get(idx);
      q.push_back($sformatf("id %s --> %d\n", idx, file));
    end while (id_file_handles.next(idx));

    q.push_back("\n*** files by id and severity\n");

    foreach( severity_id_file_handles[severity] ) begin
      uvm_severity sev = uvm_severity'(severity);
      id_f_ary = severity_id_file_handles[severity];
      if(id_f_ary.first(idx))
      do begin
        q.push_back($sformatf("%s:%s --> %d\n", sev.name(), idx, id_f_ary.get(idx)));
      end while(id_f_ary.next(idx));
    end

    begin
		uvm_report_server srvr;
	    srvr=uvm_report_server::get_server();        
    	srvr.report_summarize();
    end
    
    q.push_back("----------------------------------------------------------------------\n");
	`uvm_info("UVM/REPORT/HANDLER",`UVM_STRING_QUEUE_STREAMING_PACK(q),UVM_LOW)
  endfunction


`endif


endclass : uvm_report_handler

`endif 


`ifndef UVM_REPORT_CLIENT_SVH
`define UVM_REPORT_CLIENT_SVH

typedef class uvm_component;
typedef class uvm_env;
typedef class uvm_root;


class uvm_report_object extends uvm_object;

  uvm_report_handler m_rh;

  function new(string name = "");
    super.new(name);
    m_rh = uvm_report_handler::type_id::create(name);
  endfunction

  function uvm_report_object uvm_get_report_object();
    return this;
  endfunction

  function int uvm_report_enabled(int verbosity, uvm_severity severity = UVM_INFO, string id = "");
    if (get_report_verbosity_level(severity, id) < verbosity)
      return 0;
    return 1;
  endfunction


  virtual function void uvm_report( uvm_severity severity, string id, string message, int verbosity = (severity == uvm_severity'(UVM_ERROR)) ? UVM_LOW : (severity == uvm_severity'(UVM_FATAL)) ? UVM_NONE : UVM_MEDIUM, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked =0);
    uvm_report_message l_report_message;
    if (report_enabled_checked == 0) begin
      if (!uvm_report_enabled(verbosity, severity, id))
        return;
    end
    l_report_message = uvm_report_message::new_report_message();
    l_report_message.set_report_message(severity, id, message, 
					verbosity, filename, line, context_name);
    uvm_process_report_message(l_report_message);
  endfunction 



  virtual function void uvm_report_info( string id, string message, int verbosity = UVM_MEDIUM, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0); 
    uvm_report (UVM_INFO, id, message, verbosity, filename, line, context_name, report_enabled_checked);
  endfunction


  virtual function void uvm_report_warning( string id, string message, int verbosity = UVM_MEDIUM, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0); 
    uvm_report (UVM_WARNING, id, message, verbosity, filename, line, context_name, report_enabled_checked);
  endfunction


  virtual function void uvm_report_error( string id, string message, int verbosity = UVM_LOW, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0); 
    uvm_report (UVM_ERROR, id, message, verbosity, filename, line, context_name, report_enabled_checked);
  endfunction


  virtual function void uvm_report_fatal( string id, string message, int verbosity = UVM_NONE, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0); 
    uvm_report (UVM_FATAL, id, message, verbosity, filename, line, context_name, report_enabled_checked);
  endfunction


  virtual function void uvm_process_report_message(uvm_report_message report_message);
    report_message.set_report_object(this);
    m_rh.process_report_message(report_message);
  endfunction





  function int get_report_verbosity_level(uvm_severity severity=UVM_INFO, string id="");
    return m_rh.get_verbosity_level(severity, id);
  endfunction



  function int get_report_max_verbosity_level();
    return m_rh.m_max_verbosity_level;
  endfunction



  function void set_report_verbosity_level (int verbosity_level);
    m_rh.set_verbosity_level(verbosity_level);
  endfunction

  function void set_report_id_verbosity (string id, int verbosity);
    m_rh.set_id_verbosity(id, verbosity);
  endfunction


  function void set_report_severity_id_verbosity (uvm_severity severity, string id, int verbosity);
    m_rh.set_severity_id_verbosity(severity, id, verbosity);
  endfunction





  function int get_report_action(uvm_severity severity, string id);
    return m_rh.get_action(severity,id);
  endfunction


  function void set_report_severity_action (uvm_severity severity, uvm_action action);
    m_rh.set_severity_action(severity, action);
  endfunction

  function void set_report_id_action (string id, uvm_action action);
    m_rh.set_id_action(id, action);
  endfunction


  function void set_report_severity_id_action (uvm_severity severity, string id, uvm_action action);
    m_rh.set_severity_id_action(severity, id, action);
  endfunction





  function int get_report_file_handle(uvm_severity severity, string id);
    return m_rh.get_file_handle(severity,id);
  endfunction


  
  function void set_report_default_file (UVM_FILE file);
    m_rh.set_default_file(file);
  endfunction

  
  function void set_report_id_file (string id, UVM_FILE file);
    m_rh.set_id_file(id, file);
  endfunction

  function void set_report_severity_file (uvm_severity severity, UVM_FILE file);
    m_rh.set_severity_file(severity, file);
  endfunction


  function void set_report_severity_id_file (uvm_severity severity, string id, UVM_FILE file);
    m_rh.set_severity_id_file(severity, id, file);
  endfunction




  function void set_report_severity_override(uvm_severity cur_severity, uvm_severity new_severity); m_rh.set_severity_override(cur_severity, new_severity);
  endfunction

  function void set_report_severity_id_override(uvm_severity cur_severity, string id, uvm_severity new_severity);
    m_rh.set_severity_id_override(cur_severity, id, new_severity);
  endfunction




  function void set_report_handler(uvm_report_handler handler);
    m_rh = handler;
  endfunction



  function uvm_report_handler get_report_handler();
    return m_rh;
  endfunction



  function void reset_report_handler;
    m_rh.initialize();
  endfunction


`ifndef UVM_NO_DEPRECATED





  virtual function bit report_info_hook( string id, string message, int verbosity, string filename, int line);
    return 1;
  endfunction


  virtual function bit report_error_hook( string id, string message, int verbosity, string filename, int line);
    return 1;
  endfunction


  virtual function bit report_warning_hook( string id, string message, int verbosity, string filename, int line);
    return 1;
  endfunction


  virtual function bit report_fatal_hook( string id, string message, int verbosity, string filename, int line);
    return 1;
  endfunction


  virtual function bit report_hook( string id, string message, int verbosity, string filename, int line);
    return 1;
  endfunction



  virtual function void report_header(UVM_FILE file = 0);    
     uvm_root l_root;
     uvm_coreservice_t cs;
     cs = uvm_coreservice_t::get();
     l_root = cs.get_root();
     l_root.report_header(file);
  endfunction



  virtual function void report_summarize(UVM_FILE file = 0);
    uvm_report_server l_rs = uvm_report_server::get_server();
    l_rs.report_summarize(file);
  endfunction



  virtual function void die();       
     uvm_root l_root;
     uvm_coreservice_t cs;
     cs = uvm_coreservice_t::get();
     l_root = cs.get_root();
    l_root.die();
  endfunction



  function void set_report_max_quit_count(int max_count);
    uvm_report_server l_rs = uvm_report_server::get_server();
    l_rs.set_max_quit_count(max_count);
  endfunction



  function uvm_report_server get_report_server();
    uvm_report_server l_rs = uvm_report_server::get_server();
    return l_rs;
  endfunction



  function void dump_report_state();
    m_rh.dump_state();
  endfunction



  protected virtual function uvm_report_object m_get_report_object();
    return this;
  endfunction

`endif

endclass

`endif 



typedef class uvm_event;
typedef class uvm_event_pool;
typedef class uvm_component;
typedef class uvm_parent_child_link;
    
    
virtual class uvm_transaction extends uvm_object;

  const uvm_event_pool events = new;
  uvm_event#(uvm_object) begin_event;
  uvm_event#(uvm_object) end_event;
  local integer m_transaction_id = -1;
  local time    begin_time=-1;
  local time    end_time=-1;
  local time    accept_time=-1;
  local uvm_component initiator;
  local uvm_tr_stream stream_handle;
  local uvm_recorder      tr_recorder;

  function new (string name="", uvm_component initiator = null);
    super.new(name);
    this.initiator = initiator;
    m_transaction_id = -1;
    begin_event = events.get("begin");
    end_event = events.get("end");
  endfunction 
  
  virtual function void set_transaction_id(integer id);
      m_transaction_id = id;
  endfunction
  
  virtual function integer get_transaction_id();
      return (m_transaction_id);
  endfunction
  
  virtual function void set_initiator(uvm_component initiator);
    this.initiator = initiator;
  endfunction
  
  virtual function uvm_component get_initiator();
    return initiator;
  endfunction
  
  virtual function uvm_event_pool get_event_pool();
    return events;
  endfunction
  
  virtual function bit is_active();
    return (end_time == -1);
  endfunction
  
  virtual function time get_begin_time ();
    return begin_time;
  endfunction
  
  virtual function time get_end_time ();
    return end_time;
  endfunction
  
  virtual function time get_accept_time ();
    return accept_time;
  endfunction
  
  virtual protected function void do_accept_tr();
    return;
  endfunction
  
  virtual protected function void do_begin_tr();
    return;
  endfunction
  
  virtual protected function void do_end_tr();
    return;
  endfunction
  
  virtual function void do_print (uvm_printer printer);
    string str;
    uvm_component tmp_initiator; 
    super.do_print(printer);
    if(accept_time != -1)
      printer.print_time("accept_time", accept_time);
    if(begin_time != -1)
      printer.print_time("begin_time", begin_time);
    if(end_time != -1)
      printer.print_time("end_time", end_time);
    if(initiator != null) begin
      tmp_initiator = initiator;
      $swrite(str,"@%0d", tmp_initiator.get_inst_id());
      printer.print_generic("initiator", initiator.get_type_name(), -1, str);
    end
  endfunction
  
  virtual function void do_copy (uvm_object rhs);
    uvm_transaction txn;
    super.do_copy(rhs);
    if(rhs == null) return;
    if(!$cast(txn, rhs) ) return;
  
    accept_time = txn.accept_time;
    begin_time = txn.begin_time;
    end_time = txn.end_time;
    initiator = txn.initiator;
    stream_handle = txn.stream_handle;
    tr_recorder = txn.tr_recorder;
  endfunction  
  
  virtual function void do_record (uvm_recorder recorder);
    string s;
    super.do_record(recorder);
    if(accept_time != -1) 
       recorder.record_field("accept_time", accept_time, $bits(accept_time), UVM_TIME);
    if(initiator != null) begin
      uvm_recursion_policy_enum p = recorder.policy;
      recorder.policy = UVM_REFERENCE;
      recorder.record_object("initiator", initiator);
      recorder.policy = p;
    end
  endfunction
  
  virtual function integer get_tr_handle ();
     if (tr_recorder != null)
       return tr_recorder.get_handle();
     else 
       return 0;
  endfunction
  
  virtual function void disable_recording ();
     this.stream_handle = null;
  endfunction
  
  virtual function void enable_recording (uvm_tr_stream stream);
     this.stream_handle = stream;
  endfunction : enable_recording
     
  virtual function bit is_recording_enabled ();
    return (this.stream_handle != null);
  endfunction
  
  virtual function void accept_tr (time accept_time = 0);
    uvm_event#(uvm_object) e;
  
    if(accept_time != 0)
      this.accept_time = accept_time;
    else
      this.accept_time = $realtime;
  
    do_accept_tr();
    e = events.get("accept");
  
    if(e!=null) 
      e.trigger();
  endfunction
  
  virtual function integer begin_tr (time begin_time=0); 
    return m_begin_tr(begin_time);
  endfunction
  
  virtual function integer begin_child_tr (time begin_time=0, integer parent_handle=0); 
    return m_begin_tr(begin_time, parent_handle);
  endfunction
  
  
  virtual protected function integer m_begin_tr (time begin_time=0, integer parent_handle=0);
     time tmp_time = (begin_time == 0) ? $realtime : begin_time;
     uvm_recorder parent_recorder;
  
     if (parent_handle != 0)
       parent_recorder = uvm_recorder::get_recorder_from_handle(parent_handle);
     
     if (tr_recorder != null)
       end_tr(tmp_time);
  
     if(is_recording_enabled()) begin 
        uvm_tr_database db = stream_handle.get_db();
        
        this.end_time = -1;
        this.begin_time = tmp_time;
        
        if(parent_recorder == null)
          tr_recorder = stream_handle.open_recorder(get_type_name(), this.begin_time, "Begin_No_Parent, Link");
        else begin
           tr_recorder = stream_handle.open_recorder(get_type_name(), this.begin_time, "Begin_End, Link");
  
           if (tr_recorder != null)
             db.establish_link(uvm_parent_child_link::get_link(parent_recorder, tr_recorder));
        end
  
        if (tr_recorder != null)
          m_begin_tr = tr_recorder.get_handle();
        else
          m_begin_tr = 0;
     end
     else begin
        tr_recorder = null;
        this.end_time = -1;
        this.begin_time = tmp_time;
  
        m_begin_tr = 0;
     end
     
     do_begin_tr(); 
     
     begin_event.trigger();
  
  endfunction
  
  virtual function void end_tr (time end_time=0, bit free_handle=1);
     this.end_time = (end_time == 0) ? $realtime : end_time;
  
     do_end_tr(); 
  
     if(is_recording_enabled() && (tr_recorder != null)) begin
        record(tr_recorder);
  
        tr_recorder.close(this.end_time);
  
        if(free_handle) 
          begin  
             tr_recorder.free();
          end
     end 
  
     tr_recorder = null;
  
     end_event.trigger();
  endfunction

endclass


typedef class uvm_test_done_objection;
typedef class uvm_sequencer_base;
typedef class uvm_domain;
typedef class uvm_task_phase;
typedef class uvm_phase_cb;
typedef class uvm_phase_state_change;
`define UVM_PH_TRACE(ID,MSG,PH,VERB) \
   `uvm_info(ID, {$sformatf("Phase '%0s' (id=%0d) ", \
       PH.get_full_name(), PH.get_inst_id()),MSG}, VERB);


class uvm_phase extends uvm_object;

  `uvm_register_cb(uvm_phase, uvm_phase_cb)

  virtual function void exec_func(uvm_component comp, uvm_phase phase); endfunction
  virtual task exec_task(uvm_component comp, uvm_phase phase); endtask
  function uvm_objection get_objection(); return this.phase_done; endfunction

  int unsigned max_ready_to_end_iter = 20;
  protected uvm_phase_type m_phase_type;
  protected uvm_phase      m_parent;     
  uvm_phase                m_imp;        
  local uvm_phase_state    m_state;
  local int                m_run_count; 
  local process            m_phase_proc;
  int                      m_num_procs_not_yet_returned;

  virtual function void traverse(uvm_component comp, uvm_phase phase, uvm_phase_state state);
  endfunction
  virtual function void execute(uvm_component comp, uvm_phase phase);
  endfunction

  protected bit  m_predecessors[uvm_phase];
  protected bit  m_successors[uvm_phase];
  protected uvm_phase m_end_node;
  static protected bit m_executing_phases[uvm_phase];
  function uvm_phase get_begin_node(); if (m_imp != null) return this; return null; endfunction
  function uvm_phase get_end_node();   return m_end_node; endfunction
  local uvm_phase m_sync[$];  
  uvm_objection phase_done; 
  local int unsigned m_ready_to_end_count;

  function int unsigned get_ready_to_end_count();
     return m_ready_to_end_count;
  endfunction

  local bit                m_jump_bkwd;
  local bit                m_jump_fwd;
  local uvm_phase          m_jump_phase;
  local bit                m_premature_end;
  local static mailbox #(uvm_phase) m_phase_hopper = new();
  protected static bit m_phase_trace;
  local static bit m_use_ovm_run_semantic;

  function string convert2string();
    string s;
    s = $sformatf("phase: %s parent=%s  pred=%s  succ=%s",get_name(), (m_parent==null) ? "null" : get_schedule_name(), m_aa2string(m_predecessors), m_aa2string(m_successors));
    return s;
  endfunction

  local function string m_aa2string(bit aa[uvm_phase]); 
    string s;
    int i;
    s = "'{ ";
    foreach (aa[ph]) begin
      uvm_phase n = ph;
      s = {s, (n == null) ? "null" : n.get_name(), (i == aa.num()-1) ? "" : ", "};
      i++;
    end
    s = {s, " }"};
    return s;
  endfunction

  function bit is_domain();
    return (m_phase_type == UVM_PHASE_DOMAIN);
  endfunction

  virtual function void m_get_transitive_children(ref uvm_phase phases[$]);
    foreach (m_successors[succ])
    begin
        phases.push_back(succ);
        succ.m_get_transitive_children(phases);
    end
  endfunction

  function new(string name="uvm_phase", uvm_phase_type phase_type=UVM_PHASE_SCHEDULE, uvm_phase parent=null);
    super.new(name);
    m_phase_type = phase_type;
  
    if ((name == "common") && (phase_type == UVM_PHASE_DOMAIN))
      m_state = UVM_PHASE_DORMANT;
     
    m_run_count = 0;
    m_parent = parent;
  
    begin
      uvm_cmdline_processor clp = uvm_cmdline_processor::get_inst();
      string val;
      if (clp.get_arg_value("+UVM_PHASE_TRACE", val))
        m_phase_trace = 1;
      else
        m_phase_trace = 0;
      if (clp.get_arg_value("+UVM_USE_OVM_RUN_SEMANTIC", val))
        m_use_ovm_run_semantic = 1;
      else
        m_use_ovm_run_semantic = 0;
    end
  
     
    if (parent == null && (phase_type == UVM_PHASE_SCHEDULE || phase_type == UVM_PHASE_DOMAIN )) begin
      m_end_node = new({name,"_end"}, UVM_PHASE_TERMINAL, this);
      this.m_successors[m_end_node] = 1;
      m_end_node.m_predecessors[this] = 1;
    end
  
  endfunction
  
  
  
  function void add(uvm_phase phase, uvm_phase with_phase=null, uvm_phase after_phase=null, uvm_phase before_phase=null);
    uvm_phase new_node, begin_node, end_node, tmp_node;
    uvm_phase_state_change state_chg;
  
    if (phase == null)
        `uvm_fatal("PH/NULL", "add: phase argument is null")
  
    if (with_phase != null && with_phase.get_phase_type() == UVM_PHASE_IMP) begin
      string nm = with_phase.get_name();
      with_phase = find(with_phase);
      if (with_phase == null)
        `uvm_fatal("PH_BAD_ADD", {"cannot find with_phase '",nm,"' within node '",get_name(),"'"})
    end
  
    if (before_phase != null && before_phase.get_phase_type() == UVM_PHASE_IMP) begin
      string nm = before_phase.get_name();
      before_phase = find(before_phase);
      if (before_phase == null)
        `uvm_fatal("PH_BAD_ADD", {"cannot find before_phase '",nm,"' within node '",get_name(),"'"})
    end
  
    if (after_phase != null && after_phase.get_phase_type() == UVM_PHASE_IMP) begin
      string nm = after_phase.get_name();
      after_phase = find(after_phase);
      if (after_phase == null)
        `uvm_fatal("PH_BAD_ADD", {"cannot find after_phase '",nm,"' within node '",get_name(),"'"})
    end
  
    if (with_phase != null && (after_phase != null || before_phase != null))
      `uvm_fatal("PH_BAD_ADD", "cannot specify both 'with' and 'before/after' phase relationships")
  
    if (before_phase == this || after_phase == m_end_node || with_phase == m_end_node)
      `uvm_fatal("PH_BAD_ADD", "cannot add before begin node, after end node, or with end nodes")
  
    if (phase.get_phase_type() == UVM_PHASE_IMP) begin
      uvm_task_phase tp;
      new_node = new(phase.get_name(),UVM_PHASE_NODE,this);
      new_node.m_imp = phase;
      begin_node = new_node;
      end_node = new_node;
  
      if ($cast(tp, phase)) begin
         if (new_node.get_name() == "run") begin
           new_node.phase_done = uvm_test_done_objection::get();
         end
         else begin
           new_node.phase_done = uvm_objection::type_id::create({phase.get_name(), "_objection"});
         end
      end
  
    end
    else begin
      begin_node = phase;
      end_node   = phase.m_end_node;
      phase.m_parent = this;
    end
  
  
  
    if (with_phase == null && after_phase == null && before_phase == null) begin
      before_phase = m_end_node;
    end
  
  
    if (m_phase_trace) begin
      uvm_phase_type typ = phase.get_phase_type();
      `uvm_info("PH/TRC/ADD_PH", {get_name()," (",m_phase_type.name(),") ADD_PHASE: phase=",phase.get_full_name()," (", typ.name(),", inst_id=",$sformatf("%0d",phase.get_inst_id()),")", " with_phase=",   (with_phase == null)   ? "null" : with_phase.get_name(), " after_phase=",  (after_phase == null)  ? "null" : after_phase.get_name(), " before_phase=", (before_phase == null) ? "null" : before_phase.get_name(), " new_node=",     (new_node == null)     ? "null" : {new_node.get_name(), " inst_id=", $sformatf("%0d",new_node.get_inst_id())}, " begin_node=",   (begin_node == null)   ? "null" : begin_node.get_name(), " end_node=",     (end_node == null)     ? "null" : end_node.get_name()},UVM_DEBUG)
    end
  
  
    if (with_phase != null) begin
      begin_node.m_predecessors = with_phase.m_predecessors;
      end_node.m_successors = with_phase.m_successors;
      foreach (with_phase.m_predecessors[pred])
        pred.m_successors[begin_node] = 1;
      foreach (with_phase.m_successors[succ])
        succ.m_predecessors[end_node] = 1;
    end
    
    
    else if (before_phase != null && after_phase == null) begin
      begin_node.m_predecessors = before_phase.m_predecessors;
      end_node.m_successors[before_phase] = 1;
      foreach (before_phase.m_predecessors[pred]) begin
        pred.m_successors.delete(before_phase);
        pred.m_successors[begin_node] = 1;
      end
      before_phase.m_predecessors.delete();
      before_phase.m_predecessors[end_node] = 1;
    end
    
  
    else if (before_phase == null && after_phase != null) begin
      end_node.m_successors = after_phase.m_successors;
      begin_node.m_predecessors[after_phase] = 1;
      foreach (after_phase.m_successors[succ]) begin
        succ.m_predecessors.delete(after_phase);
        succ.m_predecessors[end_node] = 1;
      end
      after_phase.m_successors.delete();
      after_phase.m_successors[begin_node] = 1;
    end
    
  
    else if (before_phase != null && after_phase != null) begin
      if (!after_phase.is_before(before_phase)) begin
        `uvm_fatal("PH_ADD_PHASE",{"Phase '",before_phase.get_name(), "' is not before phase '",after_phase.get_name(),"'"})
      end
      begin_node.m_predecessors[after_phase] = 1;
      end_node.m_successors[before_phase] = 1;
      after_phase.m_successors[begin_node] = 1;
      before_phase.m_predecessors[end_node] = 1;
      if (after_phase.m_successors.exists(before_phase)) begin
        after_phase.m_successors.delete(before_phase);
        before_phase.m_successors.delete(after_phase);
      end
    end 
  
    if (new_node == null)
      tmp_node = phase;
    else
      tmp_node = new_node;
  
    state_chg = uvm_phase_state_change::type_id::create(tmp_node.get_name());
    state_chg.m_phase = tmp_node;
    state_chg.m_jump_to = null;
    state_chg.m_prev_state = tmp_node.m_state;
    tmp_node.m_state = UVM_PHASE_DORMANT;
    `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(tmp_node, state_chg)) 
  endfunction
  
  
  
  function uvm_phase get_parent();
    return m_parent;
  endfunction
  
  
  
  function uvm_phase get_imp();
    return m_imp;
  endfunction
  
  
  
  function uvm_phase get_schedule(bit hier=0);
    uvm_phase sched;
    sched = this;
    if (hier)
      while (sched.m_parent != null && (sched.m_parent.get_phase_type() == UVM_PHASE_SCHEDULE))
        sched = sched.m_parent;
    if (sched.m_phase_type == UVM_PHASE_SCHEDULE)
      return sched;
    if (sched.m_phase_type == UVM_PHASE_NODE)
      if (m_parent != null && m_parent.m_phase_type != UVM_PHASE_DOMAIN)
        return m_parent;
    return null;
  endfunction
  
  
  
  function uvm_domain get_domain();
    uvm_phase phase;
    phase = this;
    while (phase != null && phase.m_phase_type != UVM_PHASE_DOMAIN)
      phase = phase.m_parent;
    if (phase == null) 
      return null;
    if(!$cast(get_domain,phase))
        `uvm_fatal("PH/INTERNAL", "get_domain: m_phase_type is DOMAIN but $cast to uvm_domain fails")
  endfunction
  
  
    
  function string get_domain_name();
    uvm_domain domain;
    domain = get_domain();
    if (domain == null)
      return "unknown";
    return domain.get_name();
  endfunction
  
  
    
  function string get_schedule_name(bit hier=0);
    uvm_phase sched;
    string s;
    sched = get_schedule(hier);
    if (sched == null)
      return "";
    s = sched.get_name();
    while (sched.m_parent != null && sched.m_parent != sched &&
            (sched.m_parent.get_phase_type() == UVM_PHASE_SCHEDULE)) begin
      sched = sched.m_parent;
      s = {sched.get_name(),(s.len()>0?".":""),s};
    end
    return s;
  endfunction
  
  
  
  virtual function string get_full_name();
    string dom, sch;
    if (m_phase_type == UVM_PHASE_IMP)
      return get_name();
    get_full_name = get_domain_name();
    sch = get_schedule_name();
    if (sch != "")
      get_full_name = {get_full_name, ".", sch};
    if (m_phase_type != UVM_PHASE_DOMAIN && m_phase_type != UVM_PHASE_SCHEDULE)
      get_full_name = {get_full_name, ".", get_name()};
  endfunction
  
  
  
  function uvm_phase_type get_phase_type();
    return m_phase_type;
  endfunction
  
  
  
  
  function uvm_phase_state get_state();
    return m_state;
  endfunction
  
  
  function int get_run_count();
    return m_run_count;
  endfunction
  
  
  
  function void m_print_successors();
    uvm_phase found;
    static string spaces = "                                                 ";
    static int level;
    if (m_phase_type == UVM_PHASE_DOMAIN)
      level = 0;
    `uvm_info("UVM/PHASE/SUCC",$sformatf("%s%s (%s) id=%0d",spaces.substr(0,level*2),get_name(), m_phase_type.name(),get_inst_id()),UVM_NONE)
    level++;
    foreach (m_successors[succ]) begin
      succ.m_print_successors();
    end
    level--;
  endfunction
  
  
  
  function uvm_phase m_find_predecessor(uvm_phase phase, bit stay_in_scope=1, uvm_phase orig_phase=null);
    uvm_phase found;
    if (phase == null) begin
      return null ;
    end
    if (phase == m_imp || phase == this)
      return this;
    foreach (m_predecessors[pred]) begin
      uvm_phase orig;
      orig = (orig_phase==null) ? this : orig_phase;
      if (!stay_in_scope || 
          (pred.get_schedule() == orig.get_schedule()) ||
          (pred.get_domain() == orig.get_domain())) begin
        found = pred.m_find_predecessor(phase,stay_in_scope,orig);
        if (found != null)
          return found;
      end
    end
    return null;
  endfunction
  
  
  
  function uvm_phase m_find_predecessor_by_name(string name, bit stay_in_scope=1, uvm_phase orig_phase=null);
    uvm_phase found;
    if (get_name() == name)
      return this;
    foreach (m_predecessors[pred]) begin
      uvm_phase orig;
      orig = (orig_phase==null) ? this : orig_phase;
      if (!stay_in_scope || 
          (pred.get_schedule() == orig.get_schedule()) ||
          (pred.get_domain() == orig.get_domain())) begin
        found = pred.m_find_predecessor_by_name(name,stay_in_scope,orig);
        if (found != null)
          return found;
      end
    end
    return null;
  endfunction
  
  
  
  function uvm_phase m_find_successor(uvm_phase phase, bit stay_in_scope=1, uvm_phase orig_phase=null);
    uvm_phase found;
    if (phase == null) begin
      return null ;
    end
    if (phase == m_imp || phase == this) begin
      return this;
      end
    foreach (m_successors[succ]) begin
      uvm_phase orig;
      orig = (orig_phase==null) ? this : orig_phase;
      if (!stay_in_scope || 
          (succ.get_schedule() == orig.get_schedule()) ||
          (succ.get_domain() == orig.get_domain())) begin
        found = succ.m_find_successor(phase,stay_in_scope,orig);
        if (found != null) begin
          return found;
          end
      end
    end
    return null;
  endfunction
  
  
  
  function uvm_phase m_find_successor_by_name(string name, bit stay_in_scope=1, uvm_phase orig_phase=null);
    uvm_phase found;
    if (get_name() == name)
      return this;
    foreach (m_successors[succ]) begin
      uvm_phase orig;
      orig = (orig_phase==null) ? this : orig_phase;
      if (!stay_in_scope || 
          (succ.get_schedule() == orig.get_schedule()) ||
          (succ.get_domain() == orig.get_domain())) begin
        found = succ.m_find_successor_by_name(name,stay_in_scope,orig);
        if (found != null)
          return found;
      end
    end
    return null;
  endfunction
  
  
  
  function uvm_phase find(uvm_phase phase, bit stay_in_scope=1);
    if (phase == m_imp || phase == this)
      return phase;
    find = m_find_predecessor(phase,stay_in_scope,this);
    if (find == null)
      find = m_find_successor(phase,stay_in_scope,this);
  endfunction
  
  
  
  function uvm_phase find_by_name(string name, bit stay_in_scope=1);
    if (get_name() == name)
      return this;
    find_by_name = m_find_predecessor_by_name(name,stay_in_scope,this);
    if (find_by_name == null)
      find_by_name = m_find_successor_by_name(name,stay_in_scope,this);
  endfunction
  
  
    
  function bit is(uvm_phase phase);
    return (m_imp == phase || this == phase); 
  endfunction
  
    
  
  function bit is_before(uvm_phase phase);
    return (!is(phase) && m_find_successor(phase,0,this) != null);
  endfunction
  
  
    
  function bit is_after(uvm_phase phase);
    return (!is(phase) && m_find_predecessor(phase,0,this) != null);
  endfunction
  
  
  
  local task execute_phase();
  
    uvm_task_phase task_phase;
    uvm_root top;
    uvm_phase_state_change state_chg;
    uvm_coreservice_t cs;
  
    cs = uvm_coreservice_t::get();
    top = cs.get_root();
  
    foreach (m_predecessors[pred])
      wait (pred.m_state == UVM_PHASE_DONE);
  
  
    if (m_state == UVM_PHASE_DONE)
      return;
  
    state_chg = uvm_phase_state_change::type_id::create(get_name());
    state_chg.m_phase      = this;
    state_chg.m_jump_to    = null;
  
    state_chg.m_prev_state = m_state;
    m_state = UVM_PHASE_SYNCING;
    `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(this, state_chg))
    #0;
     
    if (m_sync.size()) begin
      
      foreach (m_sync[i]) begin
        wait (m_sync[i].m_state >= UVM_PHASE_SYNCING);
      end
    end
  
    m_run_count++;
  
  
    if (m_phase_trace) begin
      `UVM_PH_TRACE("PH/TRC/STRT","Starting phase",this,UVM_LOW)
    end
  
  
    if (m_phase_type != UVM_PHASE_NODE) begin
      state_chg.m_prev_state = m_state;
      m_state = UVM_PHASE_STARTED;
      `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(this, state_chg))
  
      #0;
  
      state_chg.m_prev_state = m_state;
      m_state = UVM_PHASE_EXECUTING;
      `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(this, state_chg))
  
      #0;
    end
  
  
    else begin 
  
      state_chg.m_prev_state = m_state;
      m_state = UVM_PHASE_STARTED;
      `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(this, state_chg))
  
      m_imp.traverse(top,this,UVM_PHASE_STARTED);
      m_ready_to_end_count = 0 ; 
      #0; 
  
  
      if (!$cast(task_phase,m_imp)) begin
  
        state_chg.m_prev_state = m_state;
        m_state = UVM_PHASE_EXECUTING;
        `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(this, state_chg))
  
        #0; 
        m_imp.traverse(top,this,UVM_PHASE_EXECUTING);
  
      end
      else begin
          m_executing_phases[this] = 1;
  
          state_chg.m_prev_state = m_state;
          m_state = UVM_PHASE_EXECUTING;
          `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(this, state_chg))
  
          fork : master_phase_process
            begin
    
              m_phase_proc = process::self();
    
              task_phase.traverse(top,this,UVM_PHASE_EXECUTING);
    
              wait(0); 
    
            end
          join_none
    
          uvm_wait_for_nba_region(); 
    
          fork
            begin 
            
             fork
               begin
                  wait (m_premature_end);
                  `UVM_PH_TRACE("PH/TRC/EXE/JUMP","PHASE EXIT ON JUMP REQUEST",this,UVM_DEBUG)
               end
    
               begin
                 bit do_ready_to_end  ; 
                 if (phase_done.get_objection_total(top) ||
                     m_use_ovm_run_semantic && m_imp.get_name() == "run") begin
                   if (!phase_done.m_top_all_dropped)
                     phase_done.wait_for(UVM_ALL_DROPPED, top);
                   `UVM_PH_TRACE("PH/TRC/EXE/ALLDROP","PHASE EXIT ALL_DROPPED",this,UVM_DEBUG)
                 end
                 else begin
                    if (m_phase_trace) `UVM_PH_TRACE("PH/TRC/SKIP","No objections raised, skipping phase",this,UVM_LOW)
                 end
                 
                 wait_for_self_and_siblings_to_drop() ;
                 do_ready_to_end = 1;
                    
   
                 while (do_ready_to_end) begin
                   uvm_wait_for_nba_region();  
                   `UVM_PH_TRACE("PH_READY_TO_END","PHASE READY TO END",this,UVM_DEBUG)
                   m_ready_to_end_count++;
                   if (m_phase_trace)
                     `UVM_PH_TRACE("PH_READY_TO_END_CB","CALLING READY_TO_END CB",this,UVM_HIGH)
                   state_chg.m_prev_state = m_state;
                   m_state = UVM_PHASE_READY_TO_END;
                   `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(this, state_chg))
                   if (m_imp != null)
                     m_imp.traverse(top,this,UVM_PHASE_READY_TO_END);
                    
                   uvm_wait_for_nba_region();  
  
                   wait_for_self_and_siblings_to_drop();
                   do_ready_to_end = (m_state == UVM_PHASE_EXECUTING) && (m_ready_to_end_count < max_ready_to_end_iter) ; 
                 end
               end
    
               begin
                 if (this.get_name() == "run") begin
                    if (top.phase_timeout == 0)
                      wait(top.phase_timeout != 0);
                    if (m_phase_trace)
                      `UVM_PH_TRACE("PH/TRC/TO_WAIT", $sformatf("STARTING PHASE TIMEOUT WATCHDOG (timeout == %t)", top.phase_timeout), this, UVM_HIGH)
                    `uvm_delay(top.phase_timeout)
                    if ($time == `UVM_DEFAULT_TIMEOUT) begin
                       if (m_phase_trace)
                         `UVM_PH_TRACE("PH/TRC/TIMEOUT", "PHASE TIMEOUT WATCHDOG EXPIRED", this, UVM_LOW)
                       foreach (m_executing_phases[p]) begin
                          if ((p.phase_done != null) && (p.phase_done.get_objection_total() > 0)) begin
                             if (m_phase_trace)
                               `UVM_PH_TRACE("PH/TRC/TIMEOUT/OBJCTN", $sformatf("Phase '%s' has outstanding objections:\n%s", p.get_full_name(), p.phase_done.convert2string()), this, UVM_LOW)
                          end
                       end
                          
                       `uvm_fatal("PH_TIMEOUT", $sformatf("Default timeout of %0t hit, indicating a probable testbench issue", `UVM_DEFAULT_TIMEOUT)) end
                    else begin
                       if (m_phase_trace)
                         `UVM_PH_TRACE("PH/TRC/TIMEOUT", "PHASE TIMEOUT WATCHDOG EXPIRED", this, UVM_LOW)
                       foreach (m_executing_phases[p]) begin
                          if ((p.phase_done != null) && (p.phase_done.get_objection_total() > 0)) begin
                             if (m_phase_trace)
                               `UVM_PH_TRACE("PH/TRC/TIMEOUT/OBJCTN", $sformatf("Phase '%s' has outstanding objections:\n%s", p.get_full_name(), p.phase_done.convert2string()), this, UVM_LOW)
                          end
                       end
                          
                       `uvm_fatal("PH_TIMEOUT", $sformatf("Explicit timeout of %0t hit, indicating a probable testbench issue", top.phase_timeout))
                    end
                    if (m_phase_trace)
                      `UVM_PH_TRACE("PH/TRC/EXE/3","PHASE EXIT TIMEOUT",this,UVM_DEBUG)
                 end 
                 else begin
                    wait (0); 
                 end
               end 
  
    
             join_any
             disable fork;
          
            end
    
          join 
  
      end
  
    end
  
    m_executing_phases.delete(this);
  
  
  
    if (m_phase_type == UVM_PHASE_NODE) begin
  
      if(m_premature_end) begin
        if(m_jump_phase != null) begin 
          state_chg.m_jump_to = m_jump_phase;
        
          `uvm_info("PH_JUMP",
                $sformatf("phase %s (schedule %s, domain %s) is jumping to phase %s", get_name(), get_schedule_name(), get_domain_name(), m_jump_phase.get_name()), UVM_MEDIUM);
        end
        else begin
          `uvm_info("PH_JUMP",
                $sformatf("phase %s (schedule %s, domain %s) is ending prematurely", get_name(), get_schedule_name(), get_domain_name()), UVM_MEDIUM);
        end
    
    
        if (m_phase_trace)
          `UVM_PH_TRACE("PH_END","ENDING PHASE PREMATURELY",this,UVM_HIGH)
      end
      else begin
        if (task_phase == null)
          m_wait_for_pred();
      end
    
      if (m_phase_trace)
        `UVM_PH_TRACE("PH_END","ENDING PHASE",this,UVM_HIGH)
      state_chg.m_prev_state = m_state;
      m_state = UVM_PHASE_ENDED;
      `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(this, state_chg))
      if (m_imp != null)
        m_imp.traverse(top,this,UVM_PHASE_ENDED);
      #0; 
    
    
      state_chg.m_prev_state = m_state;
      if(m_premature_end) m_state = UVM_PHASE_JUMPING;
      else m_state = UVM_PHASE_CLEANUP ;
      `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(this, state_chg))
      if (m_phase_proc != null) begin
        m_phase_proc.kill();
        m_phase_proc = null;
      end
      #0; 
      if (phase_done != null)
        phase_done.clear();
    end
  
    m_premature_end = 0 ;
    if(m_jump_fwd || m_jump_bkwd) begin
      if(m_jump_fwd) begin
        clear_successors(UVM_PHASE_DONE,m_jump_phase);
      end
      m_jump_phase.clear_successors();
    end
    else begin
  
      if (m_phase_trace)
        `UVM_PH_TRACE("PH/TRC/DONE","Completed phase",this,UVM_LOW)
      state_chg.m_prev_state = m_state;
      m_state = UVM_PHASE_DONE;
      `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(this, state_chg))
      m_phase_proc = null;
      #0; 
    end
    #0; 
    if (phase_done != null)
      phase_done.clear();
  
    if(m_jump_fwd || m_jump_bkwd) begin
      void'(m_phase_hopper.try_put(m_jump_phase));
      m_jump_phase = null;
      m_jump_fwd = 0;
      m_jump_bkwd = 0;
    end
    else if (m_successors.size() == 0) begin
      top.m_phase_all_done=1;
    end 
    else begin
      foreach (m_successors[succ]) begin
        if(succ.m_state < UVM_PHASE_SCHEDULED) begin
          state_chg.m_prev_state = succ.m_state;
          state_chg.m_phase = succ;
          succ.m_state = UVM_PHASE_SCHEDULED;
          `uvm_do_callbacks(uvm_phase, uvm_phase_cb, phase_state_change(succ, state_chg))
          #0; 
          void'(m_phase_hopper.try_put(succ));
          if (m_phase_trace)
            `UVM_PH_TRACE("PH/TRC/SCHEDULED",{"Scheduled from phase ",get_full_name()},succ,UVM_LOW)
        end
      end
    end
  
  endtask
  
  function void get_adjacent_predecessor_nodes(ref uvm_phase pred[]);
     bit done;
     bit predecessors[uvm_phase];
     int idx;
  
     foreach (m_predecessors[p])
       predecessors[p] = 1;
  
     do begin
        done = 1;
        foreach (predecessors[p]) begin
           if (p.get_phase_type() != UVM_PHASE_NODE) begin
              predecessors.delete(p);
              foreach (p.m_predecessors[next_p])
                predecessors[next_p] = 1;
              done = 0;
           end
        end
     end while (!done); 
  
     pred = new [predecessors.size()];
     foreach (predecessors[p]) begin
        pred[idx++] = p;
     end
  endfunction : get_adjacent_predecessor_nodes
  
  function void get_adjacent_successor_nodes(ref uvm_phase succ[]);
     bit done;
     bit successors[uvm_phase];
     int idx;
  
     foreach (m_successors[s])
       successors[s] = 1;
  
     do begin
        done = 1;
        foreach (successors[s]) begin
           if (s.get_phase_type() != UVM_PHASE_NODE) begin
              successors.delete(s);
              foreach (s.m_successors[next_s])
                successors[next_s] = 1;
              done = 0;
           end
        end
     end while (!done); 
  
     succ = new [successors.size()];
     foreach (successors[s]) begin
        succ[idx++] = s;
     end
  endfunction : get_adjacent_successor_nodes
  
  local function void get_predecessors_for_successors(output bit pred_of_succ[uvm_phase]);
      bit done;
      uvm_phase successors[];
  
      get_adjacent_successor_nodes(successors);
            
      foreach (successors[s])
        foreach (successors[s].m_predecessors[pred])
          pred_of_succ[pred] = 1;
      
      do begin
        done=1;
        foreach (pred_of_succ[pred]) begin
          if (pred.get_phase_type() != UVM_PHASE_NODE) begin
            pred_of_succ.delete(pred); 
            foreach (pred.m_predecessors[next_pred])
              pred_of_succ[next_pred] = 1;
            done =0;
          end
        end
      end while (!done);
  
  
      pred_of_succ.delete(this);
  endfunction
  
  
  
  local task m_wait_for_pred();
  
      bit pred_of_succ[uvm_phase];
      get_predecessors_for_successors(pred_of_succ);
  
      foreach (pred_of_succ[sibling]) begin
  
        if (m_phase_trace) begin
          string s;
          s = $sformatf("Waiting for phase '%s' (%0d) to be READY_TO_END. Current state is %s", sibling.get_name(),sibling.get_inst_id(),sibling.m_state.name()); `UVM_PH_TRACE("PH/TRC/WAIT_PRED_OF_SUCC",s,this,UVM_HIGH)
        end
  
        sibling.wait_for_state(UVM_PHASE_READY_TO_END, UVM_GTE);
  
        if (m_phase_trace) begin
          string s;
          s = $sformatf("Phase '%s' (%0d) is now READY_TO_END. Releasing phase", sibling.get_name(),sibling.get_inst_id()); `UVM_PH_TRACE("PH/TRC/WAIT_PRED_OF_SUCC",s,this,UVM_HIGH)
        end
  
      end
  
      if (m_phase_trace) begin
        if (pred_of_succ.num()) begin
          string s = "( ";
          foreach (pred_of_succ[pred])
            s = {s, pred.get_full_name()," "};
          s = {s, ")"};
          `UVM_PH_TRACE("PH/TRC/WAIT_PRED_OF_SUCC", {"*** All pred to succ ",s," in READY_TO_END state, so ending phase ***"},this,UVM_HIGH)
        end
        else begin
          `UVM_PH_TRACE("PH/TRC/WAIT_PRED_OF_SUCC", "*** No pred to succ other than myself, so ending phase ***",this,UVM_HIGH)
        end
      end
  
    #0; 
  
  endtask
  
  
  
  function void m_report_null_objection(uvm_object obj, string description, int count, string action);
     string m_action;
     string m_addon;
     string m_obj_name = (obj == null) ? "uvm_top" : obj.get_full_name();
     
     if ((action == "raise") || (action == "drop")) begin
        if (count != 1)
          m_action = $sformatf("%s %0d objections", action, count);
        else
          m_action = $sformatf("%s an objection", action); 
     end
     else if (action == "get_objection_count") begin
        m_action = "call get_objection_count";
     end
  
     if (this.get_phase_type() == UVM_PHASE_IMP) begin
        m_addon = " (This is a UVM_PHASE_IMP, you have to query the schedule to find the UVM_PHASE_NODE)";
     end
     
     `uvm_error("UVM/PH/NULL_OBJECTION", $sformatf("'%s' attempted to %s on '%s', however '%s' is not a task-based phase node! %s", m_obj_name, m_action, get_name(), get_name(), m_addon))
  endfunction : m_report_null_objection
                          
     
  
  virtual function void raise_objection (uvm_object obj, string description="", int count=1);
    if (phase_done != null)
      phase_done.raise_objection(obj,description,count);
    else
      m_report_null_objection(obj, description, count, "raise");
  endfunction
  
  
  
  virtual function void drop_objection (uvm_object obj, string description="", int count=1);
    if (phase_done != null)
      phase_done.drop_objection(obj,description,count);
    else
      m_report_null_objection(obj, description, count, "drop");
  endfunction
  
  
  virtual function int get_objection_count (uvm_object obj=null);
     if (phase_done != null)
       return phase_done.get_objection_count(obj);
     else begin
        m_report_null_objection(obj, "" , 0, "get_objection_count");
        return 0;
     end
  endfunction : get_objection_count
  
  
  function void sync(uvm_domain target, uvm_phase phase=null, uvm_phase with_phase=null);
    if (!this.is_domain()) begin
      `uvm_fatal("PH_BADSYNC","sync() called from a non-domain phase schedule node");
    end
    else if (target == null) begin
      `uvm_fatal("PH_BADSYNC","sync() called with a null target domain");
    end
    else if (!target.is_domain()) begin
      `uvm_fatal("PH_BADSYNC","sync() called with a non-domain phase schedule node as target");
    end
    else if (phase == null && with_phase != null) begin
      `uvm_fatal("PH_BADSYNC","sync() called with null phase and non-null with phase");
    end
    else if (phase == null) begin
      int visited[uvm_phase];
      uvm_phase queue[$];
      queue.push_back(this);
      visited[this] = 1;
      while (queue.size()) begin
        uvm_phase node;
        node = queue.pop_front();
        if (node.m_imp != null) begin
          sync(target, node.m_imp);
        end
        foreach (node.m_successors[succ]) begin
          if (!visited.exists(succ)) begin
            queue.push_back(succ);
            visited[succ] = 1;
          end
        end
      end
    end else begin
      uvm_phase from_node, to_node;
      int found_to[$], found_from[$];
      if(with_phase == null) with_phase = phase;
      from_node = find(phase);
      to_node = target.find(with_phase);
      if(from_node == null || to_node == null) return;
      found_to = from_node.m_sync.find_index(node) with (node == to_node);
      found_from = to_node.m_sync.find_index(node) with (node == from_node);
      if (found_to.size() == 0) from_node.m_sync.push_back(to_node);
      if (found_from.size() == 0) to_node.m_sync.push_back(from_node);
    end
  endfunction
  
  
  
  function void unsync(uvm_domain target, uvm_phase phase=null, uvm_phase with_phase=null);
    if (!this.is_domain()) begin
      `uvm_fatal("PH_BADSYNC","unsync() called from a non-domain phase schedule node");
    end else if (target == null) begin
      `uvm_fatal("PH_BADSYNC","unsync() called with a null target domain");
    end else if (!target.is_domain()) begin
      `uvm_fatal("PH_BADSYNC","unsync() called with a non-domain phase schedule node as target");
    end else if (phase == null && with_phase != null) begin
      `uvm_fatal("PH_BADSYNC","unsync() called with null phase and non-null with phase");
    end else if (phase == null) begin
      int visited[uvm_phase];
      uvm_phase queue[$];
      queue.push_back(this);
      visited[this] = 1;
      while (queue.size()) begin
        uvm_phase node;
        node = queue.pop_front();
        if (node.m_imp != null) unsync(target,node.m_imp);
        foreach (node.m_successors[succ]) begin
          if (!visited.exists(succ)) begin
            queue.push_back(succ);
            visited[succ] = 1;
          end
        end
      end
    end else begin
      uvm_phase from_node, to_node;
      int found_to[$], found_from[$];
      if(with_phase == null) with_phase = phase;
      from_node = find(phase);
      to_node = target.find(with_phase);
      if(from_node == null || to_node == null) return;
      found_to = from_node.m_sync.find_index(node) with (node == to_node);
      found_from = to_node.m_sync.find_index(node) with (node == from_node);
      if (found_to.size()) from_node.m_sync.delete(found_to[0]);
      if (found_from.size()) to_node.m_sync.delete(found_from[0]);
    end
  endfunction
  
  
    
  task wait_for_state(uvm_phase_state state, uvm_wait_op op=UVM_EQ);
    case (op)
      UVM_EQ:  wait((state&m_state) != 0);
      UVM_NE:  wait((state&m_state) == 0);
      UVM_LT:  wait(m_state <  state);
      UVM_LTE: wait(m_state <= state);
      UVM_GT:  wait(m_state >  state);
      UVM_GTE: wait(m_state >= state);
    endcase
  endtask
  
  
  
  
  function void set_jump_phase(uvm_phase phase) ;
    uvm_phase d;
  
    if ((m_state <  UVM_PHASE_STARTED) ||
        (m_state >  UVM_PHASE_ENDED) )
    begin
     `uvm_error("JMPPHIDL", { "Attempting to jump from phase \"", get_name(), "\" which is not currently active (current state is ", m_state.name(), "). The jump will not happen until the phase becomes ", "active."})
    end
  
  
  
  
    d = m_find_predecessor(phase,0);
    if (d == null) begin
      d = m_find_successor(phase,0);
      if (d == null) begin
        string msg;
        $sformat(msg,{"phase %s is neither a predecessor or successor of ", "phase %s or is non-existant, so we cannot jump to it.  ", "Phase control flow is now undefined so the simulation ", "must terminate"}, phase.get_name(), get_name());
        `uvm_fatal("PH_BADJUMP", msg);
      end
      else begin
        m_jump_fwd = 1;
        `uvm_info("PH_JUMPF",$sformatf("jumping forward to phase %s", phase.get_name()), UVM_DEBUG);
      end
    end
    else begin
      m_jump_bkwd = 1;
      `uvm_info("PH_JUMPB",$sformatf("jumping backward to phase %s", phase.get_name()), UVM_DEBUG);
    end
    
    m_jump_phase = d;
  endfunction
  
  
  function void end_prematurely() ;
     m_premature_end = 1 ;
  endfunction
  
  
  function void jump(uvm_phase phase);
     set_jump_phase(phase) ;
     end_prematurely() ;
  endfunction
  
  
  static function void jump_all(uvm_phase phase);
      `uvm_warning("NOTIMPL","jump_all is not implemented and has been replaced by uvm_domain::jump_all")
  endfunction
  
  
    
  function uvm_phase get_jump_target();
    return m_jump_phase;
  endfunction
  
  
  function void clear(uvm_phase_state state = UVM_PHASE_DORMANT);
    m_state = state;
    m_phase_proc = null;
    if (phase_done != null)
      phase_done.clear(this);
  endfunction
  
  
  function void clear_successors(uvm_phase_state state = UVM_PHASE_DORMANT, 
      uvm_phase end_state=null);
    if(this == end_state) 
      return;
    clear(state);
    foreach(m_successors[succ]) begin
      succ.clear_successors(state, end_state);
    end
  endfunction
  
  
  local task wait_for_self_and_siblings_to_drop() ;
    bit need_to_check_all = 1 ;
    uvm_root top;
    uvm_coreservice_t cs;
    bit siblings[uvm_phase];
    
    cs = uvm_coreservice_t::get();
    top = cs.get_root();
    
    get_predecessors_for_successors(siblings);
    foreach (m_sync[i]) begin
      siblings[m_sync[i]] = 1;
    end
  
    while (need_to_check_all) begin
      need_to_check_all = 0 ; 
  
      if ((phase_done != null) && (phase_done.get_objection_total(top) != 0)) begin 
        m_state = UVM_PHASE_EXECUTING ;
        phase_done.wait_for(UVM_ALL_DROPPED, top);
        need_to_check_all = 1 ;
      end
  
      foreach(siblings[sib]) begin
        sib.wait_for_state(UVM_PHASE_EXECUTING, UVM_GTE);  
        if ((sib.phase_done != null) && (sib.phase_done.get_objection_total(top) != 0)) begin
          m_state = UVM_PHASE_EXECUTING ;
          sib.phase_done.wait_for(UVM_ALL_DROPPED, top); 
          need_to_check_all = 1 ;
        end
      end
    end
  endtask
  
  
  function void kill();
  
    `uvm_info("PH_KILL", {"killing phase '", get_name(),"'"}, UVM_DEBUG);
  
    if (m_phase_proc != null) begin
      m_phase_proc.kill();
      m_phase_proc = null;
    end
  
  endfunction
  
  
  
  function void kill_successors();
    foreach (m_successors[succ])
      succ.kill_successors();
    kill();
  endfunction
  
  
  
  static task m_run_phases();
    uvm_root top;
    uvm_coreservice_t cs;
    cs = uvm_coreservice_t::get();
    top = cs.get_root();
  
    begin
      uvm_phase ph = uvm_domain::get_common_domain();
      void'(m_phase_hopper.try_put(ph));
    end
  
    forever begin
      uvm_phase phase;
      m_phase_hopper.get(phase);
      fork
        begin
          phase.execute_phase();
        end
      join_none
      #0;  
    end
  endtask
  
  
  
  local function void m_terminate_phase();
    if (phase_done != null)
      phase_done.clear(this);
  endfunction
  
  
  
  local function void m_print_termination_state();
    uvm_root top;
    uvm_coreservice_t cs;
    cs = uvm_coreservice_t::get();
    top = cs.get_root();
    if (phase_done != null) begin
      `uvm_info("PH_TERMSTATE", $sformatf("phase %s outstanding objections = %0d", get_name(), phase_done.get_objection_total(top)), UVM_DEBUG)
    end
    else begin
      `uvm_info("PH_TERMSTATE", $sformatf("phase %s has no outstanding objections", get_name()), UVM_DEBUG)
    end
  endfunction

endclass



class uvm_phase_state_change extends uvm_object;

  `uvm_object_utils(uvm_phase_state_change)

  uvm_phase       m_phase;
  uvm_phase_state m_prev_state;
  uvm_phase       m_jump_to;
  
  function new(string name = "uvm_phase_state_change");
    super.new(name);
  endfunction

  virtual function uvm_phase_state get_state();
    return m_phase.get_state();
  endfunction
  
  virtual function uvm_phase_state get_prev_state();
    return m_prev_state;
  endfunction

  function uvm_phase jump_to();
    return m_jump_to;
  endfunction

endclass



class uvm_phase_cb extends uvm_callback;

  function new(string name="unnamed-uvm_phase_cb");
     super.new(name);
  endfunction : new
   
  virtual function void phase_state_change(uvm_phase phase, uvm_phase_state_change change);
  endfunction
endclass

typedef uvm_callbacks#(uvm_phase, uvm_phase_cb) uvm_phase_cb_pool;


typedef class uvm_cmdline_processor;

typedef class uvm_build_phase;
typedef class uvm_connect_phase;
typedef class uvm_end_of_elaboration_phase;
typedef class uvm_start_of_simulation_phase;
typedef class uvm_run_phase;
typedef class uvm_extract_phase;
typedef class uvm_check_phase;
typedef class uvm_report_phase;
typedef class uvm_final_phase;
typedef class uvm_pre_reset_phase;
typedef class uvm_reset_phase;
typedef class uvm_post_reset_phase;
typedef class uvm_pre_configure_phase;
typedef class uvm_configure_phase;
typedef class uvm_post_configure_phase;
typedef class uvm_pre_main_phase;
typedef class uvm_main_phase;
typedef class uvm_post_main_phase;
typedef class uvm_pre_shutdown_phase;
typedef class uvm_shutdown_phase;
typedef class uvm_post_shutdown_phase;

uvm_phase build_ph;
uvm_phase connect_ph;
uvm_phase end_of_elaboration_ph;
uvm_phase start_of_simulation_ph;
uvm_phase run_ph;
uvm_phase extract_ph;
uvm_phase check_ph;
uvm_phase report_ph;
   

class uvm_domain extends uvm_phase;

  static local uvm_domain m_common_domain;
  static local uvm_domain m_uvm_domain; 
  static local uvm_domain m_domains[string];
  static local uvm_phase m_uvm_schedule;


  static function void get_domains(output uvm_domain domains[string]);
    domains = m_domains;
  endfunction 


  static function uvm_phase get_uvm_schedule();
    void'(get_uvm_domain());
    return m_uvm_schedule;
  endfunction 


  static function uvm_domain get_common_domain();

    uvm_domain domain;
    uvm_phase schedule;

    if (m_common_domain != null)
      return m_common_domain;

    domain = new("common");
    domain.add(uvm_build_phase::get());
    domain.add(uvm_connect_phase::get());
    domain.add(uvm_end_of_elaboration_phase::get());
    domain.add(uvm_start_of_simulation_phase::get());
    domain.add(uvm_run_phase::get());
    domain.add(uvm_extract_phase::get());
    domain.add(uvm_check_phase::get());
    domain.add(uvm_report_phase::get());
    domain.add(uvm_final_phase::get());
    m_domains["common"] = domain;

    build_ph               = domain.find(uvm_build_phase::get());
    connect_ph             = domain.find(uvm_connect_phase::get());
    end_of_elaboration_ph  = domain.find(uvm_end_of_elaboration_phase::get());
    start_of_simulation_ph = domain.find(uvm_start_of_simulation_phase::get());
    run_ph                 = domain.find(uvm_run_phase::get());   
    extract_ph             = domain.find(uvm_extract_phase::get());
    check_ph               = domain.find(uvm_check_phase::get());
    report_ph              = domain.find(uvm_report_phase::get());
    m_common_domain = domain;

    domain = get_uvm_domain();
    m_common_domain.add(domain, .with_phase(m_common_domain.find(uvm_run_phase::get())));
    return m_common_domain;

  endfunction


  static function void add_uvm_phases(uvm_phase schedule);

    schedule.add(uvm_pre_reset_phase::get());
    schedule.add(uvm_reset_phase::get());
    schedule.add(uvm_post_reset_phase::get());
    schedule.add(uvm_pre_configure_phase::get());
    schedule.add(uvm_configure_phase::get());
    schedule.add(uvm_post_configure_phase::get());
    schedule.add(uvm_pre_main_phase::get());
    schedule.add(uvm_main_phase::get());
    schedule.add(uvm_post_main_phase::get());
    schedule.add(uvm_pre_shutdown_phase::get());
    schedule.add(uvm_shutdown_phase::get());
    schedule.add(uvm_post_shutdown_phase::get());

  endfunction


  static function uvm_domain get_uvm_domain();
  
    if (m_uvm_domain == null) begin
      m_uvm_domain = new("uvm");
      m_uvm_schedule = new("uvm_sched", UVM_PHASE_SCHEDULE);
      add_uvm_phases(m_uvm_schedule);
      m_uvm_domain.add(m_uvm_schedule);
    end
    return m_uvm_domain;
  endfunction


  function new(string name);
    super.new(name,UVM_PHASE_DOMAIN);
    if (m_domains.exists(name))
      `uvm_error("UNIQDOMNAM", $sformatf("Domain created with non-unique name '%s'", name))
    m_domains[name] = this;
  endfunction

  function void jump(uvm_phase phase);
    uvm_phase phases[$];

    m_get_transitive_children(phases);
    
    phases = phases.find(item) with (item.get_state() inside {[UVM_PHASE_STARTED:UVM_PHASE_CLEANUP]}); 
    
    foreach(phases[idx]) 
        if(phases[idx].is_before(phase) || phases[idx].is_after(phase))
            phases[idx].jump(phase);        
    
  endfunction

  static function void jump_all(uvm_phase phase);
    uvm_domain domains[string];
    
    uvm_domain::get_domains(domains);
           
    foreach(domains[idx])      
        domains[idx].jump(phase);        
    
   endfunction
endclass



virtual class uvm_bottomup_phase extends uvm_phase;

  function new(string name);
    super.new(name,UVM_PHASE_IMP);
  endfunction


  virtual function void traverse(uvm_component comp, uvm_phase phase, uvm_phase_state state);
    string name;
    uvm_domain phase_domain =phase.get_domain();
    uvm_domain comp_domain = comp.get_domain();

    if (comp.get_first_child(name))
      do
        traverse(comp.get_child(name), phase, state);
      while(comp.get_next_child(name));

    if (m_phase_trace)
    `uvm_info("PH_TRACE",$sformatf("bottomup-phase phase=%s state=%s comp=%s comp.domain=%s phase.domain=%s", phase.get_name(), state.name(), comp.get_full_name(),comp_domain.get_name(),phase_domain.get_name()), UVM_DEBUG)

    if (phase_domain == uvm_domain::get_common_domain() ||
        phase_domain == comp_domain) begin
      case (state)
        UVM_PHASE_STARTED: begin
          comp.m_current_phase = phase;
          comp.m_apply_verbosity_settings(phase);
          comp.phase_started(phase);
          end
        UVM_PHASE_EXECUTING: begin
          uvm_phase ph = this; 
          if (comp.m_phase_imps.exists(this))
            ph = comp.m_phase_imps[this];
          ph.execute(comp, phase);
          end
        UVM_PHASE_READY_TO_END: begin
          comp.phase_ready_to_end(phase);
          end
        UVM_PHASE_ENDED: begin
          comp.phase_ended(phase);
          comp.m_current_phase = null;
          end
        default:
          `uvm_fatal("PH_BADEXEC","bottomup phase traverse internal error")
      endcase
    end
  endfunction


  virtual function void execute(uvm_component comp, uvm_phase phase);
    process proc = process::self();
    proc.srandom(uvm_create_random_seed(phase.get_type_name(), comp.get_full_name()));

    comp.m_current_phase = phase;
    exec_func(comp,phase);
  endfunction

endclass




virtual class uvm_topdown_phase extends uvm_phase;


  function new(string name);
    super.new(name,UVM_PHASE_IMP);
  endfunction


  virtual function void traverse(uvm_component comp, uvm_phase phase, uvm_phase_state state);
    string name;
    uvm_domain phase_domain = phase.get_domain();
    uvm_domain comp_domain = comp.get_domain();

    if (m_phase_trace)
    `uvm_info("PH_TRACE",$sformatf("topdown-phase phase=%s state=%s comp=%s comp.domain=%s phase.domain=%s", phase.get_name(), state.name(), comp.get_full_name(),comp_domain.get_name(),phase_domain.get_name()), UVM_DEBUG)

    if (phase_domain == uvm_domain::get_common_domain() ||
        phase_domain == comp_domain) begin
        case (state)
          UVM_PHASE_STARTED: begin
            comp.m_current_phase = phase;
            comp.m_apply_verbosity_settings(phase);
            comp.phase_started(phase);
            end
          UVM_PHASE_EXECUTING: begin
            if (!(phase.get_name() == "build" && comp.m_build_done)) begin
              uvm_phase ph = this; 
              comp.m_phasing_active++;
              if (comp.m_phase_imps.exists(this))
                ph = comp.m_phase_imps[this];
              ph.execute(comp, phase);
              comp.m_phasing_active--;
            end
            end
          UVM_PHASE_READY_TO_END: begin
            comp.phase_ready_to_end(phase);
            end
          UVM_PHASE_ENDED: begin
            comp.phase_ended(phase);
            comp.m_current_phase = null;
            end
          default:
            `uvm_fatal("PH_BADEXEC","topdown phase traverse internal error")
        endcase
    end
    if(comp.get_first_child(name))
      do
        traverse(comp.get_child(name), phase, state);
      while(comp.get_next_child(name));
  endfunction


  virtual function void execute(uvm_component comp, uvm_phase phase);
    process proc = process::self();
    proc.srandom(uvm_create_random_seed(phase.get_type_name(), comp.get_full_name()));

    comp.m_current_phase = phase;
    exec_func(comp,phase);
  endfunction

endclass



virtual class uvm_task_phase extends uvm_phase;


  function new(string name);
    super.new(name,UVM_PHASE_IMP);
  endfunction


  virtual function void traverse(uvm_component comp, uvm_phase phase, uvm_phase_state state);
    phase.m_num_procs_not_yet_returned = 0;
    m_traverse(comp, phase, state);
  endfunction

  function void m_traverse(uvm_component comp, uvm_phase phase, uvm_phase_state state);
    string name;
    uvm_domain phase_domain =phase.get_domain();
    uvm_domain comp_domain = comp.get_domain();
    uvm_sequencer_base seqr;
    
    if (comp.get_first_child(name))
      do
        m_traverse(comp.get_child(name), phase, state);
      while(comp.get_next_child(name));

    if (m_phase_trace)
    `uvm_info("PH_TRACE",$sformatf("topdown-phase phase=%s state=%s comp=%s comp.domain=%s phase.domain=%s", phase.get_name(), state.name(), comp.get_full_name(),comp_domain.get_name(),phase_domain.get_name()), UVM_DEBUG)

    if (phase_domain == uvm_domain::get_common_domain() ||
        phase_domain == comp_domain) begin
      case (state)
        UVM_PHASE_STARTED: begin
          comp.m_current_phase = phase;
          comp.m_apply_verbosity_settings(phase);
          comp.phase_started(phase);
          if ($cast(seqr, comp))
            seqr.start_phase_sequence(phase);
          end
        UVM_PHASE_EXECUTING: begin
          uvm_phase ph = this; 
          if (comp.m_phase_imps.exists(this))
            ph = comp.m_phase_imps[this];
          ph.execute(comp, phase);
          end
        UVM_PHASE_READY_TO_END: begin
          comp.phase_ready_to_end(phase);
          end
        UVM_PHASE_ENDED: begin
          if ($cast(seqr, comp))
            seqr.stop_phase_sequence(phase);
          comp.phase_ended(phase);
          comp.m_current_phase = null;
          end
        default:
          `uvm_fatal("PH_BADEXEC","task phase traverse internal error")
      endcase
    end

  endfunction


  virtual function void execute(uvm_component comp, uvm_phase phase);

    fork
      begin
        process proc;

        proc = process::self();
        proc.srandom(uvm_create_random_seed(phase.get_type_name(), comp.get_full_name()));

        phase.m_num_procs_not_yet_returned++;

        exec_task(comp,phase);

        phase.m_num_procs_not_yet_returned--;

      end
    join_none

  endfunction
endclass




class uvm_build_phase extends uvm_topdown_phase;
   virtual function void exec_func(uvm_component comp, uvm_phase phase);
      comp.build_phase(phase); 
   endfunction
   local static uvm_build_phase m_inst;
   static const string type_name = "uvm_build_phase";

   static function uvm_build_phase get();
      if(m_inst == null)
         m_inst = new();
      return m_inst; 
   endfunction
   protected function new(string name="build");
      super.new(name); 
   endfunction
   virtual function string get_type_name();
      return type_name;
   endfunction
endclass


class uvm_connect_phase extends uvm_bottomup_phase;
   virtual function void exec_func(uvm_component comp, uvm_phase phase);
      comp.connect_phase(phase); 
   endfunction
   local static uvm_connect_phase m_inst;
   static const string type_name = "uvm_connect_phase";

   static function uvm_connect_phase get();
      if(m_inst == null)
         m_inst = new();
      return m_inst; 
   endfunction
   protected function new(string name="connect");
      super.new(name); 
   endfunction
   virtual function string get_type_name();
      return type_name;
   endfunction
endclass


class uvm_end_of_elaboration_phase extends uvm_bottomup_phase;
   virtual function void exec_func(uvm_component comp, uvm_phase phase);
      comp.end_of_elaboration_phase(phase); 
   endfunction
   local static uvm_end_of_elaboration_phase m_inst;
   static const string type_name = "uvm_end_of_elaboration_phase";

   static function uvm_end_of_elaboration_phase get();
      if(m_inst == null) begin 
         m_inst = new();
      end
      return m_inst; 
   endfunction
   protected function new(string name="end_of_elaboration");
      super.new(name); 
   endfunction
   virtual function string get_type_name();
      return type_name;
   endfunction
endclass



class uvm_start_of_simulation_phase extends uvm_bottomup_phase;
   virtual function void exec_func(uvm_component comp, uvm_phase phase);
      comp.start_of_simulation_phase(phase); 
   endfunction
   local static uvm_start_of_simulation_phase m_inst;
   static const string type_name = "uvm_start_of_simulation_phase";

   static function uvm_start_of_simulation_phase get();
      if(m_inst == null)
         m_inst = new();
      return m_inst; 
   endfunction
   protected function new(string name="start_of_simulation");
      super.new(name); 
   endfunction
   virtual function string get_type_name();
      return type_name;
   endfunction
endclass

class uvm_run_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.run_phase(phase); 
   endtask
   local static uvm_run_phase m_inst; 
   static const string type_name = "uvm_run_phase"; 

   static function uvm_run_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="run"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass


class uvm_extract_phase extends uvm_bottomup_phase;
   virtual function void exec_func(uvm_component comp, uvm_phase phase);
      comp.extract_phase(phase); 
   endfunction
   local static uvm_extract_phase m_inst;
   static const string type_name = "uvm_extract_phase";

   static function uvm_extract_phase get();
      if(m_inst == null)
         m_inst = new();
      return m_inst; 
   endfunction
   protected function new(string name="extract");
      super.new(name); 
   endfunction
   virtual function string get_type_name();
      return type_name;
   endfunction
endclass

class uvm_check_phase extends uvm_bottomup_phase;
   virtual function void exec_func(uvm_component comp, uvm_phase phase);
      comp.check_phase(phase); 
   endfunction
   local static uvm_check_phase m_inst;
   static const string type_name = "uvm_check_phase";

   static function uvm_check_phase get();
      if(m_inst == null)
         m_inst = new();
      return m_inst; 
   endfunction
   protected function new(string name="check");
      super.new(name); 
   endfunction
   virtual function string get_type_name();
      return type_name;
   endfunction
endclass

class uvm_report_phase extends uvm_bottomup_phase;
   virtual function void exec_func(uvm_component comp, uvm_phase phase);
      comp.report_phase(phase); 
   endfunction
   local static uvm_report_phase m_inst;
   static const string type_name = "uvm_report_phase";

   static function uvm_report_phase get();
      if(m_inst == null)
         m_inst = new();
      return m_inst; 
   endfunction
   protected function new(string name="report");
      super.new(name); 
   endfunction
   virtual function string get_type_name();
      return type_name;
   endfunction
endclass



class uvm_final_phase extends uvm_topdown_phase;
   virtual function void exec_func(uvm_component comp, uvm_phase phase);
      comp.final_phase(phase); 
   endfunction
   local static uvm_final_phase m_inst;
   static const string type_name = "uvm_final_phase";

   static function uvm_final_phase get();
      if(m_inst == null)
         m_inst = new();
      return m_inst; 
   endfunction
   protected function new(string name="final");
      super.new(name); 
   endfunction
   virtual function string get_type_name();
      return type_name;
   endfunction
endclass



class uvm_pre_reset_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.pre_reset_phase(phase); 
   endtask
   local static uvm_pre_reset_phase m_inst; 
   static const string type_name = "uvm_pre_reset_phase"; 

   static function uvm_pre_reset_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="pre_reset"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass

class uvm_reset_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.reset_phase(phase); 
   endtask
   local static uvm_reset_phase m_inst; 
   static const string type_name = "uvm_reset_phase"; 

   static function uvm_reset_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="reset"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass

class uvm_post_reset_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.post_reset_phase(phase); 
   endtask
   local static uvm_post_reset_phase m_inst; 
   static const string type_name = "uvm_post_reset_phase"; 

   static function uvm_post_reset_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="post_reset"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass


class uvm_pre_configure_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.pre_configure_phase(phase); 
   endtask
   local static uvm_pre_configure_phase m_inst; 
   static const string type_name = "uvm_pre_configure_phase"; 

   static function uvm_pre_configure_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="pre_configure"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass


class uvm_configure_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.configure_phase(phase); 
   endtask
   local static uvm_configure_phase m_inst; 
   static const string type_name = "uvm_configure_phase"; 

   static function uvm_configure_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="configure"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass

class uvm_post_configure_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.post_configure_phase(phase); 
   endtask
   local static uvm_post_configure_phase m_inst; 
   static const string type_name = "uvm_post_configure_phase"; 

   static function uvm_post_configure_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="post_configure"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass

class uvm_pre_main_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.pre_main_phase(phase); 
   endtask
   local static uvm_pre_main_phase m_inst; 
   static const string type_name = "uvm_pre_main_phase"; 

   static function uvm_pre_main_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="pre_main"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass


class uvm_main_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.main_phase(phase); 
   endtask
   local static uvm_main_phase m_inst; 
   static const string type_name = "uvm_main_phase"; 

   static function uvm_main_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="main"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass


class uvm_post_main_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.post_main_phase(phase); 
   endtask
   local static uvm_post_main_phase m_inst; 
   static const string type_name = "uvm_post_main_phase"; 

   static function uvm_post_main_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="post_main"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass


class uvm_pre_shutdown_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.pre_shutdown_phase(phase); 
   endtask
   local static uvm_pre_shutdown_phase m_inst; 
   static const string type_name = "uvm_pre_shutdown_phase"; 

   static function uvm_pre_shutdown_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="pre_shutdown"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass


class uvm_shutdown_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.shutdown_phase(phase); 
   endtask
   local static uvm_shutdown_phase m_inst; 
   static const string type_name = "uvm_shutdown_phase"; 

   static function uvm_shutdown_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="shutdown"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass


class uvm_post_shutdown_phase extends uvm_task_phase; 
   virtual task exec_task(uvm_component comp, uvm_phase phase); 
      comp.post_shutdown_phase(phase); 
   endtask
   local static uvm_post_shutdown_phase m_inst; 
   static const string type_name = "uvm_post_shutdown_phase"; 

   static function uvm_post_shutdown_phase get(); 
      if(m_inst == null)
         m_inst = new; 
      return m_inst; 
   endfunction
   protected function new(string name="post_shutdown"); 
      super.new(name); 
   endfunction
   virtual function string get_type_name(); 
      return type_name; 
   endfunction
endclass



typedef class uvm_objection;
typedef class uvm_sequence_base;
typedef class uvm_sequence_item;
typedef class uvm_test_done_objection;
typedef class uvm_cmdline_processor;
typedef class uvm_component_proxy;
typedef class uvm_top_down_visitor_adapter;


  class uvm_config_object_wrapper;
     uvm_object obj;
     bit clone;
  endclass : uvm_config_object_wrapper

const uvm_root uvm_top = uvm_root::get();

virtual class uvm_component extends uvm_report_object;

  int enable_stop_interrupt;
  static bit m_config_deprecated_warned;
  static bit m_config_set = 1;
  static bit print_config_matches;

  virtual function void raised (uvm_objection objection, uvm_object source_obj, 
      string description, int count);
  endfunction

  virtual function void dropped (uvm_objection objection, uvm_object source_obj, 
      string description, int count);
  endfunction

  virtual task all_dropped (uvm_objection objection, uvm_object source_obj, 
      string description, int count);
  endtask

  virtual function void pre_abort;
  endfunction

  bit print_enabled = 1;
  uvm_tr_database tr_database;
  protected uvm_domain m_domain;    
  uvm_phase  m_phase_imps[uvm_phase];    
  uvm_phase            m_current_phase;            
  protected process    m_phase_process;
  bit  m_build_done;
  int  m_phasing_active;
  uvm_component m_parent;
  protected     uvm_component m_children[string];
  protected     uvm_component m_children_by_handle[uvm_component];
  local uvm_tr_stream m_main_stream;
  local uvm_tr_stream m_streams[string][string];
  local uvm_recorder m_tr_h[uvm_transaction];
  string m_name;
  const static string type_name = "uvm_component";
  protected uvm_event_pool event_pool;
  int unsigned recording_detail = UVM_NONE;

  virtual function string get_type_name();
    return type_name;
  endfunction

  typedef struct {
    string comp;
    string phase;
    time   offset;
    uvm_verbosity verbosity;
    string id;
  } m_verbosity_setting;

  m_verbosity_setting m_verbosity_settings[$];
  static m_verbosity_setting m_time_settings[$];

  typedef struct  {
  	string arg;
  	string args[$];
  	int unsigned used;
  } uvm_cmdline_parsed_arg_t;

  static uvm_cmdline_parsed_arg_t m_uvm_applied_cl_action[$];
  static uvm_cmdline_parsed_arg_t m_uvm_applied_cl_sev[$];

  function new (string name, uvm_component parent);
    string error_str;
    uvm_root top;
    uvm_coreservice_t cs;
  
    super.new(name);
  
    if (parent==null && name == "__top__") begin
      set_name(""); 
      return;
    end
  
    cs = uvm_coreservice_t::get();
    top = cs.get_root();  
  
    begin
      uvm_phase bld;
      uvm_domain common;
      common = uvm_domain::get_common_domain();
      bld = common.find(uvm_build_phase::get());
      if (bld == null)
        uvm_report_fatal("COMP/INTERNAL", "attempt to find build phase object failed",UVM_NONE);
      if (bld.get_state() == UVM_PHASE_DONE) begin
        uvm_report_fatal("ILLCRT", {"It is illegal to create a component ('", name,"' under '", (parent == null ? top.get_full_name() : parent.get_full_name()), "') after the build phase has ended."}, UVM_NONE);
      end
    end
  
    if (name == "") begin
      name.itoa(m_inst_count);
      name = {"COMP_", name};
    end
  
    if(parent == this) begin
      `uvm_fatal("THISPARENT", "cannot set the parent of a component to itself")
    end
  
    if (parent == null)
      parent = top;
  
    if(uvm_report_enabled(UVM_MEDIUM+1, UVM_INFO, "NEWCOMP"))
      `uvm_info("NEWCOMP", {"Creating ", (parent==top?"uvm_top":parent.get_full_name()),".",name},UVM_MEDIUM+1)
  
    if (parent.has_child(name) && this != parent.get_child(name)) begin
      if (parent == top) begin
        error_str = {"Name '",name,"' is not unique to other top-level ", "instances. If parent is a module, build a unique name by combining the ", "the module name and component name: $sformatf(\"\%m.\%s\",\"",name,"\")."};
        `uvm_fatal("CLDEXT",error_str)
      end
      else
        `uvm_fatal("CLDEXT", $sformatf("Cannot set '%s' as a child of '%s', %s", name, parent.get_full_name(), "which already has a child by that name."))
      return;
    end
  
    m_parent = parent;
  
    set_name(name); 
  
    if (!m_parent.m_add_child(this))
      m_parent = null;
  
    event_pool = new("event_pool");
  
    m_domain = parent.m_domain;     
    
    reseed();
  
    if (!uvm_config_db #(uvm_bitstream_t)::get(this, "", "recording_detail", recording_detail))
          void'(uvm_config_db #(int)::get(this, "", "recording_detail", recording_detail));
  
    m_rh.set_name(get_full_name());
    set_report_verbosity_level(parent.get_report_verbosity_level());
  
    m_set_cl_msg_args();
  
  endfunction
  
  
  
  virtual function bit m_add_child(uvm_component child);
  
    if (m_children.exists(child.get_name()) &&
        m_children[child.get_name()] != child) begin
        `uvm_warning("BDCLD", $sformatf("A child with the name '%0s' (type=%0s) already exists.", child.get_name(), m_children[child.get_name()].get_type_name()))
        return 0;
    end
  
    if (m_children_by_handle.exists(child)) begin
        `uvm_warning("BDCHLD", $sformatf("A child with the name '%0s' %0s %0s'", child.get_name(), "already exists in parent under name '", m_children_by_handle[child].get_name()))
        return 0;
      end
  
    m_children[child.get_name()] = child;
    m_children_by_handle[child] = child;
    return 1;
  endfunction
  
  
  
  
  
  
  virtual function void get_children(ref uvm_component children[$]);
    foreach(m_children[i]) 
      children.push_back(m_children[i]);
  endfunction
  
  
  
  virtual function int get_first_child(ref string name);
    return m_children.first(name);
  endfunction
  
  
  
  virtual function int get_next_child(ref string name);
    return m_children.next(name);
  endfunction
  
  
  
  virtual function uvm_component get_child(string name);
    if (m_children.exists(name))
      return m_children[name];
    `uvm_warning("NOCHILD",{"Component with name '",name, "' is not a child of component '",get_full_name(),"'"})
    return null;
  endfunction
  
  
  
  virtual function int has_child(string name);
    return m_children.exists(name);
  endfunction
  
  
  
  virtual function int get_num_children();
    return m_children.num();
  endfunction
  
  
  
  virtual function string get_full_name ();
    if(m_name == "")
      return get_name();
    else
      return m_name;
  endfunction
  
  
  
  virtual function uvm_component get_parent ();
    return  m_parent;
  endfunction
  
  
  
  virtual function void set_name (string name);
    if(m_name != "") begin
      `uvm_error("INVSTNM", $sformatf("It is illegal to change the name of a component. The component name will not be changed to \"%s\"", name))
      return;
    end
    super.set_name(name);
    m_set_full_name();
  
  endfunction
  
  
  
  local function void m_set_full_name();
    uvm_root top;
    top = uvm_top;
    if (m_parent == top || m_parent==null)
      m_name = get_name();
    else 
      m_name = {m_parent.get_full_name(), ".", get_name()};
  
    foreach (m_children[c]) begin
      uvm_component tmp;
      tmp = m_children[c];
      tmp.m_set_full_name(); 
    end
  
  endfunction
  
  
  
  virtual function uvm_component lookup( string name );
  
    string leaf , remainder;
    uvm_component comp;
    uvm_root top;
    uvm_coreservice_t cs;
    cs = uvm_coreservice_t::get();
    top = cs.get_root();
     
    comp = this;
    
    m_extract_name(name, leaf, remainder);
  
    if (leaf == "") begin
      comp = top; 
      m_extract_name(remainder, leaf, remainder);
    end
    
    if (!comp.has_child(leaf)) begin
      `uvm_warning("Lookup Error", $sformatf("Cannot find child %0s",leaf))
      return null;
    end
  
    if( remainder != "" )
      return comp.m_children[leaf].lookup(remainder);
  
    return comp.m_children[leaf];
  
  endfunction
  
  
  
  virtual function int unsigned get_depth();
    if(m_name == "") return 0;
    get_depth = 1;
    foreach(m_name[i]) 
      if(m_name[i] == ".") ++get_depth;
  endfunction
  
  
  
  local function void m_extract_name(input string name , output string leaf , output string remainder );
    int i , len;
    string extract_str;
    len = name.len();
    
    for( i = 0; i < name.len(); i++ ) begin  
      if( name[i] == "." ) begin
        break;
      end
    end
  
    if( i == len ) begin
      leaf = name;
      remainder = "";
      return;
    end
  
    leaf = name.substr( 0 , i - 1 );
    remainder = name.substr( i + 1 , len - 1 );
  
    return;
  endfunction
    
  
  
  virtual function void flush();
    return;
  endfunction
  
  
  
  virtual function void do_flush();
    foreach( m_children[s] )
      m_children[s].do_flush();
    flush();
  endfunction
    
  
  
  
  
  
  virtual function uvm_object  create (string name =""); 
    `uvm_error("ILLCRT", "create cannot be called on a uvm_component. Use create_component instead.")
    return null;
  endfunction
  
  
  
  virtual function uvm_object  clone ();
    `uvm_error("ILLCLN", $sformatf("Attempting to clone '%s'.  Clone cannot be called on a uvm_component.  The clone target variable will be set to null.", get_full_name()))
    return null;
  endfunction
  
  
  
  virtual function void  print_override_info (string requested_type_name, string name="");
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    factory.debug_create_by_name(requested_type_name, get_full_name(), name);
  endfunction
  
  
  
  virtual function uvm_component create_component (string requested_type_name, string name);
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    return factory.create_component_by_name(requested_type_name, get_full_name(), name, this);
  endfunction
  
  
  
  virtual function uvm_object create_object (string requested_type_name, string name="");
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    return factory.create_object_by_name(requested_type_name, get_full_name(), name);
  endfunction
  
  
  
  static function void set_type_override (string original_type_name, string override_type_name, bit    replace=1);
     uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
     uvm_factory factory=cs.get_factory();
     factory.set_type_override_by_name(original_type_name,override_type_name, replace);
  endfunction 
  
  
  
  static function void set_type_override_by_type (uvm_object_wrapper original_type, uvm_object_wrapper override_type, bit    replace=1);
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
     factory.set_type_override_by_type(original_type, override_type, replace);
  endfunction 
  
  
  
  virtual function void  set_inst_override (string relative_inst_path,  string original_type_name, string override_type_name);
    string full_inst_path;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
  
    if (relative_inst_path == "")
      full_inst_path = get_full_name();
    else
      full_inst_path = {get_full_name(), ".", relative_inst_path};
  
    factory.set_inst_override_by_name( original_type_name, override_type_name, full_inst_path);
  endfunction 
  
  
  
  virtual function void set_inst_override_by_type (string relative_inst_path,  uvm_object_wrapper original_type, uvm_object_wrapper override_type);
    string full_inst_path;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
  
    if (relative_inst_path == "")
      full_inst_path = get_full_name();
    else
      full_inst_path = {get_full_name(), ".", relative_inst_path};
  
    factory.set_inst_override_by_type(original_type, override_type, full_inst_path);
  
  endfunction
  
  
  
  
  
  virtual function void set_report_id_verbosity_hier( string id, int verbosity);
    set_report_id_verbosity(id, verbosity);
    foreach( m_children[c] )
      m_children[c].set_report_id_verbosity_hier(id, verbosity);
  endfunction
  
  
  
  virtual function void set_report_severity_id_verbosity_hier( uvm_severity severity, string id, int verbosity);
    set_report_severity_id_verbosity(severity, id, verbosity);
    foreach( m_children[c] )
      m_children[c].set_report_severity_id_verbosity_hier(severity, id, verbosity);
  endfunction
  
  
  
  virtual function void set_report_severity_action_hier( uvm_severity severity, uvm_action action);
  set_report_severity_action(severity, action);
    foreach( m_children[c] )
      m_children[c].set_report_severity_action_hier(severity, action);
  endfunction
  
  
  
  virtual function void set_report_id_action_hier( string id, uvm_action action);
    set_report_id_action(id, action);
    foreach( m_children[c] )
      m_children[c].set_report_id_action_hier(id, action);
  endfunction
  
  
  
  virtual function void set_report_severity_id_action_hier( uvm_severity severity, string id, uvm_action action);
    set_report_severity_id_action(severity, id, action);
    foreach( m_children[c] )
      m_children[c].set_report_severity_id_action_hier(severity, id, action);
  endfunction
  
  
  
  virtual function void set_report_severity_file_hier( uvm_severity severity, UVM_FILE file);
    set_report_severity_file(severity, file);
    foreach( m_children[c] )
      m_children[c].set_report_severity_file_hier(severity, file);
  endfunction
  
  
  
  virtual function void set_report_default_file_hier( UVM_FILE file);
    set_report_default_file(file);
    foreach( m_children[c] )
      m_children[c].set_report_default_file_hier(file);
  endfunction
  
  
    
  virtual function void set_report_id_file_hier( string id, UVM_FILE file);
    set_report_id_file(id, file);
    foreach( m_children[c] )
      m_children[c].set_report_id_file_hier(id, file);
  endfunction
  
  
  
  virtual function void set_report_severity_id_file_hier ( uvm_severity severity, string id, UVM_FILE file);
    set_report_severity_id_file(severity, id, file);
    foreach( m_children[c] )
      m_children[c].set_report_severity_id_file_hier(severity, id, file);
  endfunction
  
  
  
  virtual function void set_report_verbosity_level_hier(int verbosity);
    set_report_verbosity_level(verbosity);
    foreach( m_children[c] )
      m_children[c].set_report_verbosity_level_hier(verbosity);
  endfunction  
  
  
  
  
  
  
  virtual function void build_phase(uvm_phase phase);
    m_build_done = 1;
    build();
  endfunction
  
  
  virtual function void build();
    m_build_done = 1;
    apply_config_settings(print_config_matches);
    if(m_phasing_active == 0) begin
      uvm_report_warning("UVM_DEPRECATED", "build()/build_phase() has been called explicitly, outside of the phasing system. This usage of build is deprecated and may lead to unexpected behavior.");
    end
  endfunction
  
  
  virtual function void connect_phase(uvm_phase phase);
    connect();
    return; 
  endfunction
  virtual function void start_of_simulation_phase(uvm_phase phase);
    start_of_simulation();
    return; 
  endfunction
  virtual function void end_of_elaboration_phase(uvm_phase phase);
    end_of_elaboration();
    return; 
  endfunction
  virtual task          run_phase(uvm_phase phase);
    run();
    return; 
  endtask
  virtual function void extract_phase(uvm_phase phase);
    extract();
    return; 
  endfunction
  virtual function void check_phase(uvm_phase phase);
    check();
    return; 
  endfunction
  virtual function void report_phase(uvm_phase phase);
    report();
    return; 
  endfunction
  
  
  
  virtual function void connect();             return; endfunction
  virtual function void start_of_simulation(); return; endfunction
  virtual function void end_of_elaboration();  return; endfunction
  virtual task          run();                 return; endtask
  virtual function void extract();             return; endfunction
  virtual function void check();               return; endfunction
  virtual function void report();              return; endfunction
  virtual function void final_phase(uvm_phase phase);         return; endfunction
  
  
  virtual task pre_reset_phase(uvm_phase phase);      return; endtask
  virtual task reset_phase(uvm_phase phase);          return; endtask
  virtual task post_reset_phase(uvm_phase phase);     return; endtask
  virtual task pre_configure_phase(uvm_phase phase);  return; endtask
  virtual task configure_phase(uvm_phase phase);      return; endtask
  virtual task post_configure_phase(uvm_phase phase); return; endtask
  virtual task pre_main_phase(uvm_phase phase);       return; endtask
  virtual task main_phase(uvm_phase phase);           return; endtask
  virtual task post_main_phase(uvm_phase phase);      return; endtask
  virtual task pre_shutdown_phase(uvm_phase phase);   return; endtask
  virtual task shutdown_phase(uvm_phase phase);       return; endtask
  virtual task post_shutdown_phase(uvm_phase phase);  return; endtask
  
  
  
  
  
  virtual function void phase_started(uvm_phase phase);
  endfunction
  
  
  virtual function void phase_ended(uvm_phase phase);
  endfunction
  
  
  
  virtual function void phase_ready_to_end (uvm_phase phase);
  endfunction
  
  
  
  
  virtual protected function void define_domain(uvm_domain domain);
    uvm_phase schedule;
    schedule = domain.find_by_name("uvm_sched");
    if (schedule == null) begin
      uvm_domain common;
      schedule = new("uvm_sched", UVM_PHASE_SCHEDULE);
      uvm_domain::add_uvm_phases(schedule);
      domain.add(schedule);
      common = uvm_domain::get_common_domain();
      if (common.find(domain,0) == null)
        common.add(domain,.with_phase(uvm_run_phase::get()));
    end
  
  endfunction
  
  
  
  virtual function void set_domain(uvm_domain domain, int hier=1);
  
    m_domain = domain;
    define_domain(domain);
    if (hier)
      foreach (m_children[c])
        m_children[c].set_domain(domain);
  endfunction
  
  virtual function uvm_domain get_domain();
    return m_domain;
  endfunction
  
  
  
  virtual function void set_phase_imp(uvm_phase phase, uvm_phase imp, int hier=1);
    m_phase_imps[phase] = imp;
    if (hier)
      foreach (m_children[c])
        m_children[c].set_phase_imp(phase,imp,hier);
  endfunction
  
  
  
  `ifndef UVM_NO_DEPRECATED
  
  virtual function void do_kill_all();
    foreach(m_children[c])
      m_children[c].do_kill_all();
    kill();
  endfunction
  
  
  
  virtual function void kill();
      if (m_phase_process != null) begin
        m_phase_process.kill;
        m_phase_process = null;
      end
  endfunction
  `endif
  
  
  virtual task suspend();
     `uvm_warning("COMP/SPND/UNIMP", "suspend() not implemented")
  endtask
  
  
  
  virtual task resume();
     `uvm_warning("COMP/RSUM/UNIMP", "resume() not implemented")
  endtask
  
  
  
  `ifndef UVM_NO_DEPRECATED
  virtual function string status();
  
    `ifdef UVM_USE_SUSPEND_RESUME
     `ifdef UVM_USE_PROCESS_STATE
      process::state ps;
  
      if(m_phase_process == null)
        return "<unknown>";
  
      ps = m_phase_process.status();
  
      return ps.name();
    `else
      if(m_phase_process == null)
        return "<unknown>";
  
      case(m_phase_process.status())
        0: return "FINISHED";
        1: return "RUNNING";
        2: return "WAITING";
        3: return "SUSPENDED";
        4: return "KILLED";
        default: return "<unknown>";
      endcase
    `endif
    `endif 
  
     return "<unknown>";
     
  endfunction
  
  
  virtual task stop(string ph_name);
    return;
  endtask
  
  
  
  virtual task stop_phase(uvm_phase phase);
    stop(phase.get_name());
    return;
  endtask
  `endif
  
  
  
  virtual function void resolve_bindings();
    return;
  endfunction
  
  
  
  virtual function void do_resolve_bindings();
    foreach( m_children[s] )
      m_children[s].do_resolve_bindings();
    resolve_bindings();
  endfunction
  
  
  
  
  
  virtual function void accept_tr (uvm_transaction tr, time accept_time=0);
    uvm_event#(uvm_object) e;
    tr.accept_tr(accept_time);
    do_accept_tr(tr);
    e = event_pool.get("accept_tr");
    if(e!=null) 
      e.trigger();
  endfunction
  
  
  virtual function integer begin_tr (uvm_transaction tr, string stream_name="main", string label="", string desc="", time begin_time=0, integer parent_handle=0);
     return m_begin_tr(tr, parent_handle, stream_name, label, desc, begin_time);
  endfunction
  
  
  virtual function integer begin_child_tr (uvm_transaction tr, integer parent_handle=0, string stream_name="main", string label="", string desc="", time begin_time=0);
    return m_begin_tr(tr, parent_handle, stream_name, label, desc, begin_time);
  endfunction
  
  virtual function uvm_tr_database m_get_tr_database();
     if (tr_database == null) begin
        uvm_coreservice_t cs = uvm_coreservice_t::get();
        tr_database = cs.get_default_tr_database();
     end
     return tr_database;
  endfunction : m_get_tr_database
     
  virtual function uvm_tr_stream get_tr_stream( string name, string stream_type_name="" );
     uvm_tr_database db = m_get_tr_database();
     if (!m_streams.exists(name) || !m_streams[name].exists(stream_type_name))
       m_streams[name][stream_type_name] = db.open_stream(name, this.get_full_name(), stream_type_name);
     return m_streams[name][stream_type_name];
  endfunction : get_tr_stream
  
  virtual function void free_tr_stream(uvm_tr_stream stream);
     if (stream == null)
       return;
  
     if (!m_streams.exists(stream.get_name()) ||
         !m_streams[stream.get_name()].exists(stream.get_stream_type_name()))
       return;
  
     if (m_streams[stream.get_name()][stream.get_stream_type_name()] != stream)
       return;
  
     m_streams[stream.get_name()].delete(stream.get_type_name());
     if (m_streams[stream.get_name()].size() == 0)
       m_streams.delete(stream.get_name());
  
     if (stream.is_open() || stream.is_closed()) begin
        stream.free();
     end
  endfunction : free_tr_stream
     
  
  protected function integer m_begin_tr (uvm_transaction tr, integer parent_handle=0, string stream_name="main", string label="", string desc="", time begin_time=0);
     uvm_event#(uvm_object) e;
     string    name;
     string    kind;
     uvm_tr_database db;
     integer   handle, link_handle;
     uvm_tr_stream stream;
     uvm_recorder recorder, parent_recorder, link_recorder;
  
     if (tr == null)
       return 0;
  
     db = m_get_tr_database();
     
     if (parent_handle != 0)
       parent_recorder = uvm_recorder::get_recorder_from_handle(parent_handle);
     
     if (parent_recorder == null) begin
        uvm_sequence_item seq;
        if ($cast(seq,tr)) begin
           uvm_sequence_base parent_seq = seq.get_parent_sequence();
           if (parent_seq != null) begin
              parent_recorder = parent_seq.m_tr_recorder;
           end
        end
     end
     
     if(parent_recorder != null) begin
        link_handle = tr.begin_child_tr(begin_time, parent_recorder.get_handle());
     end
     else begin
        link_handle = tr.begin_tr(begin_time);
     end
  
     if (link_handle != 0)
       link_recorder = uvm_recorder::get_recorder_from_handle(link_handle);
  
     
     if (tr.get_name() != "")
       name = tr.get_name();
     else
       name = tr.get_type_name();
     
     if (uvm_verbosity'(recording_detail) != UVM_NONE) begin
        if ((stream_name == "") || (stream_name == "main")) begin
          if (m_main_stream == null)
             m_main_stream = db.open_stream("main", this.get_full_name(), "TVM");
           stream = m_main_stream;
        end
        else
          stream = get_tr_stream(stream_name);
  
        if (stream != null ) begin
           kind = (parent_recorder == null) ? "Begin_No_Parent, Link" : "Begin_End, Link";
           
           recorder = stream.open_recorder(name, begin_time, kind);
  
           if (recorder != null) begin
              if (label != "") 
                recorder.record_string("label", label);
              if (desc != "")
                recorder.record_string("desc", desc);
           
              if (parent_recorder != null) begin
                 tr_database.establish_link(uvm_parent_child_link::get_link(parent_recorder, recorder));
              end
              
              if (link_recorder != null) begin
                 tr_database.establish_link(uvm_related_link::get_link(recorder, link_recorder));
              end
              m_tr_h[tr] = recorder;
           end
        end
        
        handle = (recorder == null) ? 0 : recorder.get_handle();
        do_begin_tr(tr, stream_name, handle); 
        
     end
     
     e = event_pool.get("begin_tr");
     if (e!=null) 
       e.trigger(tr);
     
     return handle;
     
  endfunction
  
  
  
  virtual function void end_tr (uvm_transaction tr, time end_time=0, bit free_handle=1);
     uvm_event#(uvm_object) e;
     uvm_recorder recorder;
     uvm_tr_database db = m_get_tr_database();
  
     if (tr == null)
       return;
  
     tr.end_tr(end_time,free_handle);
  
     if (uvm_verbosity'(recording_detail) != UVM_NONE) begin
  
        if (m_tr_h.exists(tr)) begin
  
           recorder = m_tr_h[tr];
  
           do_end_tr(tr, recorder.get_handle()); 
  
           m_tr_h.delete(tr);
  
           tr.record(recorder);
  
           recorder.close(end_time);
  
           if (free_handle)
             recorder.free();
              
        end
        else begin
           do_end_tr(tr, 0); 
        end
        
     end
  
     e = event_pool.get("end_tr");
     if(e!=null) 
       e.trigger();
  
  endfunction
  
  
  
  virtual function integer record_error_tr (string stream_name="main", uvm_object info=null, string label="error_tr", string desc="", time   error_time=0, bit    keep_active=0);
     uvm_recorder recorder;
     string etype;
     uvm_tr_stream stream;
     uvm_tr_database db = m_get_tr_database();
     integer handle;
     
     if(keep_active) etype = "Error, Link";
     else etype = "Error";
     
     if(error_time == 0) error_time = $realtime;
  
     if ((stream_name=="") || (stream_name=="main")) begin
        if (m_main_stream == null)
          m_main_stream = tr_database.open_stream("main", this.get_full_name(), "TVM");
        stream = m_main_stream;
     end
     else
       stream = get_tr_stream(stream_name);
  
     handle = 0;
     if (stream != null) begin
  
        recorder = stream.open_recorder(label,
                                      error_time,
                                      etype);
  
        if (recorder != null) begin
           if (label != "")
             recorder.record_string("label", label);
           if (desc != "")
             recorder.record_string("desc", desc);
           if (info!=null)
             info.record(recorder);
  
           recorder.close(error_time);
  
           if (keep_active == 0) begin
              recorder.free();
           end
           else begin
              handle = recorder.get_handle();
           end
        end 
     end 
     
     return handle;
  endfunction
  
  
  
  virtual function integer record_event_tr (string stream_name="main", uvm_object info=null, string label="event_tr", string desc="", time   event_time=0, bit    keep_active=0);
     uvm_recorder recorder;
     string etype;
     integer handle;
     uvm_tr_stream stream;
     uvm_tr_database db = m_get_tr_database();
     
    if(keep_active) etype = "Event, Link";
    else etype = "Event";
     
     if(event_time == 0) event_time = $realtime;
     
     if ((stream_name=="") || (stream_name=="main")) begin
        if (m_main_stream == null)
          m_main_stream = tr_database.open_stream("main", this.get_full_name(), "TVM");
        stream = m_main_stream;
     end
     else
       stream = get_tr_stream(stream_name);
  
     handle = 0;
     if (stream != null) begin
        recorder = stream.open_recorder(label, event_time, etype);
  
        if (recorder != null) begin
           if (label != "")
             recorder.record_string("label", label);
           if (desc != "")
             recorder.record_string("desc", desc);
           if (info!=null)
             info.record(recorder);
                          
           recorder.close(event_time);
  
           if (keep_active == 0) begin
              recorder.free();
           end
           else begin
              handle = recorder.get_handle();
           end
        end 
     end 
  
     return handle;
  endfunction
  
  
  virtual protected function void do_accept_tr (uvm_transaction tr);
    return;
  endfunction
  
  
  
  virtual protected function void do_begin_tr (uvm_transaction tr, string stream_name, integer tr_handle);
    return;
  endfunction
  
  
  
  virtual protected function void do_end_tr (uvm_transaction tr, integer tr_handle);
    return;
  endfunction
  
  
  
  
  virtual function string massage_scope(string scope);
  
    if(scope == "")
      return "^$";
  
    if(scope == "*")
      return {get_full_name(), ".*"};
  
    if(scope == "uvm_test_top")
      return "uvm_test_top";
  
    if(scope[0] == ".")
      return {get_full_name(), scope};
  
    return {get_full_name(), ".", scope};
  
  endfunction
  
  
  
  
  `ifndef UVM_NO_DEPRECATED
  virtual function void set_config_int(string inst_name, string field_name, uvm_bitstream_t value);
  
    if (!uvm_component::m_config_deprecated_warned) begin
       `uvm_warning("UVM/CFG/SET/DPR", "get/set_config_* API has been deprecated. Use uvm_config_db instead.")
       uvm_component::m_config_deprecated_warned = 1;
    end
    uvm_config_int::set(this, inst_name, field_name, value);
  endfunction
  
  virtual function void set_config_string(string inst_name, string field_name, string value);
  
    if (!uvm_component::m_config_deprecated_warned) begin
       `uvm_warning("UVM/CFG/SET/DPR", "get/set_config_* API has been deprecated. Use uvm_config_db instead.")
       uvm_component::m_config_deprecated_warned = 1;
    end
    uvm_config_string::set(this, inst_name, field_name, value);
  endfunction
  
  virtual function void set_config_object(string inst_name, string field_name, uvm_object value, bit clone = 1);
    uvm_object tmp;
    uvm_config_object_wrapper wrapper;
  
    if (!uvm_component::m_config_deprecated_warned) begin
       `uvm_warning("UVM/CFG/SET/DPR", "get/set_config_* API has been deprecated. Use uvm_config_db instead.")
       uvm_component::m_config_deprecated_warned = 1;
    end
  
    if(value == null)
      `uvm_warning("NULLCFG", {"A null object was provided as a ", $sformatf("configuration object for set_config_object(\"%s\",\"%s\")", inst_name, field_name), ". Verify that this is intended."})
  
    if(clone && (value != null)) begin
      tmp = value.clone();
      if(tmp == null) begin
        uvm_component comp;
        if ($cast(comp,value)) begin
          `uvm_error("INVCLNC", {"Clone failed during set_config_object ", "with an object that is a uvm_component. Components cannot be cloned."})
          return;
        end
        else begin
          `uvm_warning("INVCLN", {"Clone failed during set_config_object, ", "the original reference will be used for configuration. Check that ", "the create method for the object type is defined properly."})
        end
      end
      else
        value = tmp;
    end
  
  
    uvm_config_object::set(this, inst_name, field_name, value);
  
    wrapper = new;
    wrapper.obj = value;
    wrapper.clone = clone;
    uvm_config_db#(uvm_config_object_wrapper)::set(this, inst_name, field_name, wrapper);
  endfunction
  
  virtual function bit get_config_int (string field_name, inout uvm_bitstream_t value);
  
    if (!uvm_component::m_config_deprecated_warned) begin
       `uvm_warning("UVM/CFG/GET/DPR", "get/set_config_* API has been deprecated. Use uvm_config_db instead.")
       uvm_component::m_config_deprecated_warned = 1;
    end
    return uvm_config_int::get(this, "", field_name, value);
  endfunction
  
  virtual function bit get_config_string(string field_name, inout string value);
  
    if (!uvm_component::m_config_deprecated_warned) begin
       `uvm_warning("UVM/CFG/GET/DPR", "get/set_config_* API has been deprecated. Use uvm_config_db instead.")
       uvm_component::m_config_deprecated_warned = 1;
    end
    return uvm_config_string::get(this, "", field_name, value);
  endfunction
  
  virtual function bit get_config_object (string field_name, inout uvm_object value, input bit clone=1);
    if (!uvm_component::m_config_deprecated_warned) begin
       `uvm_warning("UVM/CFG/GET/DPR", "get/set_config_* API has been deprecated. Use uvm_config_db instead.")
       uvm_component::m_config_deprecated_warned = 1;
    end
  
    if(!uvm_config_object::get(this, "", field_name, value)) begin
      return 0;
    end
  
    if(clone && value != null) begin
      value = value.clone();
    end
  
    return 1;
  endfunction
  `endif
  
  
  virtual function void check_config_usage ( bit recurse=1 );
    uvm_resource_pool rp = uvm_resource_pool::get();
    uvm_queue#(uvm_resource_base) rq;
  
    rq = rp.find_unused_resources();
  
    if(rq.size() == 0)
      return;
  
    uvm_report_info("CFGNRD"," ::: The following resources have at least one write and no reads :::",UVM_INFO);
    rp.print_resources(rq, 1);
  endfunction
  
  
  
  virtual function void apply_config_settings (bit verbose=0);
  
    uvm_resource_pool rp = uvm_resource_pool::get();
    uvm_queue#(uvm_resource_base) rq;
    uvm_resource_base r;
    string name;
    string search_name;
    int unsigned i;
    int unsigned j;
  
    __m_uvm_field_automation (null, UVM_CHECK_FIELDS, "");
  
    if (__m_uvm_status_container.field_array.size() == 0)
      return;
  
    if(verbose)
      uvm_report_info("CFGAPL","applying configuration settings", UVM_NONE);
  
    rq = rp.lookup_scope(get_full_name());
    rp.sort_by_precedence(rq);
  
    for(int i=rq.size()-1; i>=0; --i) begin
  
      r = rq.get(i);
      name = r.get_name();
  
      for(j = 0; j < name.len(); j++)
        if(name[j] == "[" || name[j] == ".")
          break;
  
      if(j < name.len())
        search_name = name.substr(0, j-1);
      else
        search_name = name;
  
      if(!__m_uvm_status_container.field_array.exists(search_name) && 
         search_name != "recording_detail")
        continue;
  
      if(verbose)
        uvm_report_info("CFGAPL",$sformatf("applying configuration to field %s", name),UVM_NONE);
  
      begin
         uvm_resource#(uvm_integral_t) rit;
         if ($cast(rit, r))
           set_int_local(name, rit.read(this));
         else begin
            uvm_resource#(uvm_bitstream_t) rbs;
            if($cast(rbs, r))
              set_int_local(name, rbs.read(this));
            else begin
               uvm_resource#(int) ri;
               if($cast(ri, r))
                 set_int_local(name, ri.read(this));
               else begin
                  uvm_resource#(int unsigned) riu;
                  if($cast(riu, r))
                    set_int_local(name, riu.read(this));
                  else begin
                     uvm_resource#(uvm_active_passive_enum) rap;
                     if ($cast(rap, r))
                       set_int_local(name, rap.read(this));
                     else begin
                        uvm_resource#(string) rs;
                        if($cast(rs, r))
                          set_string_local(name, rs.read(this));
                        else begin
                           uvm_resource#(uvm_config_object_wrapper) rcow;
                           if ($cast(rcow, r)) begin
                           uvm_config_object_wrapper cow = rcow.read();
                              set_object_local(name, cow.obj, cow.clone);
                           end
                           else begin
                              uvm_resource#(uvm_object) ro;
                              if($cast(ro, r)) begin
                                 set_object_local(name, ro.read(this), 0);
                              end 
                              else if (verbose) begin
                                 uvm_report_info("CFGAPL", $sformatf("field %s has an unsupported type", name), UVM_NONE);
                              end
                           end 
                        end 
                     end 
                  end 
               end 
            end 
         end 
      end
    end
  
    __m_uvm_status_container.field_array.delete();
    
  endfunction
  
  
  
  virtual function void print_config(bit recurse = 0, audit = 0);
  
    uvm_resource_pool rp = uvm_resource_pool::get();
  
    uvm_report_info("CFGPRT","visible resources:",UVM_INFO);
    rp.print_resources(rp.lookup_scope(get_full_name()), audit);
  
    if(recurse) begin
      uvm_component c;
      foreach(m_children[name]) begin
        c = m_children[name];
        c.print_config(recurse, audit);
      end
    end
  
  endfunction
  
  
  
  virtual function void print_config_settings (string field="", uvm_component comp=null, bit recurse=0);
    static bit have_been_warned;
    if(!have_been_warned) begin
      uvm_report_warning("deprecated", "print_config_settings has been deprecated.  Use print_config() instead");
      have_been_warned = 1;
    end
  
    print_config(recurse, 1);
  endfunction
  
  
  
  virtual function void print_config_with_audit(bit recurse = 0);
    print_config(recurse, 1);
  endfunction
  
  
  
  virtual function void do_print(uvm_printer printer);
    string v;
    super.do_print(printer);
  
    if(uvm_verbosity'(recording_detail) != UVM_NONE)
      case (recording_detail)
        UVM_LOW : printer.print_generic("recording_detail", "uvm_verbosity", $bits(recording_detail), "UVM_LOW");
        UVM_MEDIUM : printer.print_generic("recording_detail", "uvm_verbosity", $bits(recording_detail), "UVM_MEDIUM");
        UVM_HIGH : printer.print_generic("recording_detail", "uvm_verbosity", $bits(recording_detail), "UVM_HIGH");
        UVM_FULL : printer.print_generic("recording_detail", "uvm_verbosity", $bits(recording_detail), "UVM_FULL");
        default : printer.print_field_int("recording_detail", recording_detail, $bits(recording_detail), UVM_DEC, , "integral");
      endcase
  
  `ifndef UVM_NO_DEPRECATED
    if (enable_stop_interrupt != 0) begin
      printer.print_field_int("enable_stop_interrupt", enable_stop_interrupt, $bits(enable_stop_interrupt), UVM_BIN, ".", "bit");
    end
   `endif
  endfunction
  
  
  
  virtual function void set_int_local (string field_name, uvm_bitstream_t value, bit recurse=1);
  
    super.set_int_local(field_name, value, recurse);
  
    if(uvm_is_match(field_name, "recording_detail"))
      recording_detail = value;
  
  endfunction
  
  
  
  
  virtual function void m_set_cl_msg_args;
    m_set_cl_verb();
    m_set_cl_action();
    m_set_cl_sev();
  endfunction
  
  
  virtual function void m_set_cl_verb;
   
    static string values[$];
    static bit first = 1;
    string args[$];
    uvm_cmdline_processor clp = uvm_cmdline_processor::get_inst();
    uvm_root top;
    uvm_coreservice_t cs;
    cs = uvm_coreservice_t::get();
    top = cs.get_root();
  
    if(!values.size())
      void'(uvm_cmdline_proc.get_arg_values("+uvm_set_verbosity=",values));
  
    foreach(values[i]) begin
      m_verbosity_setting setting;
      args.delete();
      uvm_split_string(values[i], ",", args);
  
      if(first && ( ((args.size() != 4) && (args.size() != 5)) || 
                    (clp.m_convert_verb(args[2], setting.verbosity) == 0))  )
      begin
        values.delete(i);
      end
      else begin
        setting.comp = args[0];
        setting.id = args[1];
        void'(clp.m_convert_verb(args[2],setting.verbosity));
        setting.phase = args[3];
        setting.offset = 0;
        if(args.size() == 5) setting.offset = args[4].atoi();
        if((setting.phase == "time") && (this == top)) begin
          m_time_settings.push_back(setting);
        end
    
        if (uvm_is_match(setting.comp, get_full_name()) ) begin
          if((setting.phase == "" || setting.phase == "build" || setting.phase == "time") && 
             (setting.offset == 0) ) 
          begin
            if(setting.id == "_ALL_") 
              set_report_verbosity_level(setting.verbosity);
            else
              set_report_id_verbosity(setting.id, setting.verbosity);
          end
          else begin
            if(setting.phase != "time") begin
              m_verbosity_settings.push_back(setting);
            end
          end
        end
      end
    end
    if(this == top) begin
      fork begin
        time last_time = 0;
        if (m_time_settings.size() > 0)
          m_time_settings.sort() with ( item.offset );
        foreach(m_time_settings[i]) begin
          uvm_component comps[$];
          top.find_all(m_time_settings[i].comp,comps);
          #(m_time_settings[i].offset - last_time);
          last_time = m_time_settings[i].offset;
          if(m_time_settings[i].id == "_ALL_") begin
             foreach(comps[j]) begin
               comps[j].set_report_verbosity_level(m_time_settings[i].verbosity);
             end
          end
          else begin
            foreach(comps[j]) begin
              comps[j].set_report_id_verbosity(m_time_settings[i].id, m_time_settings[i].verbosity);
            end
          end
        end
      end join_none 
    end
  
    first = 0;
  endfunction
  
  
  virtual function void m_set_cl_action;
  	
    static bit initialized = 0;
    uvm_severity sev;
    uvm_action action;
  
    if(!initialized) begin
  	string values[$];
      void'(uvm_cmdline_proc.get_arg_values("+uvm_set_action=",values));
  	foreach(values[idx]) begin
  		uvm_cmdline_parsed_arg_t t;
  		string args[$];
  	 	uvm_split_string(values[idx], ",", args);	
  
  		if(args.size() != 4) begin
  	   		`uvm_warning("INVLCMDARGS", $sformatf("+uvm_set_action requires 4 arguments, but %0d given for command +uvm_set_action=%s, Usage: +uvm_set_action=<comp>,<id>,<severity>,<action[|action]>", args.size(), values[idx]))
  	   		continue;
     		end
     		if((args[2] != "_ALL_") && !uvm_string_to_severity(args[2], sev)) begin
  	   		`uvm_warning("INVLCMDARGS", $sformatf("Bad severity argument \"%s\" given to command +uvm_set_action=%s, Usage: +uvm_set_action=<comp>,<id>,<severity>,<action[|action]>", args[2], values[idx]))
  	   		continue;
     		end
     		if(!uvm_string_to_action(args[3], action)) begin
  	   		`uvm_warning("INVLCMDARGS", $sformatf("Bad action argument \"%s\" given to command +uvm_set_action=%s, Usage: +uvm_set_action=<comp>,<id>,<severity>,<action[|action]>", args[3], values[idx]))
  	   		continue;
     		end
     		t.args=args;   
     		t.arg=values[idx];
     		m_uvm_applied_cl_action.push_back(t);
  	end 
  	initialized=1;
    end
    
    foreach(m_uvm_applied_cl_action[i]) begin
  	string args[$] = m_uvm_applied_cl_action[i].args;
  
  	if (!uvm_is_match(args[0], get_full_name()) ) continue; 
  	
  	void'(uvm_string_to_severity(args[2], sev));
  	void'(uvm_string_to_action(args[3], action));
  	
      m_uvm_applied_cl_action[i].used++;
      if(args[1] == "_ALL_") begin
        if(args[2] == "_ALL_") begin
          set_report_severity_action(UVM_INFO, action);
          set_report_severity_action(UVM_WARNING, action);
          set_report_severity_action(UVM_ERROR, action);
          set_report_severity_action(UVM_FATAL, action);
        end
        else begin
          set_report_severity_action(sev, action);
        end
      end
      else begin
        if(args[2] == "_ALL_") begin
          set_report_id_action(args[1], action);
        end
        else begin
          set_report_severity_id_action(sev, args[1], action);
        end
      end
    end
  
  endfunction
  
  
  
  virtual function void m_set_cl_sev;
  
    static bit initialized;
    uvm_severity orig_sev, sev;
  
    if(!initialized) begin
  	string values[$];
      void'(uvm_cmdline_proc.get_arg_values("+uvm_set_severity=",values));
  	foreach(values[idx]) begin
  		uvm_cmdline_parsed_arg_t t;
  		string args[$];
  	 	uvm_split_string(values[idx], ",", args);	
  	 	if(args.size() != 4) begin
        		`uvm_warning("INVLCMDARGS", $sformatf("+uvm_set_severity requires 4 arguments, but %0d given for command +uvm_set_severity=%s, Usage: +uvm_set_severity=<comp>,<id>,<orig_severity>,<new_severity>", args.size(), values[idx]))
        		continue;
      	end
      	if(args[2] != "_ALL_" && !uvm_string_to_severity(args[2], orig_sev)) begin
        		`uvm_warning("INVLCMDARGS", $sformatf("Bad severity argument \"%s\" given to command +uvm_set_severity=%s, Usage: +uvm_set_severity=<comp>,<id>,<orig_severity>,<new_severity>", args[2], values[idx]))
        		continue;
      	end
      	if(!uvm_string_to_severity(args[3], sev)) begin
        		`uvm_warning("INVLCMDARGS", $sformatf("Bad severity argument \"%s\" given to command +uvm_set_severity=%s, Usage: +uvm_set_severity=<comp>,<id>,<orig_severity>,<new_severity>", args[3], values[idx]))
        		continue;
      	end
  	 	
  	 	t.args=args;
      	t.arg=values[idx];
  	 	m_uvm_applied_cl_sev.push_back(t);
  	end	
  	initialized=1;
    end
  
    foreach(m_uvm_applied_cl_sev[i]) begin
    	string args[$]=m_uvm_applied_cl_sev[i].args;
  
      if (!uvm_is_match(args[0], get_full_name()) ) continue; 
  	    
  	void'(uvm_string_to_severity(args[2], orig_sev));
  	void'(uvm_string_to_severity(args[3], sev));   	
      m_uvm_applied_cl_sev[i].used++;
      if(args[1] == "_ALL_" && args[2] == "_ALL_") begin
        set_report_severity_override(UVM_INFO,sev);
        set_report_severity_override(UVM_WARNING,sev);
        set_report_severity_override(UVM_ERROR,sev);
        set_report_severity_override(UVM_FATAL,sev);
      end
      else if(args[1] == "_ALL_") begin
        set_report_severity_override(orig_sev,sev);
      end
      else if(args[2] == "_ALL_") begin
        set_report_severity_id_override(UVM_INFO,args[1],sev);
        set_report_severity_id_override(UVM_WARNING,args[1],sev);
        set_report_severity_id_override(UVM_ERROR,args[1],sev);
        set_report_severity_id_override(UVM_FATAL,args[1],sev);
      end
      else begin
        set_report_severity_id_override(orig_sev,args[1],sev);
      end
    end
  endfunction
  
  
  
  virtual function void m_apply_verbosity_settings(uvm_phase phase);
    foreach(m_verbosity_settings[i]) begin
      if(phase.get_name() == m_verbosity_settings[i].phase) begin
        if( m_verbosity_settings[i].offset == 0 ) begin
            if(m_verbosity_settings[i].id == "_ALL_") 
              set_report_verbosity_level(m_verbosity_settings[i].verbosity);
            else 
              set_report_id_verbosity(m_verbosity_settings[i].id, m_verbosity_settings[i].verbosity);
        end
        else begin
          process p = process::self();
          string p_rand = p.get_randstate();
          fork begin
            m_verbosity_setting setting = m_verbosity_settings[i];
            #setting.offset;
            if(setting.id == "_ALL_") 
              set_report_verbosity_level(setting.verbosity);
            else 
              set_report_id_verbosity(setting.id, setting.verbosity);
          end join_none;
          p.set_randstate(p_rand);
        end
        m_verbosity_settings.delete(i);
      end
    end
  endfunction
  
  
  
  virtual function void m_do_pre_abort;
    foreach(m_children[i])
      m_children[i].m_do_pre_abort(); 
    pre_abort(); 
  endfunction


endclass : uvm_component


class uvm_root extends uvm_component;

  uvm_cmdline_processor clp;
  bit  finish_on_completion = 1;
  uvm_component top_levels[$];
  bit  enable_print_topology = 0;
  time phase_timeout = `UVM_DEFAULT_TIMEOUT;
  bit m_phase_all_done;
  static local bit m_relnotes_done=0;
  static local uvm_root m_inst;

  function void phase_started(uvm_phase phase);
    if (phase == end_of_elaboration_ph) begin
      do_resolve_bindings(); 
      if (enable_print_topology) print_topology();
      begin
          uvm_report_server srvr;
          srvr = uvm_report_server::get_server();
          if(srvr.get_severity_count(UVM_ERROR) > 0) begin
            uvm_report_fatal("BUILDERR", "stopping due to build errors", UVM_NONE);
          end
      end      
    end
  endfunction

  static function uvm_root m_uvm_get_root();
      if (m_inst == null) begin
	 m_inst = new();
	 void'(uvm_domain::get_common_domain());
	 m_inst.m_domain = uvm_domain::get_uvm_domain();
      end
      return m_inst;
  endfunction

`ifndef UVM_NO_DEPRECATED
  function void stop_request();
    uvm_test_done_objection tdo;
    tdo = uvm_test_done_objection::get();
    tdo.stop_request();
  endfunction
`endif

  virtual function void end_of_elaboration_phase(uvm_phase phase);  
	 uvm_component_proxy p = new("proxy");
	 uvm_top_down_visitor_adapter#(uvm_component) adapter = new("adapter");
	 uvm_coreservice_t cs = uvm_coreservice_t::get();
	 uvm_visitor#(uvm_component) v = cs.get_component_visitor();
	 adapter.accept(this, v, p);
  endfunction

  virtual function string get_type_name();
    return "uvm_root";
  endfunction

  virtual function void die();
    uvm_report_server l_rs = uvm_report_server::get_server();
    m_do_pre_abort();

    l_rs.report_summarize();
    $finish;
  endfunction

  static function uvm_root get();
     uvm_coreservice_t cs = uvm_coreservice_t::get();
     return cs.get_root();
  endfunction
  
  protected function new();
  
    super.new("__top__", null);
  
    m_rh.set_name("reporter");
  
    clp = uvm_cmdline_processor::get_inst();
  
    report_header();
  
    m_check_verbosity();
  endfunction
  
  virtual function void report_header(UVM_FILE file = 0);
  	string q[$];
  	uvm_report_server srvr;
  	uvm_cmdline_processor clp;
  	string args[$];
  
  	srvr = uvm_report_server::get_server();
  	clp = uvm_cmdline_processor::get_inst();
  
  	if (clp.get_arg_matches("+UVM_NO_RELNOTES", args)) return;
  
  
  	q.push_back("\n----------------------------------------------------------------\n");
  	q.push_back({uvm_revision_string(),"\n"});
  	q.push_back({uvm_mgc_copyright,"\n"});
  	q.push_back({uvm_cdn_copyright,"\n"});
  	q.push_back({uvm_snps_copyright,"\n"});
  	q.push_back({uvm_cy_copyright,"\n"});
  	q.push_back({uvm_nv_copyright,"\n"});
  	q.push_back("----------------------------------------------------------------\n");
  
  
  `ifndef UVM_NO_DEPRECATED
  	if(!m_relnotes_done)      
  		q.push_back("\n  ***********       IMPORTANT RELEASE NOTES         ************\n");
  	q.push_back("\n  You are using a version of the UVM library that has been compiled\n");
  	q.push_back("  with `UVM_NO_DEPRECATED undefined.\n");
  	m_relnotes_done=1;
  `endif
  
  `ifndef UVM_OBJECT_DO_NOT_NEED_CONSTRUCTOR
  	if(!m_relnotes_done)      
  		q.push_back("\n  ***********       IMPORTANT RELEASE NOTES         ************\n");
  		
  	q.push_back("\n  You are using a version of the UVM library that has been compiled\n");
  	q.push_back("  with `UVM_OBJECT_DO_NOT_NEED_CONSTRUCTOR undefined.\n");
  	m_relnotes_done=1;
  `endif
  
  	if(m_relnotes_done)
  		q.push_back("\n      (Specify +UVM_NO_RELNOTES to turn off this notice)\n");
  
  	`uvm_info("UVM/RELNOTES",`UVM_STRING_QUEUE_STREAMING_PACK(q),UVM_LOW)
  endfunction
  
  
  
  
  virtual task run_test(string test_name="");
  
    uvm_report_server l_rs;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    bit testname_plusarg;
    int test_name_count;
    string test_names[$];
    string msg;
    uvm_component uvm_test_top;
  
    process phase_runner_proc; 
  
    testname_plusarg = 0;
  
    uvm_objection::m_init_objections();
  
  `ifndef UVM_NO_DPI
  
    test_name_count = clp.get_arg_values("+UVM_TESTNAME=", test_names);
  
    if (test_name_count > 0) begin
      test_name = test_names[0];
      testname_plusarg = 1;
    end
  
    if (test_name_count > 1) begin
      string test_list;
      string sep;
      for (int i = 0; i < test_names.size(); i++) begin
        if (i != 0)
          sep = ", ";
        test_list = {test_list, sep, test_names[i]};
      end
      uvm_report_warning("MULTTST", 
        $sformatf("Multiple (%0d) +UVM_TESTNAME arguments provided on the command line.  '%s' will be used.  Provided list: %s.", test_name_count, test_name, test_list), UVM_NONE);
    end
  
  `else
  
    if ($value$plusargs("UVM_TESTNAME=%s", test_name)) begin
      `uvm_info("NO_DPI_TSTNAME", "UVM_NO_DPI defined--getting UVM_TESTNAME directly, without DPI", UVM_NONE)
      testname_plusarg = 1;
    end
  
  `endif
  
    if (test_name != "") begin
    	uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    	uvm_factory factory=cs.get_factory();
  	  
      if(m_children.exists("uvm_test_top")) begin
        uvm_report_fatal("TTINST", "An uvm_test_top already exists via a previous call to run_test", UVM_NONE);
        #0; 
      end
      $cast(uvm_test_top, factory.create_component_by_name(test_name, "", "uvm_test_top", null));
  
      if (uvm_test_top == null) begin
        msg = testname_plusarg ? {"command line +UVM_TESTNAME=",test_name} : {"call to run_test(",test_name,")"};
        uvm_report_fatal("INVTST", {"Requested test from ",msg, " not found." }, UVM_NONE);
      end
    end
  
    if (m_children.num() == 0) begin
      uvm_report_fatal("NOCOMP", {"No components instantiated. You must either instantiate", " at least one component before calling run_test or use", " run_test to do so. To run a test using run_test,", " use +UVM_TESTNAME or supply the test name in", " the argument to run_test(). Exiting simulation."}, UVM_NONE);
      return;
    end
  
    begin
    	if(test_name=="") 
    		uvm_report_info("RNTST", "Running test ...", UVM_LOW); 
    	else if (test_name == uvm_test_top.get_type_name())
    		uvm_report_info("RNTST", {"Running test ",test_name,"..."}, UVM_LOW); 
    	else
    		uvm_report_info("RNTST", {"Running test ",uvm_test_top.get_type_name()," (via factory override for test \"",test_name,"\")..."}, UVM_LOW);
    end
    
    fork begin
      phase_runner_proc = process::self();
      uvm_phase::m_run_phases();
    end
    join_none
    #0; 
    
    wait (m_phase_all_done == 1);
    
    phase_runner_proc.kill();
  
    l_rs = uvm_report_server::get_server();
    l_rs.report_summarize();
  
    if (finish_on_completion)
      $finish;
  
  endtask
  
  
  
  virtual function void find_all(string comp_match, ref uvm_component comps[$], input uvm_component comp=null); 
  
    if (comp==null)
      comp = this;
    m_find_all_recurse(comp_match, comps, comp);
  
  endfunction
  
  
  
  virtual function uvm_component find (string comp_match);
    uvm_component comp_list[$];
  
    find_all(comp_match,comp_list);
  
    if (comp_list.size() > 1)
      uvm_report_warning("MMATCH",
      $sformatf("Found %0d components matching '%s'. Returning first match, %0s.", comp_list.size(),comp_match,comp_list[0].get_full_name()), UVM_NONE);
  
    if (comp_list.size() == 0) begin
      uvm_report_warning("CMPNFD",
        {"Component matching '",comp_match, "' was not found in the list of uvm_components"}, UVM_NONE);
      return null;
    end
  
    return comp_list[0];
  endfunction
  
  
  
  virtual function void print_topology(uvm_printer printer=null);
  
    string s;
  
    if (m_children.num()==0) begin
      uvm_report_warning("EMTCOMP", "print_topology - No UVM components to print.", UVM_NONE);
      return;
    end
  
    if (printer==null)
      printer = uvm_default_printer;
  
    foreach (m_children[c]) begin
      if(m_children[c].print_enabled) begin
        printer.print_object("", m_children[c]);  
      end
    end
    `uvm_info("UVMTOP",{"UVM testbench topology:\n",printer.emit()},UVM_NONE)
  
  endfunction
  
  
  
  virtual function void set_timeout(time timeout, bit overridable=1);
    static bit m_uvm_timeout_overridable = 1;
    if (m_uvm_timeout_overridable == 0) begin
      uvm_report_info("NOTIMOUTOVR", $sformatf("The global timeout setting of %0d is not overridable to %0d due to a previous setting.", phase_timeout, timeout), UVM_NONE);
      return;
    end
    m_uvm_timeout_overridable = overridable;
    phase_timeout = timeout;
  endfunction
  
  
  
  
  virtual function void m_find_all_recurse(string comp_match, ref uvm_component comps[$], input uvm_component comp=null); 
    string name;
  
    if (comp.get_first_child(name))
      do begin
        this.m_find_all_recurse(comp_match, comps, comp.get_child(name));
      end
      while (comp.get_next_child(name));
    if (uvm_is_match(comp_match, comp.get_full_name()) &&
        comp.get_name() != "") 
      comps.push_back(comp);
  
  endfunction
  
  
  
  protected virtual function bit m_add_child (uvm_component child);
    if(super.m_add_child(child)) begin
      if(child.get_name() == "uvm_test_top")
        top_levels.push_front(child);
      else
        top_levels.push_back(child);
      return 1;
    end
    else
      return 0;
  endfunction
  
  
  
  virtual function void build_phase(uvm_phase phase);
  
    super.build_phase(phase);
  
    m_set_cl_msg_args();
  
    m_do_verbosity_settings();
    m_do_timeout_settings();
    m_do_factory_settings();
    m_do_config_settings();
    m_do_max_quit_settings();
    m_do_dump_args();
  
  endfunction
  
  
  
  local function void m_do_verbosity_settings();
    string set_verbosity_settings[$];
    string split_vals[$];
    uvm_verbosity tmp_verb;
  
    void'(clp.get_arg_values("+uvm_set_verbosity=", set_verbosity_settings));
  
    for(int i = 0; i < set_verbosity_settings.size(); i++) begin
      uvm_split_string(set_verbosity_settings[i], ",", split_vals);
      if(split_vals.size() < 4 || split_vals.size() > 5) begin
        uvm_report_warning("INVLCMDARGS", 
          $sformatf("Invalid number of arguments found on the command line for setting '+uvm_set_verbosity=%s'.  Setting ignored.", set_verbosity_settings[i]), UVM_NONE, "", "");
      end
      if(!clp.m_convert_verb(split_vals[2], tmp_verb)) begin
        uvm_report_warning("INVLCMDVERB", $sformatf("Invalid verbosity found on the command line for setting '%s'.", set_verbosity_settings[i]), UVM_NONE, "", "");
      end
    end
  endfunction
  
  
  
  local function void m_do_timeout_settings();
    string timeout_settings[$];
    string timeout;
    string split_timeout[$];
    int timeout_count;
    time timeout_int;
    string override_spec;
    timeout_count = clp.get_arg_values("+UVM_TIMEOUT=", timeout_settings);
    if (timeout_count ==  0)
      return;
    else begin
      timeout = timeout_settings[0];
      if (timeout_count > 1) begin
        string timeout_list;
        string sep;
        for (int i = 0; i < timeout_settings.size(); i++) begin
          if (i != 0)
            sep = "; ";
          timeout_list = {timeout_list, sep, timeout_settings[i]};
        end
        uvm_report_warning("MULTTIMOUT", $sformatf("Multiple (%0d) +UVM_TIMEOUT arguments provided on the command line.  '%s' will be used.  Provided list: %s.", timeout_count, timeout, timeout_list), UVM_NONE);
      end
      uvm_report_info("TIMOUTSET", $sformatf("'+UVM_TIMEOUT=%s' provided on the command line is being applied.", timeout), UVM_NONE); void'($sscanf(timeout,"%d,%s",timeout_int,override_spec));
      case(override_spec)
        "YES"   : set_timeout(timeout_int, 1);
        "NO"    : set_timeout(timeout_int, 0);
        default : set_timeout(timeout_int, 1);
      endcase
    end
  endfunction
  
  
  
  local function void m_do_factory_settings();
    string args[$];
  
    void'(clp.get_arg_matches("/^\\+(UVM_SET_INST_OVERRIDE|uvm_set_inst_override)=/",args));
    foreach(args[i]) begin
      m_process_inst_override(args[i].substr(23, args[i].len()-1));
    end
    void'(clp.get_arg_matches("/^\\+(UVM_SET_TYPE_OVERRIDE|uvm_set_type_override)=/",args));
    foreach(args[i]) begin
      m_process_type_override(args[i].substr(23, args[i].len()-1));
    end
  endfunction
  
  
  
  local function void m_process_inst_override(string ovr);
    string split_val[$];
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
  
    uvm_split_string(ovr, ",", split_val);
  
    if(split_val.size() != 3 ) begin
      uvm_report_error("UVM_CMDLINE_PROC", {"Invalid setting for +uvm_set_inst_override=", ovr, ", setting must specify <requested_type>,<override_type>,<instance_path>"}, UVM_NONE);
      return;
    end
  
    uvm_report_info("INSTOVR", {"Applying instance override from the command line: +uvm_set_inst_override=", ovr}, UVM_NONE);
    factory.set_inst_override_by_name(split_val[0], split_val[1], split_val[2]);
  endfunction
  
  
  
  local function void m_process_type_override(string ovr);
    string split_val[$];
    int replace=1;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
  
    uvm_split_string(ovr, ",", split_val);
  
    if(split_val.size() > 3 || split_val.size() < 2) begin
      uvm_report_error("UVM_CMDLINE_PROC", {"Invalid setting for +uvm_set_type_override=", ovr, ", setting must specify <requested_type>,<override_type>[,<replace>]"}, UVM_NONE);
      return;
    end
  
    if(split_val.size() == 3) begin
      if(split_val[2]=="0") replace =  0;
      else if (split_val[2] == "1") replace = 1;
      else begin
        uvm_report_error("UVM_CMDLINE_PROC", {"Invalid replace arg for +uvm_set_type_override=", ovr ," value must be 0 or 1"}, UVM_NONE);
        return;
      end
    end
  
    uvm_report_info("UVM_CMDLINE_PROC", {"Applying type override from the command line: +uvm_set_type_override=", ovr}, UVM_NONE);
    factory.set_type_override_by_name(split_val[0], split_val[1], replace);
  endfunction
  
  
  
  local function void m_process_config(string cfg, bit is_int);
    uvm_bitstream_t v;
    string split_val[$];  
    uvm_root m_uvm_top;
    uvm_coreservice_t cs;
    cs = uvm_coreservice_t::get();
    m_uvm_top = cs.get_root();
  
  
    uvm_split_string(cfg, ",", split_val);
    if(split_val.size() == 1) begin
      uvm_report_error("UVM_CMDLINE_PROC", {"Invalid +uvm_set_config command\"", cfg, "\" missing field and value: component is \"", split_val[0], "\""}, UVM_NONE);
      return;
    end
  
    if(split_val.size() == 2) begin
      uvm_report_error("UVM_CMDLINE_PROC", {"Invalid +uvm_set_config command\"", cfg, "\" missing value: component is \"", split_val[0], "\"  field is \"", split_val[1], "\""}, UVM_NONE);
      return;
    end
  
    if(split_val.size() > 3) begin
      uvm_report_error("UVM_CMDLINE_PROC", $sformatf("Invalid +uvm_set_config command\"%s\" : expected only 3 fields (component, field and value).", cfg), UVM_NONE);
      return;
    end
   
    if(is_int) begin
      if(split_val[2].len() > 2) begin
        string base, extval;
        base = split_val[2].substr(0,1);
        extval = split_val[2].substr(2,split_val[2].len()-1); 
        case(base)
          "'b" : v = extval.atobin();
          "0b" : v = extval.atobin();
          "'o" : v = extval.atooct();
          "'d" : v = extval.atoi();
          "'h" : v = extval.atohex();
          "'x" : v = extval.atohex();
          "0x" : v = extval.atohex();
          default : v = split_val[2].atoi();
        endcase
      end
      else begin
        v = split_val[2].atoi();
      end
      uvm_report_info("UVM_CMDLINE_PROC", {"Applying config setting from the command line: +uvm_set_config_int=", cfg}, UVM_NONE);
      uvm_config_int::set(m_uvm_top, split_val[0], split_val[1], v);
    end
    else begin
      uvm_report_info("UVM_CMDLINE_PROC", {"Applying config setting from the command line: +uvm_set_config_string=", cfg}, UVM_NONE);
      uvm_config_string::set(m_uvm_top, split_val[0], split_val[1], split_val[2]);
    end 
  
  endfunction
  
  
  local function void m_process_default_sequence(string cfg);
    string split_val[$];
    uvm_coreservice_t cs = uvm_coreservice_t::get();
    uvm_root m_uvm_top = cs.get_root();   
    uvm_factory f = cs.get_factory();
    uvm_object_wrapper w;
  
    uvm_split_string(cfg, ",", split_val);
    if(split_val.size() == 1) begin
      uvm_report_error("UVM_CMDLINE_PROC", {"Invalid +uvm_set_default_sequence command\"", cfg, "\" missing phase and type: sequencer is \"", split_val[0], "\""}, UVM_NONE);
      return;
    end
  
    if(split_val.size() == 2) begin
      uvm_report_error("UVM_CMDLINE_PROC", {"Invalid +uvm_set_default_sequence command\"", cfg, "\" missing type: sequencer is \"", split_val[0], "\"  phase is \"", split_val[1], "\""}, UVM_NONE);
      return;
    end
  
    if(split_val.size() > 3) begin
      uvm_report_error("UVM_CMDLINE_PROC", 
        $sformatf("Invalid +uvm_set_default_sequence command\"%s\" : expected only 3 fields (sequencer, phase and type).", cfg), UVM_NONE);
      return;
    end
  
    w = f.find_wrapper_by_name(split_val[2]);
    if (w == null) begin
        uvm_report_error("UVM_CMDLINE_PROC", $sformatf("Invalid type '%s' provided to +uvm_set_default_sequence", split_val[2]), UVM_NONE);
        return;
    end
    else begin
        uvm_report_info("UVM_CMDLINE_PROC", {"Setting default sequence from the command line: +uvm_set_default_sequence=", cfg}, UVM_NONE);
        uvm_config_db#(uvm_object_wrapper)::set(this, {split_val[0], ".", split_val[1]}, "default_sequence", w);
    end 
  
  endfunction : m_process_default_sequence
  
  
  
  local function void m_do_config_settings();
    string args[$];
  
    void'(clp.get_arg_matches("/^\\+(UVM_SET_CONFIG_INT|uvm_set_config_int)=/",args));
    foreach(args[i]) begin
      m_process_config(args[i].substr(20, args[i].len()-1), 1);
    end
    void'(clp.get_arg_matches("/^\\+(UVM_SET_CONFIG_STRING|uvm_set_config_string)=/",args));
    foreach(args[i]) begin
      m_process_config(args[i].substr(23, args[i].len()-1), 0);
    end
    void'(clp.get_arg_matches("/^\\+(UVM_SET_DEFAULT_SEQUENCE|uvm_set_default_sequence)=/", args));
    foreach(args[i]) begin
      m_process_default_sequence(args[i].substr(26, args[i].len()-1));
    end
  endfunction
  
  
  
  local function void m_do_max_quit_settings();
    uvm_report_server srvr;
    string max_quit_settings[$];
    int max_quit_count;
    string max_quit;
    string split_max_quit[$];
    int max_quit_int;
    srvr = uvm_report_server::get_server();
    max_quit_count = clp.get_arg_values("+UVM_MAX_QUIT_COUNT=", max_quit_settings);
    if (max_quit_count ==  0)
      return;
    else begin
      max_quit = max_quit_settings[0];
      if (max_quit_count > 1) begin
        string max_quit_list;
        string sep;
        for (int i = 0; i < max_quit_settings.size(); i++) begin
          if (i != 0)
            sep = "; ";
          max_quit_list = {max_quit_list, sep, max_quit_settings[i]};
        end
        uvm_report_warning("MULTMAXQUIT", $sformatf("Multiple (%0d) +UVM_MAX_QUIT_COUNT arguments provided on the command line.  '%s' will be used.  Provided list: %s.", max_quit_count, max_quit, max_quit_list), UVM_NONE);
      end
      uvm_report_info("MAXQUITSET", $sformatf("'+UVM_MAX_QUIT_COUNT=%s' provided on the command line is being applied.", max_quit), UVM_NONE); uvm_split_string(max_quit, ",", split_max_quit);
      max_quit_int = split_max_quit[0].atoi();
      case(split_max_quit[1])
        "YES"   : srvr.set_max_quit_count(max_quit_int, 1);
        "NO"    : srvr.set_max_quit_count(max_quit_int, 0);
        default : srvr.set_max_quit_count(max_quit_int, 1);
      endcase
    end
  endfunction
  
  
  
  local function void m_do_dump_args();
    string dump_args[$];
    string all_args[$];
    string out_string;
    if(clp.get_arg_matches("+UVM_DUMP_CMDLINE_ARGS", dump_args)) begin
      clp.get_args(all_args);
      for (int i = 0; i < all_args.size(); i++) begin
        if (all_args[i] == "__-f__")
          continue;
        out_string = {out_string, all_args[i], " "};
      end
      uvm_report_info("DUMPARGS", out_string, UVM_NONE);
    end
  endfunction
  
  
  
  virtual function void m_check_verbosity();
  
    string verb_string;
    string verb_settings[$];
    int verb_count;
    int plusarg;
    int verbosity = UVM_MEDIUM;
  
    `ifndef UVM_CMDLINE_NO_DPI
    verb_count = clp.get_arg_values("+UVM_VERBOSITY=", verb_settings);
    `else
    verb_count = $value$plusargs("UVM_VERBOSITY=%s",verb_string);
    if (verb_count)
      verb_settings.push_back(verb_string);
    `endif
  
  
    if (verb_count > 0) begin
      verb_string = verb_settings[0];
      plusarg = 1;
    end
  
    if (verb_count > 1) begin
      string verb_list;
      string sep;
      for (int i = 0; i < verb_settings.size(); i++) begin
        if (i != 0)
          sep = ", ";
        verb_list = {verb_list, sep, verb_settings[i]};
      end
      uvm_report_warning("MULTVERB", $sformatf("Multiple (%0d) +UVM_VERBOSITY arguments provided on the command line.  '%s' will be used.  Provided list: %s.", verb_count, verb_string, verb_list), UVM_NONE);
    end
  
    if(plusarg == 1) begin
      case(verb_string)
        "UVM_NONE"    : verbosity = UVM_NONE;
        "NONE"        : verbosity = UVM_NONE;
        "UVM_LOW"     : verbosity = UVM_LOW;
        "LOW"         : verbosity = UVM_LOW;
        "UVM_MEDIUM"  : verbosity = UVM_MEDIUM;
        "MEDIUM"      : verbosity = UVM_MEDIUM;
        "UVM_HIGH"    : verbosity = UVM_HIGH;
        "HIGH"        : verbosity = UVM_HIGH;
        "UVM_FULL"    : verbosity = UVM_FULL;
        "FULL"        : verbosity = UVM_FULL;
        "UVM_DEBUG"   : verbosity = UVM_DEBUG;
        "DEBUG"       : verbosity = UVM_DEBUG;
        default       : begin
          verbosity = verb_string.atoi();
          if(verbosity > 0)
            uvm_report_info("NSTVERB", $sformatf("Non-standard verbosity value, using provided '%0d'.", verbosity), UVM_NONE);
          if(verbosity == 0) begin
            verbosity = UVM_MEDIUM;
            uvm_report_warning("ILLVERB", "Illegal verbosity value, using default of UVM_MEDIUM.", UVM_NONE);
          end
        end
      endcase
    end
  
    set_report_verbosity_level_hier(verbosity);
  
  endfunction
  
  virtual task run_phase (uvm_phase phase);
    foreach(m_uvm_applied_cl_action[idx])
  	  if(m_uvm_applied_cl_action[idx].used==0) begin
  		    `uvm_warning("INVLCMDARGS",$sformatf("\"+uvm_set_action=%s\" never took effect due to a mismatching component pattern",m_uvm_applied_cl_action[idx].arg))
  	  end
    foreach(m_uvm_applied_cl_sev[idx])
  	  if(m_uvm_applied_cl_sev[idx].used==0) begin
  		    `uvm_warning("INVLCMDARGS",$sformatf("\"+uvm_set_severity=%s\" never took effect due to a mismatching component pattern",m_uvm_applied_cl_sev[idx].arg))
  	  end	  
  	  
    if($time > 0)
      `uvm_fatal("RUNPHSTIME", {"The run phase must start at time 0, current time is ", $sformatf("%0t", $realtime), ". No non-zero delays are allowed before ", "run_test(), and pre-run user defined phases may not consume ", "simulation time before the start of the run phase."})
  endtask

endclass


`ifndef UVM_OBJECTION_SVH
`define UVM_OBJECTION_SVH

typedef class uvm_objection_context_object;
typedef class uvm_objection;
typedef class uvm_sequence_base;
typedef class uvm_objection_callback;
typedef uvm_callbacks #(uvm_objection,uvm_objection_callback) uvm_objection_cbs_t;
typedef class uvm_cmdline_processor;

class uvm_objection_events;
  int waiters;
  event raised;
  event dropped;
  event all_dropped;
endclass



class uvm_objection extends uvm_report_object;
  `uvm_register_cb(uvm_objection, uvm_objection_callback)

  protected bit     m_trace_mode;
  protected int     m_source_count[uvm_object];
  protected int     m_total_count [uvm_object];
  protected time    m_drain_time  [uvm_object];
  protected uvm_objection_events m_events [uvm_object];
  bit     m_top_all_dropped;
  protected uvm_root m_top;
  static uvm_objection m_objections[$];
  local static uvm_objection_context_object m_context_pool[$];

`ifndef UVM_USE_PROCESS_CONTAINER   
  local process m_drain_proc[uvm_object];
`else
  local process_container_c m_drain_proc[uvm_object];
`endif
   
  local static uvm_objection_context_object m_scheduled_list[$];
  local uvm_objection_context_object m_scheduled_contexts[uvm_object];
  local uvm_objection_context_object m_forked_list[$];
  local uvm_objection_context_object m_forked_contexts[uvm_object];
  protected bit m_prop_mode = 1;
  protected bit m_cleared; 

  function new(string name="");
    uvm_cmdline_processor clp;
    uvm_coreservice_t cs_ ;
    string trace_args[$];
    super.new(name);
    cs_ = uvm_coreservice_t::get();
    m_top  = cs_.get_root();
     
    set_report_verbosity_level(m_top.get_report_verbosity_level());

    clp = uvm_cmdline_processor::get_inst();
    if(clp.get_arg_matches("+UVM_OBJECTION_TRACE", trace_args)) begin
      m_trace_mode=1;
    end
    m_objections.push_back(this);
  endfunction



   function bit trace_mode (int mode=-1);
    trace_mode = m_trace_mode;
    if(mode == 0) m_trace_mode = 0;
    else if(mode == 1) m_trace_mode = 1;
   endfunction


  function void m_report(uvm_object obj, uvm_object source_obj, string description, int count, string action);
    string desc;
    int _count = m_source_count.exists(obj) ? m_source_count[obj] : 0;
    int _total = m_total_count.exists(obj) ? m_total_count[obj] : 0;
    if (!uvm_report_enabled(UVM_NONE,UVM_INFO,"OBJTN_TRC") || !m_trace_mode) return;

    if (source_obj == obj)

      uvm_report_info("OBJTN_TRC", $sformatf("Object %0s %0s %0d objection(s)%s: count=%0d  total=%0d", obj.get_full_name()==""?"uvm_top":obj.get_full_name(), action, count, description != ""? {" (",description,")"}:"", _count, _total), UVM_NONE);
    else begin
      int cpath = 0, last_dot=0;
      string sname = source_obj.get_full_name(), nm = obj.get_full_name();
      int max = sname.len() > nm.len() ? nm.len() : sname.len();

      while((sname[cpath] == nm[cpath]) && (cpath < max)) begin
        if(sname[cpath] == ".") last_dot = cpath;
        cpath++;
      end 

      if(last_dot) sname = sname.substr(last_dot+1, sname.len());
      uvm_report_info("OBJTN_TRC", $sformatf("Object %0s %0s %0d objection(s) %0s its total (%s from source object %s%s): count=%0d  total=%0d", obj.get_full_name()==""?"uvm_top":obj.get_full_name(), action=="raised"?"added":"subtracted", count, action=="raised"?"to":"from", action, sname, description != ""?{", ",description}:"", _count, _total), UVM_NONE);
    end
  endfunction



  function uvm_object m_get_parent(uvm_object obj);
    uvm_component comp;
    uvm_sequence_base seq;
    if ($cast(comp, obj)) begin
      obj = comp.get_parent();
    end
    else if ($cast(seq, obj)) begin
       obj = seq.get_sequencer();
    end
    else
      obj = m_top;
    if (obj == null)
      obj = m_top;
    return obj;
  endfunction



  function void m_propagate (uvm_object obj, uvm_object source_obj, string description, int count, bit raise, int in_top_thread);
    if (obj != null && obj != m_top) begin
      obj = m_get_parent(obj);
      if(raise)
        m_raise(obj, source_obj, description, count);
      else
        m_drop(obj, source_obj, description, count, in_top_thread);
    end
  endfunction



  function void set_propagate_mode (bit prop_mode);
     if (!m_top_all_dropped && (get_objection_total() != 0)) begin
        `uvm_error("UVM/BASE/OBJTN/PROP_MODE", {"The propagation mode of '", this.get_full_name(), "' cannot be changed while the objection is raised ", "or draining!"})
        return;
     end

     m_prop_mode = prop_mode;
  endfunction : set_propagate_mode

  function bit get_propagate_mode();
     return m_prop_mode;
  endfunction : get_propagate_mode
   

  virtual function void raise_objection (uvm_object obj=null, string description="", int count=1);
    if(obj == null)
      obj = m_top;
    m_cleared = 0;
    m_top_all_dropped = 0;
    m_raise (obj, obj, description, count);
  endfunction



  function void m_raise (uvm_object obj, uvm_object source_obj, string description="", int count=1);
    int idx;
    uvm_objection_context_object ctxt;

    if (count == 0)
      return;

    if (m_total_count.exists(obj))
      m_total_count[obj] += count;
    else 
      m_total_count[obj] = count;

    if (source_obj==obj) begin
      if (m_source_count.exists(obj))
        m_source_count[obj] += count;
      else
        m_source_count[obj] = count;
    end
  
    if (m_trace_mode)
      m_report(obj,source_obj,description,count,"raised");

    raised(obj, source_obj, description, count);


    idx = 0;
    while (idx < m_scheduled_list.size()) begin
        if ((m_scheduled_list[idx].obj == obj) && (m_scheduled_list[idx].objection == this)) begin
            ctxt = m_scheduled_list[idx];
            m_scheduled_list.delete(idx);
            break;
        end
        idx++;
    end

    if (ctxt == null) begin
        idx = 0;
        while (idx < m_forked_list.size()) begin
            if (m_forked_list[idx].obj == obj) begin
                ctxt = m_forked_list[idx];
                m_forked_list.delete(idx);
                m_scheduled_contexts.delete(ctxt.obj);
                break;
            end
            idx++;
        end
    end

    if (ctxt == null) begin
        if (m_forked_contexts.exists(obj)) begin
            ctxt = m_forked_contexts[obj];
            m_forked_contexts.delete(obj);
`ifndef UVM_USE_PROCESS_CONTAINER	   
            m_drain_proc[obj].kill();
            m_drain_proc.delete(obj);
`else
            m_drain_proc[obj].p.kill();
            m_drain_proc.delete(obj);
`endif
	   
        end
    end

    if (ctxt == null) begin

        if (!m_prop_mode && obj != m_top)
          m_raise(m_top,source_obj,description,count);
        else if (obj != m_top)
          m_propagate(obj, source_obj, description, count, 1, 0);
    end
    else begin
        int diff_count;

        diff_count = count - ctxt.count;

        if (diff_count != 0) begin
            if (diff_count > 0) begin
                if (!m_prop_mode && obj != m_top)
                  m_raise(m_top, source_obj, description, diff_count);
                else if (obj != m_top)
                  m_propagate(obj, source_obj, description, diff_count, 1, 0);
            end
            else begin
                diff_count = -diff_count;
                if (!m_prop_mode && obj != m_top)
                  m_drop(m_top, source_obj, description, diff_count);
                else if (obj != m_top)
                  m_propagate(obj, source_obj, description, diff_count, 0, 0);
            end
        end

        ctxt.clear();
        m_context_pool.push_back(ctxt);
    end
        
  endfunction
  


  virtual function void drop_objection (uvm_object obj=null, string description="", int count=1);
    if(obj == null)
      obj = m_top;
    m_drop (obj, obj, description, count, 0);
  endfunction



  function void m_drop (uvm_object obj, uvm_object source_obj, string description="", int count=1, int in_top_thread=0);

    if (count == 0)
      return;

    if (!m_total_count.exists(obj) || (count > m_total_count[obj])) begin
      if(m_cleared)
        return;
      uvm_report_fatal("OBJTN_ZERO", {"Object \"", obj.get_full_name(), "\" attempted to drop objection '",this.get_name(),"' count below zero"});
      return;
    end

    if (obj == source_obj) begin
      if (!m_source_count.exists(obj) || (count > m_source_count[obj])) begin
        if(m_cleared)
          return;
        uvm_report_fatal("OBJTN_ZERO", {"Object \"", obj.get_full_name(), "\" attempted to drop objection '",this.get_name(),"' count below zero"});
        return;
      end
      m_source_count[obj] -= count;
    end

    m_total_count[obj] -= count;

    if (m_trace_mode)
      m_report(obj,source_obj,description,count,"dropped");
    
    dropped(obj, source_obj, description, count);
  
    if (m_total_count[obj] != 0) begin
      if (!m_prop_mode && obj != m_top)
        m_drop(m_top,source_obj,description, count, in_top_thread);
      else if (obj != m_top) begin
        this.m_propagate(obj, source_obj, description, count, 0, in_top_thread);
      end

    end
    else begin
        uvm_objection_context_object ctxt;
        if (m_context_pool.size())
          ctxt = m_context_pool.pop_front();
        else
          ctxt = new;

        ctxt.obj = obj;
        ctxt.source_obj = source_obj;
        ctxt.description = description;
        ctxt.count = count;
        ctxt.objection = this;


        m_scheduled_list.push_back(ctxt);

    end 

  endfunction


  virtual function void clear(uvm_object obj=null);
    string name;
    uvm_objection_context_object ctxt;
    int  idx;

    if (obj==null)
      obj=m_top;
    name = obj.get_full_name();
    if (name == "")
      name = "uvm_top";
    else
      name = obj.get_full_name();
    if (!m_top_all_dropped && get_objection_total(m_top))
      uvm_report_warning("OBJTN_CLEAR",{"Object '",name, "' cleared objection counts for ",get_name()});
    m_source_count.delete();
    m_total_count.delete();

    idx = 0;
    while (idx < m_scheduled_list.size()) begin
        if (m_scheduled_list[idx].objection == this) begin
            m_scheduled_list[idx].clear();
            m_context_pool.push_back(m_scheduled_list[idx]);
            m_scheduled_list.delete(idx);
        end
        else begin
            idx++;
        end
    end

    m_scheduled_contexts.delete();
    while (m_forked_list.size()) begin
        m_forked_list[0].clear();
        m_context_pool.push_back(m_forked_list[0]);
        void'(m_forked_list.pop_front());
    end

    foreach (m_forked_contexts[o]) begin
`ifndef UVM_USE_PROCESS_CONTAINER       
        m_drain_proc[o].kill();
        m_drain_proc.delete(o);
`else
        m_drain_proc[o].p.kill();
        m_drain_proc.delete(o);
`endif
       
        m_forked_contexts[o].clear();
        m_context_pool.push_back(m_forked_contexts[o]);
        m_forked_contexts.delete(o);
    end

    m_top_all_dropped = 0;
    m_cleared = 1;
    if (m_events.exists(m_top))
      ->m_events[m_top].all_dropped;

  endfunction


  static task m_execute_scheduled_forks();
    while(1) begin
      wait(m_scheduled_list.size() != 0);
      if(m_scheduled_list.size() != 0) begin
          uvm_objection_context_object c;
          uvm_objection o;
          c = m_scheduled_list.pop_front();
          c.objection.m_scheduled_contexts[c.obj] = c;
          c.objection.m_forked_list.push_back(c);
          fork : guard
              automatic uvm_objection objection = c.objection;
              begin
                  if (objection.m_forked_list.size() > 0) begin
                      uvm_objection_context_object ctxt;
	              ctxt = objection.m_forked_list.pop_front();
                      objection.m_scheduled_contexts.delete(ctxt.obj);
                      objection.m_forked_contexts[ctxt.obj] = ctxt;
`ifndef UVM_USE_PROCESS_CONTAINER		     
                      objection.m_drain_proc[ctxt.obj] = process::self();
`else
		     begin
			process_container_c c = new(process::self());
			objection.m_drain_proc[ctxt.obj]=c;
		     end
`endif		     
                      objection.m_forked_drain(ctxt.obj, ctxt.source_obj, ctxt.description, ctxt.count, 1);
                      objection.m_drain_proc.delete(ctxt.obj);
                      objection.m_forked_contexts.delete(ctxt.obj);
                      ctxt.clear();
                      m_context_pool.push_back(ctxt);
                  end
              end
          join_none : guard
      end
    end
  endtask



  task m_forked_drain (uvm_object obj, uvm_object source_obj, string description="", int count=1, int in_top_thread=0);

      int diff_count;

      if (m_drain_time.exists(obj))
        `uvm_delay(m_drain_time[obj])
      
      if (m_trace_mode)
        m_report(obj,source_obj,description,count,"all_dropped");
      
      all_dropped(obj,source_obj,description, count);
          
      wait fork;

      if (m_source_count.exists(obj) && m_source_count[obj] == 0)
        m_source_count.delete(obj);
          
      if (m_total_count.exists(obj) && m_total_count[obj] == 0)
        m_total_count.delete(obj);

      if (!m_prop_mode && obj != m_top)
        m_drop(m_top,source_obj,description, count, 1);
      else if (obj != m_top)
        m_propagate(obj, source_obj, description, count, 0, 1);

  endtask



  static function void m_init_objections();
    fork 
      uvm_objection::m_execute_scheduled_forks();
    join_none
  endfunction


  function void set_drain_time (uvm_object obj=null, time drain);
    if (obj==null)
      obj = m_top;
    m_drain_time[obj] = drain;
  endfunction
  



  virtual function void raised (uvm_object obj, uvm_object source_obj, string description, int count);
    uvm_component comp;
    if ($cast(comp,obj))    
      comp.raised(this, source_obj, description, count);
    `uvm_do_callbacks(uvm_objection,uvm_objection_callback,raised(this,obj,source_obj,description,count))
    if (m_events.exists(obj))
       ->m_events[obj].raised;
  endfunction



  virtual function void dropped (uvm_object obj, uvm_object source_obj, string description, int count);
    uvm_component comp;
    if($cast(comp,obj))    
      comp.dropped(this, source_obj, description, count);
    `uvm_do_callbacks(uvm_objection,uvm_objection_callback,dropped(this,obj,source_obj,description,count))
    if (m_events.exists(obj))
       ->m_events[obj].dropped;
  endfunction



  virtual task all_dropped (uvm_object obj, uvm_object source_obj, string description, int count);
    uvm_component comp;
    if($cast(comp,obj))    
      comp.all_dropped(this, source_obj, description, count);
    `uvm_do_callbacks(uvm_objection,uvm_objection_callback,all_dropped(this,obj,source_obj,description,count))
    if (m_events.exists(obj))
       ->m_events[obj].all_dropped;
    if (obj == m_top)
      m_top_all_dropped = 1;
  endtask




  function void get_objectors(ref uvm_object list[$]);
    list.delete();
    foreach (m_source_count[obj]) list.push_back(obj); 
  endfunction


  task wait_for(uvm_objection_event objt_event, uvm_object obj=null);

     if (obj==null)
       obj = m_top;

     if (!m_events.exists(obj)) begin
       m_events[obj] = new;
     end

     m_events[obj].waiters++;
     case (objt_event)
       UVM_RAISED:      @(m_events[obj].raised);
       UVM_DROPPED:     @(m_events[obj].dropped);
       UVM_ALL_DROPPED: @(m_events[obj].all_dropped);
     endcase
     
     m_events[obj].waiters--;

     if (m_events[obj].waiters == 0)
       m_events.delete(obj);

   endtask


   task wait_for_total_count(uvm_object obj=null, int count=0);
     if (obj==null)
       obj = m_top;

     if(!m_total_count.exists(obj) && count == 0)
       return;
     if (count == 0)
        wait (!m_total_count.exists(obj) && count == 0);
     else
        wait (m_total_count.exists(obj) && m_total_count[obj] == count);
   endtask
   


  function int get_objection_count (uvm_object obj=null);
    if (obj==null)
      obj = m_top;

    if (!m_source_count.exists(obj))
      return 0;
    return m_source_count[obj];
  endfunction
  


  function int get_objection_total (uvm_object obj=null);
 
    if (obj==null)
      obj = m_top;

    if (!m_total_count.exists(obj))
      return 0;
    else
      return m_total_count[obj];
     
  endfunction
  


  function time get_drain_time (uvm_object obj=null);
    if (obj==null)
      obj = m_top;

    if (!m_drain_time.exists(obj))
      return 0;
    return m_drain_time[obj];
  endfunction



  protected function string m_display_objections(uvm_object obj=null, bit show_header=1);

    static string blank="                                                                                   ";
    
    string s;
    int total;
    uvm_object list[string];
    uvm_object curr_obj;
    int depth;
    string name;
    string this_obj_name;
    string curr_obj_name;
  
    foreach (m_total_count[o]) begin
      uvm_object theobj = o; 
      if ( m_total_count[o] > 0)
        list[theobj.get_full_name()] = theobj;
    end

    if (obj==null)
      obj = m_top;

    total = get_objection_total(obj);
    
    s = $sformatf("The total objection count is %0d\n",total);

    if (total == 0)
      return s;

    s = {s,"---------------------------------------------------------\n"};
    s = {s,"Source  Total   \n"};
    s = {s,"Count   Count   Object\n"};
    s = {s,"---------------------------------------------------------\n"};

  
    this_obj_name = obj.get_full_name();
    curr_obj_name = this_obj_name;

    do begin

      curr_obj = list[curr_obj_name];
  
      depth=0;
      foreach (curr_obj_name[i])
        if (curr_obj_name[i] == ".")
          depth++;

      name = curr_obj_name;
      for (int i=curr_obj_name.len()-1;i >= 0; i--)
        if (curr_obj_name[i] == ".") begin
           name = curr_obj_name.substr(i+1,curr_obj_name.len()-1); 
           break;
        end
      if (curr_obj_name == "")
        name = "uvm_top";
      else
        depth++;

      s = {s, $sformatf("%-6d  %-6d %s%s\n", m_source_count.exists(curr_obj) ? m_source_count[curr_obj] : 0, m_total_count.exists(curr_obj) ? m_total_count[curr_obj] : 0, blank.substr(0,2*depth), name)};

    end while (list.next(curr_obj_name) &&
        curr_obj_name.substr(0,this_obj_name.len()-1) == this_obj_name);
  
    s = {s,"---------------------------------------------------------\n"};

    return s;

  endfunction
  

  function string convert2string();
    return m_display_objections(m_top,1);
  endfunction
  
  

  function void display_objections(uvm_object obj=null, bit show_header=1);
	string m = m_display_objections(obj,show_header);
    `uvm_info("UVM/OBJ/DISPLAY",m,UVM_NONE)
  endfunction



  typedef uvm_object_registry#(uvm_objection,"uvm_objection") type_id;
  static function type_id get_type();
    return type_id::get();
  endfunction

  function uvm_object create (string name="");
    uvm_objection tmp = new(name);
    return tmp;
  endfunction

  virtual function string get_type_name ();
    return "uvm_objection";
  endfunction

  function void do_copy (uvm_object rhs);
    uvm_objection _rhs;
    $cast(_rhs, rhs);
    m_source_count = _rhs.m_source_count;
    m_total_count  = _rhs.m_total_count;
    m_drain_time   = _rhs.m_drain_time;
    m_prop_mode    = _rhs.m_prop_mode;
  endfunction

endclass


typedef class uvm_cmdline_processor;




class uvm_test_done_objection extends uvm_objection;

   protected static uvm_test_done_objection m_inst;
  protected bit m_forced;

  local  bit m_executing_stop_processes;
  local  int m_n_stop_threads;



  function new(string name="uvm_test_done");
    super.new(name);
  endfunction



  virtual function void qualify(uvm_object obj=null,
                                bit is_raise,
                                string description);
    uvm_component c;
    uvm_sequence_base s;
    string nm = is_raise ? "raise_objection" : "drop_objection";
    string desc = description == "" ? "" : {" (\"", description, "\")"};
    if(! ($cast(c,obj) || $cast(s,obj))) begin
      uvm_report_error("TEST_DONE_NOHIER", {"A non-hierarchical object, '", obj.get_full_name(), "' (", obj.get_type_name(),") was used in a call ", "to uvm_test_done.", nm,"(). For this objection, a sequence ", "or component is required.", desc });
    end
  endfunction

  
`ifndef UVM_NO_DEPRECATED

  task m_do_stop_all(uvm_component comp);

    string name;

    if (comp.get_first_child(name))
      do begin
        m_do_stop_all(comp.get_child(name));
      end
      while (comp.get_next_child(name));
  
    if (comp.enable_stop_interrupt) begin
      m_n_stop_threads++;
      fork begin
        comp.stop_phase(run_ph);
        m_n_stop_threads--;
      end
      join_none
    end
  endtask
 


  function void stop_request();
    `uvm_info_context("STOP_REQ", "Stop-request called. Waiting for all-dropped on uvm_test_done", UVM_FULL,m_top);
    fork
      m_stop_request();
    join_none
  endfunction

  task m_stop_request();
    raise_objection(m_top,"stop_request called; raising test_done objection");
    uvm_wait_for_nba_region();
    drop_objection(m_top,"stop_request called; dropping test_done objection");
  endtask



  time stop_timeout = 0;
   

  
  virtual task all_dropped (uvm_object obj, uvm_object source_obj, string description, int count);
    if (obj != m_top) begin
      super.all_dropped(obj,source_obj,description,count);
      return;
    end

    m_top.all_dropped(this, source_obj, description, count);

  
    if(m_cleared == 0) begin
      `uvm_info_context("TEST_DONE", "All end-of-test objections have been dropped. Calling stop tasks",
          UVM_FULL,m_top);
      fork begin 
        fork
          begin
            m_executing_stop_processes = 1;
            m_do_stop_all(m_top);
            wait (m_n_stop_threads == 0);
            m_executing_stop_processes = 0;
          end
          begin
            if (stop_timeout == 0)
              wait(stop_timeout != 0);
            `uvm_delay(stop_timeout)
            `uvm_error("STOP_TIMEOUT", {$sformatf("Stop-task timeout of %0t expired. ", stop_timeout), "'run' phase ready to proceed to extract phase"})
          end
        join_any
        disable fork;
      end
      join 
  
      `uvm_info_context("TEST_DONE", {"'run' phase is ready ", "to proceed to the 'extract' phase"}, UVM_LOW,m_top)

    end

    if (m_events.exists(obj))
      ->m_events[obj].all_dropped;
    m_top_all_dropped = 1;

  endtask



  virtual function void raise_objection (uvm_object obj=null, string description="", int count=1);
    if(obj==null)
      obj=m_top;
    else
      qualify(obj, 1, description);

    if (m_executing_stop_processes) begin
      string desc = description == "" ? "" : {"(\"", description, "\") "};
      `uvm_warning("ILLRAISE", {"The uvm_test_done objection was ", "raised ", desc, "during processing of a stop_request, i.e. stop ", "task execution. The objection is ignored by the stop process"}) return;
    end

    super.raise_objection(obj,description,count);

  endfunction



  virtual function void drop_objection (uvm_object obj=null, string description="", int count=1);
    if(obj==null)
      obj=m_top;
    else
      qualify(obj, 0, description);
    super.drop_objection(obj,description,count);
  endfunction



  virtual task force_stop(uvm_object obj=null);
    uvm_report_warning("FORCE_STOP",{"Object '", (obj!=null?obj.get_name():"<unknown>"),"' called force_stop"});
    m_cleared = 1;
    all_dropped(m_top,obj,"force_stop() called",1);
    clear(obj);
  endtask
`endif



  typedef uvm_object_registry#(uvm_test_done_objection,"uvm_test_done") type_id;
  static function type_id get_type();
    return type_id::get();
  endfunction

  function uvm_object create (string name="");
    uvm_test_done_objection tmp = new(name);
    return tmp;
  endfunction

  virtual function string get_type_name ();
    return "uvm_test_done";
  endfunction

  static function uvm_test_done_objection get();
    if(m_inst == null)
      m_inst = uvm_test_done_objection::type_id::create("run");
    return m_inst;
  endfunction

endclass



class uvm_objection_context_object;
    uvm_object obj;
    uvm_object source_obj;
    string description;
    int    count;
    uvm_objection objection;

    function void clear();
        obj = null;
        source_obj = null;
        description = "";
        count = 0;
        objection = null;
    endfunction : clear
endclass

typedef uvm_objection uvm_callbacks_objection;
   


class uvm_objection_callback extends uvm_callback;
  function new(string name);
    super.new(name);
  endfunction


  virtual function void raised (uvm_objection objection, uvm_object obj, 
      uvm_object source_obj, string description, int count);
  endfunction


  virtual function void dropped (uvm_objection objection, uvm_object obj, 
      uvm_object source_obj, string description, int count);
  endfunction


  virtual task all_dropped (uvm_objection objection, uvm_object obj, 
      uvm_object source_obj, string description, int count);
  endtask

endclass


`endif



`ifndef UVM_HEARTBEAT_SVH
`define UVM_HEARTBEAT_SVH

typedef enum {
  UVM_ALL_ACTIVE,
  UVM_ONE_ACTIVE,
  UVM_ANY_ACTIVE,
  UVM_NO_HB_MODE
} uvm_heartbeat_modes;

typedef class uvm_heartbeat_callback;
typedef uvm_callbacks #(uvm_objection,uvm_heartbeat_callback) uvm_heartbeat_cbs_t;



typedef class uvm_objection_callback;
class uvm_heartbeat extends uvm_object;

  protected uvm_objection m_objection;
  protected uvm_heartbeat_callback m_cb;
  protected uvm_component   m_cntxt;
  protected uvm_heartbeat_modes   m_mode;
  protected uvm_component   m_hblist[$];
  protected uvm_event#(uvm_object)       m_event;
  protected bit             m_started;
  protected event           m_stop_event;


  function new(string name, uvm_component cntxt, uvm_objection objection=null);
     uvm_coreservice_t cs;
    super.new(name);
    m_objection = objection;
    cs  = uvm_coreservice_t::get();
     
    if(cntxt != null) m_cntxt = cntxt;
    else m_cntxt = cs.get_root();

    m_cb = new({name,"_cb"},m_cntxt);

  endfunction



  function uvm_heartbeat_modes set_mode (uvm_heartbeat_modes mode = UVM_NO_HB_MODE);
    set_mode = m_mode;
    if(mode == UVM_ANY_ACTIVE || mode == UVM_ONE_ACTIVE || mode == UVM_ALL_ACTIVE)
      m_mode = mode;
  endfunction



  function void set_heartbeat (uvm_event#(uvm_object) e, ref uvm_component comps[$]);
    uvm_object c;
    foreach(comps[i]) begin
      c = comps[i];
      if(!m_cb.cnt.exists(c)) 
        m_cb.cnt[c]=0;
      if(!m_cb.last_trigger.exists(c)) 
        m_cb.last_trigger[c]=0;
    end
    if(e==null && m_event==null) return;
    start(e);
  endfunction


  function void add (uvm_component comp);
    uvm_object c = comp;
    if(m_cb.cnt.exists(c)) return;
    m_cb.cnt[c]=0;
    m_cb.last_trigger[c]=0;
  endfunction


  function void remove (uvm_component comp);
    uvm_object c = comp;
    if(m_cb.cnt.exists(c)) m_cb.cnt.delete(c);
    if(m_cb.last_trigger.exists(c)) m_cb.last_trigger.delete(c);
  endfunction



  function void start (uvm_event#(uvm_object) e=null);
    if(m_event == null && e == null) begin
      m_cntxt.uvm_report_warning("NOEVNT", { "start() was called for: ", get_name(), " with a null trigger and no currently set trigger" }, UVM_NONE);
      return;
    end
    if((m_event != null) && (e != m_event) && m_started) begin
      m_cntxt.uvm_report_error("ILHBVNT", { "start() was called for: ", get_name(), " with trigger ", e.get_name(), " which is different ", "from the original trigger ", m_event.get_name() }, UVM_NONE);
      return;
    end  
    if(e != null) m_event = e;
    m_enable_cb();
    m_start_hb_process();
  endfunction


  function void stop ();
    m_started = 0;
    ->m_stop_event;
    m_disable_cb();
  endfunction

  function void m_start_hb_process();
    if(m_started) return;
    m_started = 1;
    fork
      m_hb_process;
    join_none
  endfunction

  protected bit m_added;
  function void m_enable_cb;
    void'(m_cb.callback_mode(1));
    if(m_objection == null) return;
    if(!m_added) 
      uvm_heartbeat_cbs_t::add(m_objection, m_cb);
    m_added = 1;
  endfunction

  function void m_disable_cb;
    void'(m_cb.callback_mode(0));
  endfunction

  task m_hb_process;
    uvm_object obj;
    bit  triggered;
    time last_trigger=0;
    fork
      begin
        while(1) begin
          m_event.wait_trigger();
          if(triggered) begin
            case (m_mode)
              UVM_ALL_ACTIVE:              
                begin
                  foreach(m_cb.cnt[idx]) begin
                    obj = idx;
                    if(!m_cb.cnt[obj]) begin
                      m_cntxt.uvm_report_fatal("HBFAIL", $sformatf("Did not recieve an update of %s for component %s since last event trigger at time %0t : last update time was %0t",
                        m_objection.get_name(), obj.get_full_name(), 
                        last_trigger, m_cb.last_trigger[obj]), UVM_NONE);
                    end
                  end
                end 
              UVM_ANY_ACTIVE:              
                begin
                  if(m_cb.cnt.num() && !m_cb.objects_triggered()) begin
                    string s;
                    foreach(m_cb.cnt[idx]) begin
                      obj = idx;
                      s={s,"\n  ",obj.get_full_name()};
                    end
                    m_cntxt.uvm_report_fatal("HBFAIL", $sformatf("Did not recieve an update of %s on any component since last event trigger at time %0t. The list of registered components is:%s",
                      m_objection.get_name(), last_trigger, s), UVM_NONE); 
                  end
                end 
              UVM_ONE_ACTIVE:              
                begin
                  if(m_cb.objects_triggered() > 1) begin
                    string s;
                    foreach(m_cb.cnt[idx])  begin
                      obj = idx;
                      if(m_cb.cnt[obj]) $swrite(s,"%s\n  %s (updated: %0t)",
                         s, obj.get_full_name(), m_cb.last_trigger[obj]);
                    end
                    m_cntxt.uvm_report_fatal("HBFAIL", $sformatf("Recieved update of %s from more than one component since last event trigger at time %0t. The list of triggered components is:%s",
                      m_objection.get_name(), last_trigger, s), UVM_NONE); 
                  end
                  if(m_cb.cnt.num() && !m_cb.objects_triggered()) begin
                    string s;
                    foreach(m_cb.cnt[idx]) begin
                      obj = idx;
                      s={s,"\n  ",obj.get_full_name()};
                    end
                    m_cntxt.uvm_report_fatal("HBFAIL", $sformatf("Did not recieve an update of %s on any component since last event trigger at time %0t. The list of registered components is:%s",
                      m_objection.get_name(), last_trigger, s), UVM_NONE); 
                  end
                end 
            endcase
          end 
          m_cb.reset_counts();
          last_trigger = $realtime;
          triggered = 1;
        end
      end
      @(m_stop_event);
    join_any
    disable fork;
  endtask
endclass


class uvm_heartbeat_callback extends uvm_objection_callback;
  int  cnt [uvm_object];
  time last_trigger [uvm_object];
  uvm_object target;
  uvm_coreservice_t cs = uvm_coreservice_t::get();

  function new(string name, uvm_object target);
    super.new(name);
    if (target != null)
       this.target = target;
    else
       this.target = cs.get_root();
  endfunction

  virtual function void raised (uvm_objection objection, uvm_object obj, uvm_object source_obj, string description, int count);
    if(obj == target) begin
      if(!cnt.exists(source_obj))
        cnt[source_obj] = 0;
      cnt[source_obj] = cnt[source_obj]+1;
      last_trigger[source_obj] = $realtime;
    end
  endfunction

  virtual function void dropped (uvm_objection objection, uvm_object obj, uvm_object source_obj, string description, int count);
    raised(objection,obj,source_obj,description,count);
  endfunction

  function void reset_counts;
    foreach(cnt[i]) cnt[i] = 0;
  endfunction

  function int objects_triggered;
    objects_triggered = 0; 
    foreach(cnt[i])
      if (cnt[i] != 0)
        objects_triggered++;
  endfunction

endclass

`endif

task run_test (string test_name="");
  uvm_root top;
  uvm_coreservice_t cs;
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  top.run_test(test_name);
endtask

`ifndef UVM_NO_DEPRECATED

const uvm_test_done_objection uvm_test_done = uvm_test_done_objection::get();

function void global_stop_request();
  uvm_test_done_objection tdo;
  tdo = uvm_test_done_objection::get();
  tdo.stop_request();
endfunction

function void set_global_timeout(time timeout, bit overridable = 1);
  uvm_root top;
  uvm_coreservice_t cs;
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  top.set_timeout(timeout,overridable);
endfunction

function void set_global_stop_timeout(time timeout);
  uvm_test_done_objection tdo;
  tdo = uvm_test_done_objection::get();
  tdo.stop_timeout = timeout;
endfunction
`endif

function uvm_report_object uvm_get_report_object();
  uvm_root top;
  uvm_coreservice_t cs;
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  return top;
endfunction

function int uvm_report_enabled (int verbosity, uvm_severity severity=UVM_INFO, string id="");
  uvm_root top;
  uvm_coreservice_t cs;
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  return top.uvm_report_enabled(verbosity,severity,id);
endfunction


function void uvm_report( uvm_severity severity, string id, string message, int verbosity = (severity == uvm_severity'(UVM_ERROR)) ? UVM_LOW : (severity == uvm_severity'(UVM_FATAL)) ? UVM_NONE : UVM_MEDIUM, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);
  uvm_root top;
  uvm_coreservice_t cs;
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  top.uvm_report(severity, id, message, verbosity, filename, line, context_name, report_enabled_checked);
endfunction 

export "DPI-C" function m__uvm_report_dpi;
function void m__uvm_report_dpi(int severity, string id, string message, int    verbosity, string filename, int    line);
   uvm_report(uvm_severity'(severity), id, message, verbosity, filename, line);
endfunction : m__uvm_report_dpi


function void uvm_report_info(string id, string message, int verbosity = UVM_MEDIUM, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);
  uvm_root top;
  uvm_coreservice_t cs;
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  top.uvm_report_info(id, message, verbosity, filename, line, context_name, report_enabled_checked);
endfunction

function void uvm_report_warning(string id, string message, int verbosity = UVM_MEDIUM, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);
  uvm_root top;
  uvm_coreservice_t cs;
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  top.uvm_report_warning(id, message, verbosity, filename, line, context_name, report_enabled_checked);
endfunction

function void uvm_report_error(string id, string message, int verbosity = UVM_LOW, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);
  uvm_root top;
  uvm_coreservice_t cs;
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  top.uvm_report_error(id, message, verbosity, filename, line, context_name, report_enabled_checked);
endfunction

function void uvm_report_fatal(string id, string message, int verbosity = UVM_NONE, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);
  uvm_root top;
  uvm_coreservice_t cs;
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  top.uvm_report_fatal(id, message, verbosity, filename, line, context_name, report_enabled_checked);
endfunction

function void uvm_process_report_message(uvm_report_message report_message);
  uvm_root top;
  uvm_coreservice_t cs;
  process p;
  p = process::self();
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  top.uvm_process_report_message(report_message);
endfunction

function bit uvm_string_to_severity (string sev_str, output uvm_severity sev);
  case (sev_str)
    "UVM_INFO": sev = UVM_INFO;
    "UVM_WARNING": sev = UVM_WARNING;
    "UVM_ERROR": sev = UVM_ERROR;
    "UVM_FATAL": sev = UVM_FATAL;
    default: return 0;
  endcase
  return 1;
endfunction

function automatic bit uvm_string_to_action (string action_str, output uvm_action action);
  string actions[$];
  uvm_split_string(action_str,"|",actions);
  uvm_string_to_action = 1;
  action = 0;
  foreach(actions[i]) begin
    case (actions[i])
      "UVM_NO_ACTION": action |= UVM_NO_ACTION;
      "UVM_DISPLAY":   action |= UVM_DISPLAY;
      "UVM_LOG":       action |= UVM_LOG;
      "UVM_COUNT":     action |= UVM_COUNT;
      "UVM_EXIT":      action |= UVM_EXIT;
      "UVM_CALL_HOOK": action |= UVM_CALL_HOOK;
      "UVM_STOP":      action |= UVM_STOP;
      "UVM_RM_RECORD": action |= UVM_RM_RECORD;
      default: uvm_string_to_action = 0;
    endcase
  end
endfunction
  
`ifndef UVM_NO_DEPRECATED

function void  set_config_int  (string inst_name, string field_name, uvm_bitstream_t value);
  uvm_root top;
  uvm_coreservice_t cs;
  if (!uvm_component::m_config_deprecated_warned) begin
     `uvm_warning("UVM/CFG/SET/DPR", "get/set_config_* API has been deprecated. Use uvm_config_db instead.")
     uvm_component::m_config_deprecated_warned = 1;
  end
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  top.set_config_int(inst_name, field_name, value);
endfunction

function void set_config_object (string inst_name, string field_name, uvm_object value, bit clone=1);
  uvm_root top;
  uvm_coreservice_t cs;
  if (!uvm_component::m_config_deprecated_warned) begin
     `uvm_warning("UVM/CFG/SET/DPR", "get/set_config_* API has been deprecated. Use uvm_config_db instead.")
     uvm_component::m_config_deprecated_warned = 1;
  end
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  top.set_config_object(inst_name, field_name, value, clone);
endfunction

function void set_config_string (string inst_name,  string field_name, string value);
  uvm_root top;
  uvm_coreservice_t cs;
  if (!uvm_component::m_config_deprecated_warned) begin
     `uvm_warning("UVM/CFG/SET/DPR", "get/set_config_* API has been deprecated. Use uvm_config_db instead.")
     uvm_component::m_config_deprecated_warned = 1;
  end
  cs = uvm_coreservice_t::get();
  top = cs.get_root();
  top.set_config_string(inst_name, field_name, value);
endfunction
`endif

function bit uvm_is_match (string expr, string str);
  string s;
  s = uvm_glob_to_re(expr);
  return (uvm_re_match(s, str) == 0);
endfunction

parameter UVM_LINE_WIDTH = `UVM_LINE_WIDTH;
parameter UVM_NUM_LINES = `UVM_NUM_LINES;
parameter UVM_SMALL_STRING = UVM_LINE_WIDTH*8-1;
parameter UVM_LARGE_STRING = UVM_LINE_WIDTH*UVM_NUM_LINES*8-1;

function logic[UVM_LARGE_STRING:0] uvm_string_to_bits(string str);
  $swrite(uvm_string_to_bits, "%0s", str);
endfunction

function string uvm_bits_to_string(logic [UVM_LARGE_STRING:0] str);
  $swrite(uvm_bits_to_string, "%0s", str);
endfunction

task uvm_wait_for_nba_region;
  string s;
  int nba;
  int next_nba;

`ifndef UVM_NO_WAIT_FOR_NBA
  next_nba++;
  nba <= next_nba;
  @(nba);
`else
  repeat(`UVM_POUND_ZERO_COUNT) #0;
`endif
endtask

function automatic void uvm_split_string (string str, byte sep, ref string values[$]);
  int s = 0, e = 0;
  values.delete();
  while(e < str.len()) begin
    for(s=e; e<str.len(); ++e)
      if(str[e] == sep) break;
    if(s != e)
      values.push_back(str.substr(s,e-1));
    e++;
  end
endfunction

class uvm_enum_wrapper#(type T=uvm_active_passive_enum);

    protected static T map[string];

    static function bit from_name(string name, ref T value);
        if (map.size() == 0)
          m_init_map();

        if (map.exists(name)) begin
            value = map[name];
            return 1;
        end
        else begin
            return 0;
        end
    endfunction : from_name

    protected static function void m_init_map();
        T e = e.first();
        do 
          begin
            map[e.name()] = e;
            e = e.next();
          end
        while (e != e.first());
    endfunction : m_init_map

    protected function new();
    endfunction : new

endclass : uvm_enum_wrapper

`ifndef UVM_CMDLINE_PROCESSOR_SV
`define UVM_CMDLINE_PROCESSOR_SV

class uvm_cmd_line_verb;
  string comp_path;
  string id;
  uvm_verbosity verb;
  int exec_time;
endclass

class uvm_cmdline_processor extends uvm_report_object;

  static local uvm_cmdline_processor m_inst;

  static function uvm_cmdline_processor get_inst();
    if(m_inst == null) 
      m_inst = new("uvm_cmdline_proc");
    return m_inst;
  endfunction

  protected string m_argv[$]; 
  protected string m_plus_argv[$];
  protected string m_uvm_argv[$];

  function void get_args (output string args[$]);
    args = m_argv;
  endfunction

  function void get_plusargs (output string args[$]);
    args = m_plus_argv;
  endfunction

  function void get_uvm_args (output string args[$]);
    args = m_uvm_argv;
  endfunction

  function int get_arg_matches (string match, ref string args[$]);

   `ifndef UVM_CMDLINE_NO_DPI
    chandle exp_h = null;
    int len = match.len();
    args.delete();
    if((match.len() > 2) && (match[0] == "/") && (match[match.len()-1] == "/")) begin
       match = match.substr(1,match.len()-2);
       exp_h = uvm_dpi_regcomp(match);
       if(exp_h == null) begin
         uvm_report_error("UVM_CMDLINE_PROC", {"Unable to compile the regular expression: ", match}, UVM_NONE);
         return 0;
       end
    end
    foreach (m_argv[i]) begin
      if(exp_h != null) begin
        if(!uvm_dpi_regexec(exp_h, m_argv[i]))
           args.push_back(m_argv[i]);
      end
      else if((m_argv[i].len() >= len) && (m_argv[i].substr(0,len - 1) == match))
        args.push_back(m_argv[i]);
    end

    if(exp_h != null)
      uvm_dpi_regfree(exp_h);
    `endif

    return args.size();
  endfunction
 
  function int get_arg_value (string match, ref string value);
    int chars = match.len();
    get_arg_value = 0;
    foreach (m_argv[i]) begin
      if(m_argv[i].len() >= chars) begin
        if(m_argv[i].substr(0,chars-1) == match) begin
          get_arg_value++;
          if(get_arg_value == 1)
            value = m_argv[i].substr(chars,m_argv[i].len()-1);
        end
      end
    end
  endfunction

  function int get_arg_values (string match, ref string values[$]);
    int chars = match.len();

    values.delete();
    foreach (m_argv[i]) begin
      if(m_argv[i].len() >= chars) begin
        if(m_argv[i].substr(0,chars-1) == match)
          values.push_back(m_argv[i].substr(chars,m_argv[i].len()-1));
      end
    end
    return values.size();
  endfunction

  function string get_tool_name ();
    return uvm_dpi_get_tool_name();
  endfunction

  function string  get_tool_version ();
    return uvm_dpi_get_tool_version();
  endfunction

  function new(string name = "");
    string s;
    string sub;
    int doInit=1;
    super.new(name);
    do begin
      s = uvm_dpi_get_next_arg(doInit);
      doInit=0;
      if(s!="") begin
        m_argv.push_back(s);
        if(s[0] == "+") begin
          m_plus_argv.push_back(s);
        end 
        if(s.len() >= 4 && (s[0]=="-" || s[0]=="+")) begin
          sub = s.substr(1,3);
          sub = sub.toupper();
          if(sub == "UVM")
            m_uvm_argv.push_back(s);
        end 
      end
    end while(s!=""); 
  endfunction

  function bit m_convert_verb(string verb_str, output uvm_verbosity verb_enum);
    case (verb_str)
      "NONE"       : begin verb_enum = UVM_NONE;   return 1; end
      "UVM_NONE"   : begin verb_enum = UVM_NONE;   return 1; end
      "LOW"        : begin verb_enum = UVM_LOW;    return 1; end
      "UVM_LOW"    : begin verb_enum = UVM_LOW;    return 1; end
      "MEDIUM"     : begin verb_enum = UVM_MEDIUM; return 1; end
      "UVM_MEDIUM" : begin verb_enum = UVM_MEDIUM; return 1; end
      "HIGH"       : begin verb_enum = UVM_HIGH;   return 1; end
      "UVM_HIGH"   : begin verb_enum = UVM_HIGH;   return 1; end
      "FULL"       : begin verb_enum = UVM_FULL;   return 1; end
      "UVM_FULL"   : begin verb_enum = UVM_FULL;   return 1; end
      "DEBUG"      : begin verb_enum = UVM_DEBUG;  return 1; end
      "UVM_DEBUG"  : begin verb_enum = UVM_DEBUG;  return 1; end
      default      : begin                         return 0; end
    endcase
  endfunction

endclass

const uvm_cmdline_processor uvm_cmdline_proc = uvm_cmdline_processor::get_inst();

`endif 

virtual class uvm_visitor#(type NODE=uvm_component) extends uvm_object;
	function new (string name = "");
		super.new(name);
	endfunction 
	
	virtual function void begin_v(); endfunction
		
	virtual function void end_v(); endfunction

	pure virtual function void visit(NODE node);
endclass


virtual class uvm_structure_proxy#(type STRUCTURE=uvm_component) extends uvm_object;
	function new (string name = "");
		super.new(name);
	endfunction     
		
	pure virtual function void get_immediate_children(STRUCTURE s, ref STRUCTURE children[$]);
endclass    


virtual class uvm_visitor_adapter#(type STRUCTURE=uvm_component,VISITOR=uvm_visitor#(STRUCTURE)) extends uvm_object;
	
	pure virtual function void accept(STRUCTURE s, VISITOR v,uvm_structure_proxy#(STRUCTURE) p, bit invoke_begin_end=1);
	function new (string name = "");
		super.new(name);
	endfunction 
endclass


class uvm_top_down_visitor_adapter#(type STRUCTURE=uvm_component,VISITOR=uvm_visitor#(STRUCTURE)) extends uvm_visitor_adapter#(STRUCTURE,VISITOR);
	function new (string name = "");
		super.new(name);
	endfunction         
	virtual function void accept(STRUCTURE s, VISITOR v,uvm_structure_proxy#(STRUCTURE) p, bit invoke_begin_end=1);
		STRUCTURE c[$];

		if(invoke_begin_end)
			v.begin_v();

		v.visit(s);
		p.get_immediate_children(s, c);

		foreach(c[idx])
			accept(c[idx],v,p,0);

		if(invoke_begin_end)
			v.end_v();

	endfunction
endclass


class uvm_bottom_up_visitor_adapter#(type STRUCTURE=uvm_component,VISITOR=uvm_visitor#(STRUCTURE)) extends uvm_visitor_adapter#(STRUCTURE,VISITOR);
	function new (string name = "");
		super.new(name);
	endfunction         
	virtual function void accept(STRUCTURE s, VISITOR v,uvm_structure_proxy#(STRUCTURE) p, bit invoke_begin_end=1);
		STRUCTURE c[$];

		if(invoke_begin_end)
			v.begin_v();

		p.get_immediate_children(s, c);
		foreach(c[idx])
			accept(c[idx],v,p,0);

		v.visit(s);

		if(invoke_begin_end)
			v.end_v();

	endfunction
endclass

class uvm_by_level_visitor_adapter#(type STRUCTURE=uvm_component,VISITOR=uvm_visitor#(STRUCTURE)) extends uvm_visitor_adapter#(STRUCTURE,VISITOR);
	function new (string name = "");
		super.new(name);
	endfunction         
	virtual function void accept(STRUCTURE s, VISITOR v,uvm_structure_proxy#(STRUCTURE) p, bit invoke_begin_end=1);
		STRUCTURE c[$];
		c.push_back(s);

		if(invoke_begin_end)
			v.begin_v();

		while(c.size() > 0) begin
			STRUCTURE q[$];
			foreach(c[idx]) begin
				STRUCTURE t[$]; 

				v.visit(c[idx]);
				p.get_immediate_children(c[idx], t);
				q = {q,t};
			end 
			c=q;
		end 

		if(invoke_begin_end)
			v.end_v();
	endfunction
endclass

class uvm_component_proxy extends uvm_structure_proxy#(uvm_component);
	virtual function void get_immediate_children(STRUCTURE s, ref STRUCTURE children[$]);   
		s.get_children(children);   
	endfunction

	function new (string name = "");
		super.new(name);
	endfunction 
endclass

class uvm_component_name_check_visitor extends uvm_visitor#(uvm_component);
	local uvm_root _root;
		
	virtual function string get_name_constraint();
		return "^[][[:alnum:](){}_:-]([][[:alnum:](){} _:-]*[][[:alnum:](){}_:-])?$";
	endfunction

	virtual function void visit(NODE node);
`ifndef UVM_NO_DPI
		static chandle compiled_regex;
		
		if(compiled_regex==null)
			compiled_regex=uvm_dpi_regcomp(get_name_constraint());  
		
		assert(compiled_regex!=null);
		
		if(_root != node)
			if(uvm_dpi_regexec(compiled_regex, node.get_name())) 
				`uvm_warning("UVM/COMP/NAME",$sformatf("the name \"%s\" of the component \"%s\" violates the uvm component name constraints",node.get_name(),node.get_full_name()))
`endif
	endfunction 
	function new (string name = "");
		super.new(name);
	endfunction 

	virtual function void begin_v(); 
		uvm_coreservice_t cs = uvm_coreservice_t::get();
   
		_root =  cs.get_root();
`ifdef UVM_NO_DPI
		`uvm_info("UVM/COMP/NAMECHECK","This implementation of the component name checks requires DPI to be enabled",UVM_NONE)
`endif
	endfunction
	virtual function void end_v(); 
`ifndef UVM_NO_DPI
		uvm_dpi_regfree(visit.compiled_regex);
		visit.compiled_regex=null;  
`endif
	endfunction
endclass    

`endif 

`ifndef UVM_DAP_SVH
 `define UVM_DAP_SVH


virtual class uvm_set_get_dap_base#(type T=int) extends uvm_object;

   typedef uvm_set_get_dap_base#(T) this_type;

   function new(string name="unnamed-uvm_set_get_dap_base#(T)");
      super.new(name);
   endfunction : new

   pure virtual function void set(T value);

   pure virtual function bit try_set(T value);
   
   pure virtual function T get();

   pure virtual function bit try_get(output T value);

endclass : uvm_set_get_dap_base


class uvm_simple_lock_dap#(type T=int) extends uvm_set_get_dap_base#(T);

   typedef uvm_simple_lock_dap#(T) this_type;
   
   `uvm_object_param_utils(uvm_simple_lock_dap#(T))
   
   local T m_value;

   local bit m_locked;

   function new(string name="unnamed-uvm_simple_lock_dap#(T)");
      super.new(name);
      m_locked = 0;
   endfunction : new

   
   virtual function void set(T value);
      if (m_locked)
        `uvm_error("UVM/SIMPLE_LOCK_DAP/SAG", $sformatf("Attempt to set new value on '%s', but the data access policy forbids setting while locked!", get_full_name()))
      else begin
         m_value = value;
      end
   endfunction : set

   virtual function bit try_set(T value);
      if (m_locked)
        return 0;
      else begin
         m_value = value;
         return 1;
      end
   endfunction : try_set
   
   virtual  function T get();
      return m_value;
   endfunction : get

   virtual function bit try_get(output T value);
      value = get();
      return 1;
   endfunction : try_get


   function void lock();
      m_locked = 1;
   endfunction : lock

   function void unlock();
      m_locked = 0;
   endfunction : unlock

   function bit is_locked();
      return m_locked;
   endfunction : is_locked
   

   virtual function void do_copy(uvm_object rhs);
      `uvm_error("UVM/SIMPLE_LOCK_DAP/CPY", "'copy()' is not supported for 'uvm_simple_lock_dap#(T)'")
   endfunction : do_copy

   virtual function void do_pack(uvm_packer packer);
      `uvm_error("UVM/SIMPLE_LOCK_DAP/PCK", "'pack()' is not supported for 'uvm_simple_lock_dap#(T)'")
   endfunction : do_pack

   virtual function void do_unpack(uvm_packer packer);
      `uvm_error("UVM/SIMPLE_LOCK_DAP/UPK", "'unpack()' is not supported for 'uvm_simple_lock_dap#(T)'")
   endfunction : do_unpack
   
   virtual function string convert2string();
      if (m_locked)
        return $sformatf("(%s) %0p [LOCKED]", `uvm_typename(m_value), m_value);
      else
        return $sformatf("(%s) %0p [UNLOCKED]", `uvm_typename(m_value), m_value);
   endfunction : convert2string
   
   virtual function void do_print(uvm_printer printer);
      super.do_print(printer);
      printer.print_int("lock_state", m_locked, $bits(m_locked));
      printer.print_generic("value", `uvm_typename(m_value), 0, $sformatf("%0p", m_value));
   endfunction : do_print

endclass 

class uvm_get_to_lock_dap#(type T=int) extends uvm_set_get_dap_base#(T);

   typedef uvm_get_to_lock_dap#(T) this_type;
   
   `uvm_object_param_utils(uvm_get_to_lock_dap#(T))
   
   local T m_value;

   local bit m_locked;

   function new(string name="unnamed-uvm_get_to_lock_dap#(T)");
      super.new(name);
      m_locked = 0;
   endfunction : new

   
   virtual function void set(T value);
      if (m_locked)
        `uvm_error("UVM/GET_TO_LOCK_DAP/SAG", $sformatf("Attempt to set new value on '%s', but the data access policy forbids setting after a get!", get_full_name()))
      else begin
         m_value = value;
      end
   endfunction : set

   virtual function bit try_set(T value);
      if (m_locked)
        return 0;
      else begin
         m_value = value;
         return 1;
      end
   endfunction : try_set
   
   virtual  function T get();
      m_locked = 1;
      return m_value;
   endfunction : get

   virtual function bit try_get(output T value);
      value = get();
      return 1;
   endfunction : try_get


   virtual function void do_copy(uvm_object rhs);
      `uvm_error("UVM/GET_TO_LOCK_DAP/CPY", "'copy()' is not supported for 'uvm_get_to_lock_dap#(T)'")
   endfunction : do_copy

   virtual function void do_pack(uvm_packer packer);
      `uvm_error("UVM/GET_TO_LOCK_DAP/PCK", "'pack()' is not supported for 'uvm_get_to_lock_dap#(T)'")
   endfunction : do_pack

   virtual function void do_unpack(uvm_packer packer);
      `uvm_error("UVM/GET_TO_LOCK_DAP/UPK", "'unpack()' is not supported for 'uvm_get_to_lock_dap#(T)'")
   endfunction : do_unpack

   
   virtual function string convert2string();
      if (m_locked)
        return $sformatf("(%s) %0p [LOCKED]", `uvm_typename(m_value), m_value);
      else
        return $sformatf("(%s) %0p [UNLOCKED]", `uvm_typename(m_value), m_value);
   endfunction : convert2string
   
   virtual function void do_print(uvm_printer printer);
      super.do_print(printer);
      printer.print_field_int("lock_state", m_locked, $bits(m_locked));
      printer.print_generic("value", `uvm_typename(m_value), 0, $sformatf("%0p", m_value));
   endfunction : do_print

endclass 


class uvm_set_before_get_dap#(type T=int) extends uvm_set_get_dap_base#(T);

   typedef uvm_set_before_get_dap#(T) this_type;
   
   `uvm_object_param_utils(uvm_set_before_get_dap#(T))
   
   local T m_value;

   local bit m_set;

   function new(string name="unnamed-uvm_set_before_get_dap#(T)");
      super.new(name);
      m_set = 0;
   endfunction : new

   
   virtual function void set(T value);
      m_set = 1;
      m_value = value;
   endfunction : set

   virtual function bit try_set(T value);
      set(value);
      return 1;
   endfunction : try_set
   
   virtual  function T get();
      if (!m_set) begin
         `uvm_error("UVM/SET_BEFORE_GET_DAP/NO_SET", $sformatf("Attempt to get value on '%s', but the data access policy forbits calling 'get' prior to calling 'set' or 'try_set'!", get_full_name()))
      end
      return m_value;
   endfunction : get

   virtual function bit try_get(output T value);
      if (!m_set) begin
        return 0;
      end
      else begin
         value = m_value;
         return 1;
      end
   endfunction : try_get


   virtual function void do_copy(uvm_object rhs);
      `uvm_error("UVM/SET_BEFORE_GET_DAP/CPY", "'copy()' is not supported for 'uvm_set_before_get_dap#(T)'")
   endfunction : do_copy

   virtual function void do_pack(uvm_packer packer);
      `uvm_error("UVM/SET_BEFORE_GET_DAP/PCK", "'pack()' is not supported for 'uvm_set_before_get_dap#(T)'")
   endfunction : do_pack

   virtual function void do_unpack(uvm_packer packer);
      `uvm_error("UVM/SET_BEFORE_GET_DAP/UPK", "'unpack()' is not supported for 'uvm_set_before_get_dap#(T)'")
   endfunction : do_unpack

   
   virtual function string convert2string();
      if (m_set)
        return $sformatf("(%s) %0p [SET]", `uvm_typename(m_value), m_value);
      else
        return $sformatf("(%s) %0p [UNSET]", `uvm_typename(m_value), m_value);
   endfunction : convert2string
   
   virtual function void do_print(uvm_printer printer);
      super.do_print(printer);
      printer.print_field_int("set_state", m_set, $bits(m_set));
      printer.print_generic("value", `uvm_typename(m_value), 0, $sformatf("%0p", m_value));
   endfunction : do_print

endclass 

`endif 

`define UVM_TASK_ERROR "TLM interface task not implemented"
`define UVM_FUNCTION_ERROR "TLM interface function not implemented"


virtual class uvm_tlm_if_base #(type T1=int, type T2=int);

  virtual task put( input T1 t );
    uvm_report_error("put", `UVM_TASK_ERROR, UVM_NONE);
  endtask

  virtual task get( output T2 t );
    uvm_report_error("get", `UVM_TASK_ERROR, UVM_NONE);
  endtask

  virtual task peek( output T2 t );
    uvm_report_error("peek", `UVM_TASK_ERROR, UVM_NONE);
  endtask

  virtual function bit try_put( input T1 t );
    uvm_report_error("try_put", `UVM_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function bit can_put();
    uvm_report_error("can_put", `UVM_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function bit try_get( output T2 t );
    uvm_report_error("try_get", `UVM_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function bit can_get();
    uvm_report_error("can_get", `UVM_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function bit try_peek( output T2 t );
    uvm_report_error("try_peek", `UVM_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function bit can_peek();
    uvm_report_error("can_ppeek", `UVM_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual task transport( input T1 req , output T2 rsp );
    uvm_report_error("transport", `UVM_TASK_ERROR, UVM_NONE);
  endtask

  virtual function bit nb_transport(input T1 req, output T2 rsp);
    uvm_report_error("nb_transport", `UVM_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function void write( input T1 t );
    uvm_report_error("write", `UVM_FUNCTION_ERROR, UVM_NONE);
  endfunction

endclass


`define UVM_SEQ_ITEM_TASK_ERROR "Sequencer interface task not implemented"
`define UVM_SEQ_ITEM_FUNCTION_ERROR "Sequencer interface function not implemented"

virtual class uvm_sqr_if_base #(type T1=uvm_object, T2=T1);

  virtual task get_next_item(output T1 t);
    uvm_report_error("get_next_item", `UVM_SEQ_ITEM_TASK_ERROR, UVM_NONE);
  endtask

  virtual task try_next_item(output T1 t);
    uvm_report_error("try_next_item", `UVM_SEQ_ITEM_TASK_ERROR, UVM_NONE);
  endtask

  virtual function void item_done(input T2 t = null);
    uvm_report_error("item_done", `UVM_SEQ_ITEM_FUNCTION_ERROR, UVM_NONE);
  endfunction

  virtual task wait_for_sequences();
    uvm_report_error("wait_for_sequences", `UVM_SEQ_ITEM_TASK_ERROR, UVM_NONE);
  endtask

  virtual function bit has_do_available();
    uvm_report_error("has_do_available", `UVM_SEQ_ITEM_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual task get(output T1 t);
    uvm_report_error("get", `UVM_SEQ_ITEM_TASK_ERROR, UVM_NONE);
  endtask

  virtual task peek(output T1 t);
    uvm_report_error("peek", `UVM_SEQ_ITEM_TASK_ERROR, UVM_NONE);
  endtask

  virtual task put(input T2 t);
    uvm_report_error("put", `UVM_SEQ_ITEM_TASK_ERROR, UVM_NONE);
  endtask

  virtual function void put_response(input T2 t);
    uvm_report_error("put_response", `UVM_SEQ_ITEM_FUNCTION_ERROR, UVM_NONE);
  endfunction

  virtual function void disable_auto_item_recording();
    uvm_report_error("disable_auto_item_recording", `UVM_SEQ_ITEM_FUNCTION_ERROR, UVM_NONE);
  endfunction
  
  virtual function bit is_auto_item_recording_enabled();
    uvm_report_error("is_auto_item_recording_enabled", `UVM_SEQ_ITEM_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction
endclass

const int UVM_UNBOUNDED_CONNECTIONS = -1;
const string s_connection_error_id = "Connection Error";
const string s_connection_warning_id = "Connection Warning";
const string s_spaces = "                       ";

typedef class uvm_port_component_base;
typedef uvm_port_component_base uvm_port_list[string];

virtual class uvm_port_component_base extends uvm_component;
   
  function new (string name, uvm_component parent);
    super.new(name,parent);
  endfunction

  pure virtual function void get_connected_to(ref uvm_port_list list);

  pure virtual function void get_provided_to(ref uvm_port_list list);

  pure virtual function bit is_port();

  pure virtual function bit is_export();

  pure virtual function bit is_imp();

  virtual function void build_phase(uvm_phase phase);
    build(); 
    return;
  endfunction

  virtual task do_task_phase (uvm_phase phase);
  endtask
endclass

class uvm_port_component #(type PORT=uvm_object) extends uvm_port_component_base;
  
  PORT m_port;

  function new (string name, uvm_component parent, PORT port);
    super.new(name,parent);
    if (port == null)
      uvm_report_fatal("Bad usage", "Null handle to port", UVM_NONE);
    m_port = port;
  endfunction

  virtual function string get_type_name();
    if(m_port == null) return "uvm_port_component";
    return m_port.get_type_name();
  endfunction
    
  virtual function void resolve_bindings();
    m_port.resolve_bindings();
  endfunction
  
  function PORT get_port();
    return m_port;
  endfunction

  virtual function void get_connected_to(ref uvm_port_list list);
    m_port.get_connected_to(list);
  endfunction

  virtual function void get_provided_to(ref uvm_port_list list);
    m_port.get_provided_to(list);
  endfunction

  function bit is_port ();
    return m_port.is_port();
  endfunction

  function bit is_export ();
    return m_port.is_export();
  endfunction

  function bit is_imp ();
    return m_port.is_imp();
  endfunction

endclass


virtual class uvm_port_base #(type IF=uvm_void) extends IF;
   
  typedef uvm_port_base #(IF) this_type;
  protected int unsigned  m_if_mask;
  protected this_type     m_if;    
  protected int unsigned  m_def_index;
  uvm_port_component #(this_type) m_comp;
  local this_type m_provided_by[string];
  local this_type m_provided_to[string];
  local uvm_port_type_e   m_port_type;
  local int               m_min_size;
  local int               m_max_size;
  local bit               m_resolved;
  local this_type         m_imp_list[string];


  function new (string name, uvm_component parent, uvm_port_type_e port_type, int min_size=0, int max_size=1);
    uvm_component comp;
    int tmp;
    m_port_type = port_type;
    m_min_size  = min_size;
    m_max_size  = max_size;
    m_comp = new(name, parent, this);

    if (!uvm_config_int::get(m_comp, "", "check_connection_relationships",tmp))
      m_comp.set_report_id_action(s_connection_warning_id, UVM_NO_ACTION);

  endfunction

  function string get_name();
    return m_comp.get_name();
  endfunction

  virtual function string get_full_name();
    return m_comp.get_full_name();
  endfunction

  virtual function uvm_component get_parent();
    return m_comp.get_parent();
  endfunction

  virtual function uvm_port_component_base get_comp();
    return m_comp;
  endfunction

  virtual function string get_type_name();
    case( m_port_type )
      UVM_PORT : return "port";
      UVM_EXPORT : return "export";
      UVM_IMPLEMENTATION : return "implementation";
    endcase
  endfunction

  function int max_size ();
    return m_max_size;
  endfunction

  function int min_size ();
    return m_min_size;
  endfunction

  function bit is_unbounded ();
    return (m_max_size ==  UVM_UNBOUNDED_CONNECTIONS);
  endfunction

  function bit is_port ();
    return m_port_type == UVM_PORT;
  endfunction

  function bit is_export ();
    return m_port_type == UVM_EXPORT;
  endfunction

  function bit is_imp ();
    return m_port_type == UVM_IMPLEMENTATION;
  endfunction

  function int size ();
    return m_imp_list.num();
  endfunction

  function void set_if (int index=0);
    m_if = get_if(index);
    if (m_if != null)
      m_def_index = index;
  endfunction

  function int m_get_if_mask();
    return m_if_mask;
  endfunction

  function void set_default_index (int index);
    m_def_index = index;
  endfunction

  virtual function void connect (this_type provider);
     uvm_root top;
     uvm_coreservice_t cs;
     cs = uvm_coreservice_t::get();
     top = cs.get_root();
    if (end_of_elaboration_ph.get_state() == UVM_PHASE_EXECUTING || 
        end_of_elaboration_ph.get_state() == UVM_PHASE_DONE ) begin
       m_comp.uvm_report_warning("Late Connection", {"Attempt to connect ",this.get_full_name()," (of type ",this.get_type_name(), ") at or after end_of_elaboration phase.  Ignoring."});
       return;
     end

    if (provider == null) begin
      m_comp.uvm_report_error(s_connection_error_id, "Cannot connect to null port handle", UVM_NONE);
      return;
    end
    
    if (provider == this) begin
      m_comp.uvm_report_error(s_connection_error_id, "Cannot connect a port instance to itself", UVM_NONE);
      return;
    end

    if ((provider.m_if_mask & m_if_mask) != m_if_mask) begin
      m_comp.uvm_report_error(s_connection_error_id, 
        {provider.get_full_name(),
         " (of type ",provider.get_type_name(), ") does not provide the complete interface required of this port (type ", get_type_name(),")"}, UVM_NONE);
      return;
    end

    if (is_imp()) begin
      m_comp.uvm_report_error(s_connection_error_id, $sformatf( "Cannot call an imp port's connect method. An imp is connected only to the component passed in its constructor. (You attempted to bind this imp to %s)", provider.get_full_name()), UVM_NONE);
      return;
    end
  
    if (is_export() && provider.is_port()) begin
      m_comp.uvm_report_error(s_connection_error_id, $sformatf( "Cannot connect exports to ports Try calling port.connect(export) instead. (You attempted to bind this export to %s).", provider.get_full_name()), UVM_NONE);
      return;
    end
  
    void'(m_check_relationship(provider));
  
    m_provided_by[provider.get_full_name()] = provider;
    provider.m_provided_to[get_full_name()] = this;
    
  endfunction

  function void debug_connected_to (int level=0, int max_level=-1);
    int sz, num, curr_num;
    string s_sz;
    static string indent, save;
    this_type port;
  
    if (level <  0) level = 0;
    if (level == 0) begin save = ""; indent="  "; end
  
    if (max_level != -1 && level >= max_level)
      return;
  
    num = m_provided_by.num();
  
    if (m_provided_by.num() != 0) begin
      foreach (m_provided_by[nm]) begin
        curr_num++;
        port = m_provided_by[nm];
        save = {save, indent, "  | \n"};
        save = {save, indent, "  |_",nm," (",port.get_type_name(),")\n"};
        indent = (num > 1 && curr_num != num) ?  {indent,"  | "}:{indent, "    "};
        port.debug_connected_to(level+1, max_level);
        indent = indent.substr(0,indent.len()-4-1);
      end
    end
  
    if (level == 0) begin
      if (save != "")
        save = {"This port's fanout network:\n\n  ", get_full_name()," (",get_type_name(),")\n",save,"\n"};
      if (m_imp_list.num() == 0) begin
	 uvm_root top;
	 uvm_coreservice_t cs;
	 cs = uvm_coreservice_t::get();
	 top = cs.get_root();
        if (end_of_elaboration_ph.get_state() == UVM_PHASE_EXECUTING || end_of_elaboration_ph.get_state() == UVM_PHASE_DONE )  
           save = {save,"  Connected implementations: none\n"};
        else
           save = {save, "  Connected implementations: not resolved until end-of-elab\n"};
      end
      else begin
        save = {save,"  Resolved implementation list:\n"};
        foreach (m_imp_list[nm]) begin
          port = m_imp_list[nm];
          s_sz.itoa(sz);
          save = {save, indent, s_sz, ": ",nm," (",port.get_type_name(),")\n"};
          sz++;
        end
      end
      m_comp.uvm_report_info("debug_connected_to", save);
    end
  endfunction
  
  function void debug_provided_to  (int level=0, int max_level=-1);
    string nm;
    int num,curr_num;
    this_type port;
    static string indent, save;
  
    if (level <  0) level = 0; 
    if (level == 0) begin save = ""; indent = "  "; end

    if (max_level != -1 && level > max_level)
      return;
  
    num = m_provided_to.num();
  
    if (num != 0) begin
      foreach (m_provided_to[nm]) begin
        curr_num++;
        port = m_provided_to[nm];
        save = {save, indent, "  | \n"};
        save = {save, indent, "  |_",nm," (",port.get_type_name(),")\n"};
        indent = (num > 1 && curr_num != num) ?  {indent,"  | "}:{indent, "    "};
        port.debug_provided_to(level+1, max_level);
        indent = indent.substr(0,indent.len()-4-1);
      end
    end

    if (level == 0) begin
      if (save != "")
        save = {"This port's fanin network:\n\n  ", get_full_name()," (",get_type_name(),")\n",save,"\n"};
      if (m_provided_to.num() == 0)
        save = {save,indent,"This port has not been bound\n"};
      m_comp.uvm_report_info("debug_provided_to", save);
    end
  
  endfunction

  function void get_connected_to (ref uvm_port_list list);
    this_type port;
    list.delete();
    foreach (m_provided_by[name]) begin
      port = m_provided_by[name];
      list[name] = port.get_comp();
    end
  endfunction

  function void get_provided_to (ref uvm_port_list list);
    this_type port;
    list.delete();
    foreach (m_provided_to[name]) begin
      port = m_provided_to[name];
      list[name] = port.get_comp();
    end
  endfunction

  local function bit  m_check_relationship (this_type provider);  
    string s;
    this_type from;
    uvm_component from_parent;
    uvm_component to_parent;
    uvm_component from_gparent;
    uvm_component to_gparent;
  

    if (get_type_name() == "uvm_analysis_port")
      return 1;
    
    from         = this;
    from_parent  = get_parent();
    to_parent    = provider.get_parent();
  
    if (from_parent == null || to_parent == null)
      return 1;
  
    from_gparent = from_parent.get_parent();
    to_gparent   = to_parent.get_parent();
  
    if (from.is_port() && provider.is_port() && from_gparent != to_parent) begin
      s = {provider.get_full_name(), " (of type ",provider.get_type_name(), ") is not up one level of hierarchy from this port. ", "A port-to-port connection takes the form ", "child_component.child_port.connect(parent_port)"};
      m_comp.uvm_report_warning(s_connection_warning_id, s, UVM_NONE);
      return 0;
    end    
      
    else if (from.is_port() && (provider.is_export() || provider.is_imp()) &&
             from_gparent != to_gparent) begin
      s = {provider.get_full_name(), " (of type ",provider.get_type_name(), ") is not at the same level of hierarchy as this port. ", "A port-to-export connection takes the form ", "component1.port.connect(component2.export)"};
      m_comp.uvm_report_warning(s_connection_warning_id, s, UVM_NONE);
      return 0;
    end
  
    else if (from.is_export() && (provider.is_export() || provider.is_imp()) &&
             from_parent != to_gparent) begin
      s = {provider.get_full_name(), " (of type ",provider.get_type_name(), ") is not down one level of hierarchy from this export. ", "An export-to-export or export-to-imp connection takes the form ", "parent_export.connect(child_component.child_export)"};
      m_comp.uvm_report_warning(s_connection_warning_id, s, UVM_NONE);
      return 0;
    end

    return 1;
  endfunction

  local function void m_add_list(this_type provider);
    string sz;
    this_type imp;

    for (int i = 0; i < provider.size(); i++) begin
      imp = provider.get_if(i);
      if (!m_imp_list.exists(imp.get_full_name()))
        m_imp_list[imp.get_full_name()] = imp;
    end

  endfunction

  virtual function void resolve_bindings();
    if (m_resolved) 
     return;

    if (is_imp()) begin
      m_imp_list[get_full_name()] = this;
    end
    else begin
      foreach (m_provided_by[nm]) begin
        this_type port;
        port = m_provided_by[nm];
        port.resolve_bindings();
        m_add_list(port);
      end
    end
  
    m_resolved = 1;
  
    if (size() < min_size() ) begin
      m_comp.uvm_report_error(s_connection_error_id, $sformatf("connection count of %0d does not meet required minimum of %0d", size(), min_size()), UVM_NONE);
    end
  
    if (max_size() != UVM_UNBOUNDED_CONNECTIONS && size() > max_size() ) begin
      m_comp.uvm_report_error(s_connection_error_id, $sformatf("connection count of %0d exceeds maximum of %0d", size(), max_size()), UVM_NONE);
    end

    if (size())
      set_if(0);
  
  endfunction
  
  function uvm_port_base #(IF) get_if(int index=0);
    string s;
    if (size()==0) begin
      m_comp.uvm_report_warning("get_if", "Port size is zero; cannot get interface at any index", UVM_NONE);
      return null;
    end
    if (index < 0 || index >= size()) begin
      $sformat(s, "Index %0d out of range [0,%0d]", index, size()-1);
      m_comp.uvm_report_warning(s_connection_error_id, s, UVM_NONE);
      return null;
    end
    foreach (m_imp_list[nm]) begin
      if (index == 0)
        return m_imp_list[nm];
      index--;
    end
  endfunction

endclass

`ifndef UVM_TLM_IMPS_SVH
`define UVM_TLM_IMPS_SVH

`define UVM_BLOCKING_PUT_IMP(imp, TYPE, arg) \
  task put (TYPE arg); \
    imp.put(arg); \
  endtask

`define UVM_NONBLOCKING_PUT_IMP(imp, TYPE, arg) \
  function bit try_put (TYPE arg); \
    return imp.try_put(arg); \
  endfunction \
  function bit can_put(); \
    return imp.can_put(); \
  endfunction

`define UVM_BLOCKING_GET_IMP(imp, TYPE, arg) \
  task get (output TYPE arg); \
    imp.get(arg); \
  endtask

`define UVM_NONBLOCKING_GET_IMP(imp, TYPE, arg) \
  function bit try_get (output TYPE arg); \
    return imp.try_get(arg); \
  endfunction \
  function bit can_get(); \
    return imp.can_get(); \
  endfunction

`define UVM_BLOCKING_PEEK_IMP(imp, TYPE, arg) \
  task peek (output TYPE arg); \
    imp.peek(arg); \
  endtask

`define UVM_NONBLOCKING_PEEK_IMP(imp, TYPE, arg) \
  function bit try_peek (output TYPE arg); \
    return imp.try_peek(arg); \
  endfunction \
  function bit can_peek(); \
    return imp.can_peek(); \
  endfunction

`define UVM_BLOCKING_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg) \
  task transport (REQ req_arg, output RSP rsp_arg); \
    imp.transport(req_arg, rsp_arg); \
  endtask

`define UVM_NONBLOCKING_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg) \
  function bit nb_transport (REQ req_arg, output RSP rsp_arg); \
    return imp.nb_transport(req_arg, rsp_arg); \
  endfunction

`define UVM_PUT_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_PUT_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_PUT_IMP(imp, TYPE, arg)

`define UVM_GET_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_GET_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_GET_IMP(imp, TYPE, arg)

`define UVM_PEEK_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_PEEK_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_PEEK_IMP(imp, TYPE, arg)

`define UVM_BLOCKING_GET_PEEK_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_GET_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_PEEK_IMP(imp, TYPE, arg)

`define UVM_NONBLOCKING_GET_PEEK_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_GET_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_PEEK_IMP(imp, TYPE, arg)

`define UVM_GET_PEEK_IMP(imp, TYPE, arg) \
  `UVM_BLOCKING_GET_PEEK_IMP(imp, TYPE, arg) \
  `UVM_NONBLOCKING_GET_PEEK_IMP(imp, TYPE, arg)

`define UVM_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg) \
  `UVM_BLOCKING_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg) \
  `UVM_NONBLOCKING_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg)



`define UVM_TLM_GET_TYPE_NAME(NAME) \
  virtual function string get_type_name(); \
    return NAME; \
  endfunction

`define UVM_PORT_COMMON(MASK,TYPE_NAME) \
  function new (string name, uvm_component parent, \
                int min_size=1, int max_size=1); \
    super.new (name, parent, UVM_PORT, min_size, max_size); \
    m_if_mask = MASK; \
  endfunction \
  `UVM_TLM_GET_TYPE_NAME(TYPE_NAME)

`define UVM_SEQ_PORT(MASK,TYPE_NAME) \
  function new (string name, uvm_component parent, \
                int min_size=0, int max_size=1); \
    super.new (name, parent, UVM_PORT, min_size, max_size); \
    m_if_mask = MASK; \
  endfunction \
  `UVM_TLM_GET_TYPE_NAME(TYPE_NAME)
  
`define UVM_EXPORT_COMMON(MASK,TYPE_NAME) \
  function new (string name, uvm_component parent, \
                int min_size=1, int max_size=1); \
    super.new (name, parent, UVM_EXPORT, min_size, max_size); \
    m_if_mask = MASK; \
  endfunction \
  `UVM_TLM_GET_TYPE_NAME(TYPE_NAME)
  
`define UVM_IMP_COMMON(MASK,TYPE_NAME,IMP) \
  local IMP m_imp; \
  function new (string name, IMP imp); \
    super.new (name, imp, UVM_IMPLEMENTATION, 1, 1); \
    m_imp = imp; \
    m_if_mask = MASK; \
  endfunction \
  `UVM_TLM_GET_TYPE_NAME(TYPE_NAME)

`define UVM_MS_IMP_COMMON(MASK,TYPE_NAME) \
  local this_req_type m_req_imp; \
  local this_rsp_type m_rsp_imp; \
  function new (string name, this_imp_type imp, \
                this_req_type req_imp = null, this_rsp_type rsp_imp = null); \
    super.new (name, imp, UVM_IMPLEMENTATION, 1, 1); \
    if(req_imp==null) $cast(req_imp, imp); \
    if(rsp_imp==null) $cast(rsp_imp, imp); \
    m_req_imp = req_imp; \
    m_rsp_imp = rsp_imp; \
    m_if_mask = MASK; \
  endfunction  \
  `UVM_TLM_GET_TYPE_NAME(TYPE_NAME)

`endif

class uvm_blocking_put_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_BLOCKING_PUT_MASK,"uvm_blocking_put_imp",IMP)
  `UVM_BLOCKING_PUT_IMP (m_imp, T, t)
endclass

class uvm_nonblocking_put_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_NONBLOCKING_PUT_MASK,"uvm_nonblocking_put_imp",IMP)
  `UVM_NONBLOCKING_PUT_IMP (m_imp, T, t)
endclass

class uvm_put_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_PUT_MASK,"uvm_put_imp",IMP)
  `UVM_PUT_IMP (m_imp, T, t)
endclass

class uvm_blocking_get_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_BLOCKING_GET_MASK,"uvm_blocking_get_imp",IMP)
  `UVM_BLOCKING_GET_IMP (m_imp, T, t)
endclass

class uvm_nonblocking_get_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_NONBLOCKING_GET_MASK,"uvm_nonblocking_get_imp",IMP)
  `UVM_NONBLOCKING_GET_IMP (m_imp, T, t)
endclass

class uvm_get_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_GET_MASK,"uvm_get_imp",IMP)
  `UVM_GET_IMP (m_imp, T, t)
endclass

class uvm_blocking_peek_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_BLOCKING_PEEK_MASK,"uvm_blocking_peek_imp",IMP)
  `UVM_BLOCKING_PEEK_IMP (m_imp, T, t)
endclass

class uvm_nonblocking_peek_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_NONBLOCKING_PEEK_MASK,"uvm_nonblocking_peek_imp",IMP)
  `UVM_NONBLOCKING_PEEK_IMP (m_imp, T, t)
endclass

class uvm_peek_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_PEEK_MASK,"uvm_peek_imp",IMP)
  `UVM_PEEK_IMP (m_imp, T, t)
endclass

class uvm_blocking_get_peek_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_BLOCKING_GET_PEEK_MASK,"uvm_blocking_get_peek_imp",IMP)
  `UVM_BLOCKING_GET_PEEK_IMP (m_imp, T, t)
endclass

class uvm_nonblocking_get_peek_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_NONBLOCKING_GET_PEEK_MASK,"uvm_nonblocking_get_peek_imp",IMP)
  `UVM_NONBLOCKING_GET_PEEK_IMP (m_imp, T, t)
endclass

class uvm_get_peek_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_GET_PEEK_MASK,"uvm_get_peek_imp",IMP)
  `UVM_GET_PEEK_IMP (m_imp, T, t)
endclass


class uvm_blocking_master_imp #(type REQ=int, type RSP=REQ, type IMP=int, type REQ_IMP=IMP, type RSP_IMP=IMP) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  typedef IMP     this_imp_type;
  typedef REQ_IMP this_req_type;
  typedef RSP_IMP this_rsp_type;
  `UVM_MS_IMP_COMMON(`UVM_TLM_BLOCKING_MASTER_MASK,"uvm_blocking_master_imp")
  `UVM_BLOCKING_PUT_IMP (m_req_imp, REQ, t)
  `UVM_BLOCKING_GET_PEEK_IMP (m_rsp_imp, RSP, t)
endclass

class uvm_nonblocking_master_imp #(type REQ=int, type RSP=REQ, type IMP=int, type REQ_IMP=IMP, type RSP_IMP=IMP) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  typedef IMP     this_imp_type;
  typedef REQ_IMP this_req_type;
  typedef RSP_IMP this_rsp_type;
  `UVM_MS_IMP_COMMON(`UVM_TLM_NONBLOCKING_MASTER_MASK,"uvm_nonblocking_master_imp")
  `UVM_NONBLOCKING_PUT_IMP (m_req_imp, REQ, t)
  `UVM_NONBLOCKING_GET_PEEK_IMP (m_rsp_imp, RSP, t)
endclass

class uvm_master_imp #(type REQ=int, type RSP=REQ, type IMP=int, type REQ_IMP=IMP, type RSP_IMP=IMP) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  typedef IMP     this_imp_type;
  typedef REQ_IMP this_req_type;
  typedef RSP_IMP this_rsp_type;
  `UVM_MS_IMP_COMMON(`UVM_TLM_MASTER_MASK,"uvm_master_imp")
  `UVM_PUT_IMP (m_req_imp, REQ, t)
  `UVM_GET_PEEK_IMP (m_rsp_imp, RSP, t)
endclass

class uvm_blocking_slave_imp #(type REQ=int, type RSP=REQ, type IMP=int, type REQ_IMP=IMP, type RSP_IMP=IMP) extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ));
  typedef IMP     this_imp_type;
  typedef REQ_IMP this_req_type;
  typedef RSP_IMP this_rsp_type;
  `UVM_MS_IMP_COMMON(`UVM_TLM_BLOCKING_SLAVE_MASK,"uvm_blocking_slave_imp")
  `UVM_BLOCKING_PUT_IMP (m_rsp_imp, RSP, t)
  `UVM_BLOCKING_GET_PEEK_IMP (m_req_imp, REQ, t)
endclass

class uvm_nonblocking_slave_imp #(type REQ=int, type RSP=REQ, type IMP=int, type REQ_IMP=IMP, type RSP_IMP=IMP) extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ));
  typedef IMP     this_imp_type;
  typedef REQ_IMP this_req_type;
  typedef RSP_IMP this_rsp_type;
  `UVM_MS_IMP_COMMON(`UVM_TLM_NONBLOCKING_SLAVE_MASK,"uvm_nonblocking_slave_imp")
  `UVM_NONBLOCKING_PUT_IMP (m_rsp_imp, RSP, t)
  `UVM_NONBLOCKING_GET_PEEK_IMP (m_req_imp, REQ, t)
endclass

class uvm_slave_imp #(type REQ=int, type RSP=REQ, type IMP=int, type REQ_IMP=IMP, type RSP_IMP=IMP) extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ));
  typedef IMP     this_imp_type;
  typedef REQ_IMP this_req_type;
  typedef RSP_IMP this_rsp_type;
  `UVM_MS_IMP_COMMON(`UVM_TLM_SLAVE_MASK,"uvm_slave_imp")
  `UVM_PUT_IMP (m_rsp_imp, RSP, t)
  `UVM_GET_PEEK_IMP (m_req_imp, REQ, t)
endclass

class uvm_blocking_transport_imp #(type REQ=int, type RSP=REQ, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_IMP_COMMON(`UVM_TLM_BLOCKING_TRANSPORT_MASK,"uvm_blocking_transport_imp",IMP)
  `UVM_BLOCKING_TRANSPORT_IMP (m_imp, REQ, RSP, req, rsp)
endclass

class uvm_nonblocking_transport_imp #(type REQ=int, type RSP=REQ, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_IMP_COMMON(`UVM_TLM_NONBLOCKING_TRANSPORT_MASK,"uvm_nonblocking_transport_imp",IMP)
  `UVM_NONBLOCKING_TRANSPORT_IMP (m_imp, REQ, RSP, req, rsp)
endclass

class uvm_transport_imp #(type REQ=int, type RSP=REQ, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_IMP_COMMON(`UVM_TLM_TRANSPORT_MASK,"uvm_transport_imp",IMP)
  `UVM_BLOCKING_TRANSPORT_IMP (m_imp, REQ, RSP, req, rsp)
  `UVM_NONBLOCKING_TRANSPORT_IMP (m_imp, REQ, RSP, req, rsp)
endclass


class uvm_blocking_put_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_BLOCKING_PUT_MASK,"uvm_blocking_put_port")
  `UVM_BLOCKING_PUT_IMP (this.m_if, T, t)
endclass 

class uvm_nonblocking_put_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_NONBLOCKING_PUT_MASK,"uvm_nonblocking_put_port")
  `UVM_NONBLOCKING_PUT_IMP (this.m_if, T, t)
endclass

class uvm_put_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_PUT_MASK,"uvm_put_port")
  `UVM_PUT_IMP (this.m_if, T, t)
endclass

class uvm_blocking_get_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_BLOCKING_GET_MASK,"uvm_blocking_get_port")
  `UVM_BLOCKING_GET_IMP (this.m_if, T, t)
endclass 

class uvm_nonblocking_get_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_NONBLOCKING_GET_MASK,"uvm_nonblocking_get_port")
  `UVM_NONBLOCKING_GET_IMP (this.m_if, T, t)
endclass

class uvm_get_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_GET_MASK,"uvm_get_port")
  `UVM_GET_IMP (this.m_if, T, t)
endclass 

class uvm_blocking_peek_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_BLOCKING_PEEK_MASK,"uvm_blocking_peek_port")
  `UVM_BLOCKING_PEEK_IMP (this.m_if, T, t)
endclass 

class uvm_nonblocking_peek_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_NONBLOCKING_PEEK_MASK,"uvm_nonblocking_peek_port")
  `UVM_NONBLOCKING_PEEK_IMP (this.m_if, T, t)
endclass

class uvm_peek_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_PEEK_MASK,"uvm_peek_port")
  `UVM_PEEK_IMP (this.m_if, T, t)
endclass 

class uvm_blocking_get_peek_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_BLOCKING_GET_PEEK_MASK,"uvm_blocking_get_peek_port")
  `UVM_BLOCKING_GET_PEEK_IMP (this.m_if, T, t)
endclass 

class uvm_nonblocking_get_peek_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_NONBLOCKING_GET_PEEK_MASK,"uvm_nonblocking_get_peek_port")
  `UVM_NONBLOCKING_GET_PEEK_IMP (this.m_if, T, t)
endclass

class uvm_get_peek_port #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_PORT_COMMON(`UVM_TLM_GET_PEEK_MASK,"uvm_get_peek_port")
  `UVM_GET_PEEK_IMP (this.m_if, T, t)
endclass 


class uvm_blocking_master_port #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_PORT_COMMON(`UVM_TLM_BLOCKING_MASTER_MASK,"uvm_blocking_master_port")
  `UVM_BLOCKING_PUT_IMP (this.m_if, REQ, t)
  `UVM_BLOCKING_GET_PEEK_IMP (this.m_if, RSP, t)
endclass 

class uvm_nonblocking_master_port #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_PORT_COMMON(`UVM_TLM_NONBLOCKING_MASTER_MASK,"uvm_nonblocking_master_port")
  `UVM_NONBLOCKING_PUT_IMP (this.m_if, REQ, t)
  `UVM_NONBLOCKING_GET_PEEK_IMP (this.m_if, RSP, t)
endclass 

class uvm_master_port #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_PORT_COMMON(`UVM_TLM_MASTER_MASK,"uvm_master_port")
  `UVM_PUT_IMP (this.m_if, REQ, t)
  `UVM_GET_PEEK_IMP (this.m_if, RSP, t)
endclass

class uvm_blocking_slave_port #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ));
  `UVM_PORT_COMMON(`UVM_TLM_BLOCKING_SLAVE_MASK,"uvm_blocking_slave_port")
  `UVM_BLOCKING_PUT_IMP (this.m_if, RSP, t)
  `UVM_BLOCKING_GET_PEEK_IMP (this.m_if, REQ, t)
endclass 

class uvm_nonblocking_slave_port #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ));
  `UVM_PORT_COMMON(`UVM_TLM_NONBLOCKING_SLAVE_MASK,"uvm_nonblocking_slave_port")
  `UVM_NONBLOCKING_PUT_IMP (this.m_if, RSP, t)
  `UVM_NONBLOCKING_GET_PEEK_IMP (this.m_if, REQ, t)
endclass 

class uvm_slave_port #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ));
  `UVM_PORT_COMMON(`UVM_TLM_SLAVE_MASK,"uvm_slave_port")
  `UVM_PUT_IMP (this.m_if, RSP, t)
  `UVM_GET_PEEK_IMP (this.m_if, REQ, t)
endclass

class uvm_blocking_transport_port #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_PORT_COMMON(`UVM_TLM_BLOCKING_TRANSPORT_MASK,"uvm_blocking_transport_port")
  `UVM_BLOCKING_TRANSPORT_IMP (this.m_if, REQ, RSP, req, rsp)
endclass

class uvm_nonblocking_transport_port #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_PORT_COMMON(`UVM_TLM_NONBLOCKING_TRANSPORT_MASK,"uvm_nonblocking_transport_port")
  `UVM_NONBLOCKING_TRANSPORT_IMP (this.m_if, REQ, RSP, req, rsp)
endclass

class uvm_transport_port #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_PORT_COMMON(`UVM_TLM_TRANSPORT_MASK,"uvm_transport_port")
  `UVM_TRANSPORT_IMP (this.m_if, REQ, RSP, req, rsp)
endclass


class uvm_blocking_put_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_BLOCKING_PUT_MASK,"uvm_blocking_put_export")
  `UVM_BLOCKING_PUT_IMP (this.m_if, T, t)
endclass 

class uvm_nonblocking_put_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_NONBLOCKING_PUT_MASK,"uvm_nonblocking_put_export")
  `UVM_NONBLOCKING_PUT_IMP (this.m_if, T, t)
endclass

class uvm_put_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_PUT_MASK,"uvm_put_export")
  `UVM_PUT_IMP (this.m_if, T, t)
endclass

class uvm_blocking_get_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_BLOCKING_GET_MASK,"uvm_blocking_get_export")
  `UVM_BLOCKING_GET_IMP (this.m_if, T, t)
endclass 

class uvm_nonblocking_get_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_NONBLOCKING_GET_MASK,"uvm_nonblocking_get_export")
  `UVM_NONBLOCKING_GET_IMP (this.m_if, T, t)
endclass

class uvm_get_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_GET_MASK,"uvm_get_export")
  `UVM_GET_IMP (this.m_if, T, t)
endclass 

class uvm_blocking_peek_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_BLOCKING_PEEK_MASK,"uvm_blocking_peek_export")
  `UVM_BLOCKING_PEEK_IMP (this.m_if, T, t)
endclass 

class uvm_nonblocking_peek_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_NONBLOCKING_PEEK_MASK,"uvm_nonblocking_peek_export")
  `UVM_NONBLOCKING_PEEK_IMP (this.m_if, T, t)
endclass

class uvm_peek_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_PEEK_MASK,"uvm_peek_export")
  `UVM_PEEK_IMP (this.m_if, T, t)
endclass 

class uvm_blocking_get_peek_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_BLOCKING_GET_PEEK_MASK,"uvm_blocking_get_peek_export")
  `UVM_BLOCKING_GET_PEEK_IMP (this.m_if, T, t)
endclass 

class uvm_nonblocking_get_peek_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_NONBLOCKING_GET_PEEK_MASK,"uvm_nonblocking_get_peek_export")
  `UVM_NONBLOCKING_GET_PEEK_IMP (this.m_if, T, t)
endclass

class uvm_get_peek_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_EXPORT_COMMON(`UVM_TLM_GET_PEEK_MASK,"uvm_get_peek_export")
  `UVM_GET_PEEK_IMP (this.m_if, T, t)
endclass 


class uvm_blocking_master_export #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_EXPORT_COMMON(`UVM_TLM_BLOCKING_MASTER_MASK,"uvm_blocking_master_export")
  `UVM_BLOCKING_PUT_IMP (this.m_if, REQ, t)
  `UVM_BLOCKING_GET_PEEK_IMP (this.m_if, RSP, t)
endclass 

class uvm_nonblocking_master_export #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_EXPORT_COMMON(`UVM_TLM_NONBLOCKING_MASTER_MASK,"uvm_nonblocking_master_export")
  `UVM_NONBLOCKING_PUT_IMP (this.m_if, REQ, t)
  `UVM_NONBLOCKING_GET_PEEK_IMP (this.m_if, RSP, t)
endclass 

class uvm_master_export #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_EXPORT_COMMON(`UVM_TLM_MASTER_MASK,"uvm_master_export")
  `UVM_PUT_IMP (this.m_if, REQ, t)
  `UVM_GET_PEEK_IMP (this.m_if, RSP, t)
endclass

class uvm_blocking_slave_export #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ));
  `UVM_EXPORT_COMMON(`UVM_TLM_BLOCKING_SLAVE_MASK,"uvm_blocking_slave_export")
  `UVM_BLOCKING_PUT_IMP (this.m_if, RSP, t)
  `UVM_BLOCKING_GET_PEEK_IMP (this.m_if, REQ, t)
endclass 

class uvm_nonblocking_slave_export #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ));
  `UVM_EXPORT_COMMON(`UVM_TLM_NONBLOCKING_SLAVE_MASK,"uvm_nonblocking_slave_export")
  `UVM_NONBLOCKING_PUT_IMP (this.m_if, RSP, t)
  `UVM_NONBLOCKING_GET_PEEK_IMP (this.m_if, REQ, t)
endclass 

class uvm_slave_export #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(RSP, REQ));
  `UVM_EXPORT_COMMON(`UVM_TLM_SLAVE_MASK,"uvm_slave_export")
  `UVM_PUT_IMP (this.m_if, RSP, t)
  `UVM_GET_PEEK_IMP (this.m_if, REQ, t)
endclass

class uvm_blocking_transport_export #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_EXPORT_COMMON(`UVM_TLM_BLOCKING_TRANSPORT_MASK,"uvm_blocking_transport_export")
  `UVM_BLOCKING_TRANSPORT_IMP (this.m_if, REQ, RSP, req, rsp)
endclass

class uvm_nonblocking_transport_export #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_EXPORT_COMMON(`UVM_TLM_NONBLOCKING_TRANSPORT_MASK,"uvm_nonblocking_transport_export")
  `UVM_NONBLOCKING_TRANSPORT_IMP (this.m_if, REQ, RSP, req, rsp)
endclass

class uvm_transport_export #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_tlm_if_base #(REQ, RSP));
  `UVM_EXPORT_COMMON(`UVM_TLM_TRANSPORT_MASK,"uvm_transport_export")
  `UVM_TRANSPORT_IMP (this.m_if, REQ, RSP, req, rsp)
endclass

class uvm_analysis_port # (type T = int) extends uvm_port_base # (uvm_tlm_if_base #(T,T));

  function new (string name, uvm_component parent);
    super.new (name, parent, UVM_PORT, 0, UVM_UNBOUNDED_CONNECTIONS);
    m_if_mask = `UVM_TLM_ANALYSIS_MASK;  
  endfunction

  virtual function string get_type_name();
    return "uvm_analysis_port";
  endfunction

  function void write (input T t);
    uvm_tlm_if_base # (T, T) tif;
    for (int i = 0; i < this.size(); i++) begin
      tif = this.get_if (i);
      if ( tif == null )
        uvm_report_fatal ("NTCONN", {"No uvm_tlm interface is connected to ", get_full_name(), " for executing write()"}, UVM_NONE);
      tif.write (t);
    end 
  endfunction

endclass

class uvm_analysis_imp #(type T=int, type IMP=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));
  `UVM_IMP_COMMON(`UVM_TLM_ANALYSIS_MASK,"uvm_analysis_imp",IMP)
  function void write (input T t);
    m_imp.write (t);
  endfunction
endclass

class uvm_analysis_export #(type T=int) extends uvm_port_base #(uvm_tlm_if_base #(T,T));

  function new (string name, uvm_component parent = null);
    super.new (name, parent, UVM_EXPORT, 1, UVM_UNBOUNDED_CONNECTIONS);
    m_if_mask = `UVM_TLM_ANALYSIS_MASK;
  endfunction

  virtual function string get_type_name();
    return "uvm_analysis_export";
  endfunction
  
  function void write (input T t);
    uvm_tlm_if_base #(T, T) tif;
    for (int i = 0; i < this.size(); i++) begin
      tif = this.get_if (i);
      if (tif == null)
         uvm_report_fatal ("NTCONN", {"No uvm_tlm interface is connected to ", get_full_name(), " for executing write()"}, UVM_NONE);
      tif.write (t);
    end 
  endfunction

endclass

`define UVM_TLM_FIFO_TASK_ERROR "fifo channel task not implemented"
`define UVM_TLM_FIFO_FUNCTION_ERROR "fifo channel function not implemented"

class uvm_tlm_event;
  event trigger;
endclass

virtual class uvm_tlm_fifo_base #(type T=int) extends uvm_component;

  typedef uvm_tlm_fifo_base #(T) this_type;
  uvm_put_imp #(T, this_type) put_export;
  uvm_get_peek_imp #(T, this_type) get_peek_export;  
  uvm_analysis_port #(T) put_ap;
  uvm_analysis_port #(T) get_ap;
  uvm_put_imp      #(T, this_type) blocking_put_export;
  uvm_put_imp      #(T, this_type) nonblocking_put_export;
  uvm_get_peek_imp #(T, this_type) blocking_get_export;
  uvm_get_peek_imp #(T, this_type) nonblocking_get_export;
  uvm_get_peek_imp #(T, this_type) get_export;
  uvm_get_peek_imp #(T, this_type) blocking_peek_export;
  uvm_get_peek_imp #(T, this_type) nonblocking_peek_export;
  uvm_get_peek_imp #(T, this_type) peek_export;
  uvm_get_peek_imp #(T, this_type) blocking_get_peek_export;
  uvm_get_peek_imp #(T, this_type) nonblocking_get_peek_export;

  function new(string name, uvm_component parent = null);
    super.new(name, parent);

    put_export = new("put_export", this);
    blocking_put_export     = put_export;
    nonblocking_put_export  = put_export;

    get_peek_export = new("get_peek_export", this);
    blocking_get_peek_export    = get_peek_export;
    nonblocking_get_peek_export = get_peek_export;
    blocking_get_export         = get_peek_export;
    nonblocking_get_export      = get_peek_export;
    get_export                  = get_peek_export;
    blocking_peek_export        = get_peek_export;
    nonblocking_peek_export     = get_peek_export;
    peek_export                 = get_peek_export;

    put_ap = new("put_ap", this);
    get_ap = new("get_ap", this);
    
  endfunction

  virtual function void build_phase(uvm_phase phase);
    build(); 
    return;
  endfunction

  virtual function void flush();
    uvm_report_error("flush", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
  endfunction
  
  virtual function int size();
    uvm_report_error("size", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual task put(T t);
    uvm_report_error("put", `UVM_TLM_FIFO_TASK_ERROR, UVM_NONE);
  endtask

  virtual task get(output T t);
    uvm_report_error("get", `UVM_TLM_FIFO_TASK_ERROR, UVM_NONE);
  endtask

  virtual task peek(output T t);
    uvm_report_error("peek", `UVM_TLM_FIFO_TASK_ERROR, UVM_NONE);
  endtask
  
  virtual function bit try_put(T t);
    uvm_report_error("try_put", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function bit try_get(output T t);
    uvm_report_error("try_get", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function bit try_peek(output T t);
    uvm_report_error("try_peek", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction
  
  virtual function bit can_put();
    uvm_report_error("can_put", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function bit can_get();
    uvm_report_error("can_get", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function bit can_peek();
    uvm_report_error("can_peek", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function uvm_tlm_event ok_to_put();
    uvm_report_error("ok_to_put", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return null;
  endfunction

  virtual function uvm_tlm_event ok_to_get();
    uvm_report_error("ok_to_get", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return null;
  endfunction

  virtual function uvm_tlm_event ok_to_peek();
    uvm_report_error("ok_to_peek", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return null;
  endfunction

  virtual function bit is_empty();
    uvm_report_error("is_empty", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

  virtual function bit is_full();
    uvm_report_error("is_full", `UVM_TLM_FIFO_FUNCTION_ERROR);
    return 0;
  endfunction

  virtual function int used();
    uvm_report_error("used", `UVM_TLM_FIFO_FUNCTION_ERROR, UVM_NONE);
    return 0;
  endfunction

endclass

typedef class uvm_tlm_event;

class uvm_tlm_fifo #(type T=int) extends uvm_tlm_fifo_base #(T);

  const static string type_name = "uvm_tlm_fifo #(T)";
  local mailbox #( T ) m;
  local int m_size;
  protected int m_pending_blocked_gets;

  function new(string name, uvm_component parent = null, int size = 1);
    super.new(name, parent);
    m = new( size );
    m_size = size;
  endfunction

  virtual function string get_type_name();
    return type_name;
  endfunction

  virtual function int size();
    return m_size;
  endfunction

  virtual function int used();
    return m.num();
  endfunction

  virtual function bit is_empty();
    return (m.num() == 0);
  endfunction

  virtual function bit is_full();
    return (m_size != 0) && (m.num() == m_size);
  endfunction

  virtual task put( input T t );
    m.put( t );
    put_ap.write( t );
  endtask

  virtual task get( output T t );
    m_pending_blocked_gets++;
    m.get( t );
    m_pending_blocked_gets--;
    get_ap.write( t );
  endtask
  
  virtual task peek( output T t );
    m.peek( t );
  endtask
   
  virtual function bit try_get( output T t );
    if( !m.try_get( t ) ) begin
      return 0;
    end

    get_ap.write( t );
    return 1;
  endfunction 
  
  virtual function bit try_peek( output T t );
    if( !m.try_peek( t ) ) begin
      return 0;
    end
    return 1;
  endfunction

  virtual function bit try_put( input T t );
    if( !m.try_put( t ) ) begin
      return 0;
    end
  
    put_ap.write( t );
    return 1;
  endfunction  

  virtual function bit can_put();
    return m_size == 0 || m.num() < m_size;
  endfunction  

  virtual function bit can_get();
    return m.num() > 0 && m_pending_blocked_gets == 0;
  endfunction
  
  virtual function bit can_peek();
    return m.num() > 0;
  endfunction

  virtual function void flush();
    T t;
    bit r;

    r = 1; 
    while( r ) r = try_get( t ) ;
    
    if( m.num() > 0 && m_pending_blocked_gets != 0 ) begin
      uvm_report_error("flush failed" , "there are blocked gets preventing the flush", UVM_NONE);
    end
  
  endfunction
 
endclass 


class uvm_tlm_analysis_fifo #(type T = int) extends uvm_tlm_fifo #(T);

  uvm_analysis_imp #(T, uvm_tlm_analysis_fifo #(T)) analysis_export;

  function new(string name ,  uvm_component parent = null);
    super.new(name, parent, 0); 
    analysis_export = new("analysis_export", this);
  endfunction

  const static string type_name = "uvm_tlm_analysis_fifo #(T)";

  virtual function string get_type_name();
    return type_name;
  endfunction

  function void write(input T t);
    void'(this.try_put(t)); 
  endfunction

endclass

class uvm_tlm_req_rsp_channel #(type REQ=int, type RSP=REQ) extends uvm_component;

  typedef uvm_tlm_req_rsp_channel #(REQ, RSP) this_type;

  const static string type_name = "uvm_tlm_req_rsp_channel #(REQ,RSP)";
  uvm_put_export #(REQ) put_request_export;
  uvm_get_peek_export #(RSP) get_peek_response_export;
  uvm_get_peek_export #(REQ) get_peek_request_export;
  uvm_put_export #(RSP) put_response_export;
  uvm_analysis_port #(REQ) request_ap;
  uvm_analysis_port   #(RSP) response_ap;
  uvm_master_imp #(REQ, RSP, this_type, uvm_tlm_fifo #(REQ), uvm_tlm_fifo #(RSP)) master_export;
  uvm_slave_imp  #(REQ, RSP, this_type, uvm_tlm_fifo #(REQ), uvm_tlm_fifo #(RSP)) slave_export;
  uvm_put_export      #(REQ) blocking_put_request_export, nonblocking_put_request_export;
  uvm_get_peek_export #(REQ) get_request_export,
                             blocking_get_request_export,
                             nonblocking_get_request_export,
                             peek_request_export,
                             blocking_peek_request_export,
                             nonblocking_peek_request_export,
                             blocking_get_peek_request_export,
                             nonblocking_get_peek_request_export;

  uvm_put_export      #(RSP) blocking_put_response_export,
                             nonblocking_put_response_export;
  uvm_get_peek_export #(RSP) get_response_export,
                             blocking_get_response_export,
                             nonblocking_get_response_export,
                             peek_response_export,
                             blocking_peek_response_export,
                             nonblocking_peek_response_export,
                             blocking_get_peek_response_export,
                             nonblocking_get_peek_response_export;

  uvm_master_imp #(REQ, RSP, this_type, uvm_tlm_fifo #(REQ), uvm_tlm_fifo #(RSP))
                             blocking_master_export, 
                             nonblocking_master_export;

  uvm_slave_imp  #(REQ, RSP, this_type, uvm_tlm_fifo #(REQ), uvm_tlm_fifo #(RSP))
                             blocking_slave_export, 
                             nonblocking_slave_export;
  protected uvm_tlm_fifo #(REQ) m_request_fifo;
  protected uvm_tlm_fifo #(RSP) m_response_fifo;

  function new (string name, uvm_component parent=null, int request_fifo_size=1, int response_fifo_size=1);

    super.new (name, parent);

    m_request_fifo  = new ("request_fifo",  this, request_fifo_size);
    m_response_fifo = new ("response_fifo", this, response_fifo_size);

    request_ap      = new ("request_ap",  this);
    response_ap     = new ("response_ap", this);
            
    put_request_export       = new ("put_request_export",       this);
    get_peek_request_export  = new ("get_peek_request_export",  this);

    put_response_export      = new ("put_response_export",      this); 
    get_peek_response_export = new ("get_peek_response_export", this);

    master_export   = new ("master_export", this, m_request_fifo, m_response_fifo);
    slave_export    = new ("slave_export",  this, m_request_fifo, m_response_fifo);

    create_aliased_exports();

    set_report_id_action_hier(s_connection_error_id, UVM_NO_ACTION);

  endfunction

  virtual function void connect_phase(uvm_phase phase);
    put_request_export.connect       (m_request_fifo.put_export);
    get_peek_request_export.connect  (m_request_fifo.get_peek_export);
    m_request_fifo.put_ap.connect    (request_ap);
    put_response_export.connect      (m_response_fifo.put_export);
    get_peek_response_export.connect (m_response_fifo.get_peek_export);
    m_response_fifo.put_ap.connect   (response_ap);
  endfunction

  function void create_aliased_exports();
    blocking_put_request_export         = put_request_export;
    nonblocking_put_request_export      = put_request_export;
    get_request_export                  = get_peek_request_export;
    blocking_get_request_export         = get_peek_request_export;
    nonblocking_get_request_export      = get_peek_request_export;
    peek_request_export                 = get_peek_request_export;
    blocking_peek_request_export        = get_peek_request_export;
    nonblocking_peek_request_export     = get_peek_request_export;
    blocking_get_peek_request_export    = get_peek_request_export;
    nonblocking_get_peek_request_export = get_peek_request_export;
  
    blocking_put_response_export         = put_response_export;
    nonblocking_put_response_export      = put_response_export;
    get_response_export                  = get_peek_response_export;
    blocking_get_response_export         = get_peek_response_export;
    nonblocking_get_response_export      = get_peek_response_export;
    peek_response_export                 = get_peek_response_export;
    blocking_peek_response_export        = get_peek_response_export;
    nonblocking_peek_response_export     = get_peek_response_export;
    blocking_get_peek_response_export    = get_peek_response_export;
    nonblocking_get_peek_response_export = get_peek_response_export;
  
    blocking_master_export    = master_export; 
    nonblocking_master_export = master_export;
    blocking_slave_export     = slave_export;
    nonblocking_slave_export  = slave_export;
  endfunction
  

  function string get_type_name ();
    return type_name;
  endfunction
  
  function uvm_object create (string name=""); 
    this_type v;
    v=new(name);
    return v;
  endfunction

endclass

class uvm_tlm_transport_channel #(type REQ=int, type RSP=REQ) extends uvm_tlm_req_rsp_channel #(REQ, RSP);

  typedef uvm_tlm_transport_channel #(REQ, RSP) this_type;
  uvm_transport_imp #(REQ, RSP, this_type) transport_export;

  function new (string name, uvm_component parent=null);
    super.new(name, parent, 1, 1);
    transport_export = new("transport_export", this);
  endfunction

  task transport (REQ request, output RSP response );
    this.m_request_fifo.put( request );
    this.m_response_fifo.get( response );
  endtask

  function bit nb_transport (REQ req, output RSP rsp );
    if(this.m_request_fifo.try_put(req)) 
      return this.m_response_fifo.try_get(rsp);
    else
      return 0;
  endfunction

endclass

class uvm_seq_item_pull_port #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_sqr_if_base #(REQ, RSP));
  `UVM_SEQ_PORT(`UVM_SEQ_ITEM_PULL_MASK, "uvm_seq_item_pull_port")
  `UVM_SEQ_ITEM_PULL_IMP(this.m_if, REQ, RSP, t, t)
  bit print_enabled;
endclass

class uvm_seq_item_pull_export #(type REQ=int, type RSP=REQ) extends uvm_port_base #(uvm_sqr_if_base #(REQ, RSP));
  `UVM_EXPORT_COMMON(`UVM_SEQ_ITEM_PULL_MASK, "uvm_seq_item_pull_export")
  `UVM_SEQ_ITEM_PULL_IMP(this.m_if, REQ, RSP, t, t)
endclass

class uvm_seq_item_pull_imp #(type REQ=int, type RSP=REQ, type IMP=int) extends uvm_port_base #(uvm_sqr_if_base #(REQ, RSP));
  `UVM_IMP_COMMON(`UVM_SEQ_ITEM_PULL_MASK, "uvm_seq_item_pull_imp",IMP)
  `UVM_SEQ_ITEM_PULL_IMP(m_imp, REQ, RSP, t, t)
endclass


class uvm_class_pair #(type T1=int, T2=T1) extends uvm_object;

  typedef uvm_class_pair #(T1, T2 ) this_type;
  const static string type_name = "uvm_class_pair #(T1,T2)";
  T1 first;
  T2 second;

  `uvm_object_param_utils(this_type)
  
  function new (string name="", T1 f=null, T2 s=null);

    super.new(name);

    if (f == null)
      first = new;
    else
      first = f;

    if (s == null)
      second = new;
    else
      second = s;

  endfunction  
  
  virtual function string get_type_name ();
    return type_name;
  endfunction

  virtual function string convert2string;
    string s;
    $sformat(s, "pair : %s, %s", first.convert2string(), second.convert2string());
    return s;    
  endfunction

  virtual function bit do_compare(uvm_object rhs, uvm_comparer comparer);
    this_type rhs_;
    if(!$cast(rhs_,rhs)) begin
      `uvm_error("WRONG_TYPE", {"do_compare: rhs argument is not of type '",get_type_name(),"'"})
      return 0;
    end
    return first.compare(rhs_.first) && second.compare(rhs_.second);
  endfunction

  virtual function void do_copy (uvm_object rhs);
    this_type rhs_;
    if(!$cast(rhs_,rhs))
      `uvm_fatal("WRONG_TYPE", {"do_copy: rhs argument is not of type '",get_type_name(),"'"})
    first.copy(rhs_.first);
    second.copy(rhs_.second);
  endfunction

endclass


class uvm_built_in_pair #(type T1=int, T2=T1) extends uvm_object;

  typedef uvm_built_in_pair #(T1,T2) this_type;
  const static string type_name = "uvm_built_in_pair #(T1,T2)";
  T1 first;
  T2 second;

  `uvm_object_param_utils(this_type)
  
  function new (string name="");
    super.new(name);
  endfunction  
  
  virtual function string get_type_name ();
    return type_name;
  endfunction

  virtual function string convert2string;
    return $sformatf("built-in pair : %p, %p", first, second);
  endfunction

  virtual function bit do_compare(uvm_object rhs, uvm_comparer comparer);
    this_type rhs_;
    if(!$cast(rhs_,rhs)) begin
      `uvm_error("WRONG_TYPE", {"do_compare: rhs argument is not of type '",get_type_name(),"'"})
      return 0;
    end
    return first == rhs_.first && second == rhs_.second;
  endfunction

  function void do_copy (uvm_object rhs);
    this_type rhs_;
    if(!$cast(rhs_,rhs))
      `uvm_fatal("WRONG_TYPE", {"do_copy: rhs argument is not of type '",get_type_name(),"'"})
    first = rhs_.first;
    second = rhs_.second;
  endfunction
  
endclass


class uvm_built_in_comp #(type T=int);

  static function bit comp(T a, T b);
    return a == b;
  endfunction

endclass

class uvm_built_in_converter #(type T=int);
  static function string convert2string(input T t);
    return $sformatf("%p" , t );
  endfunction
endclass

class uvm_built_in_clone #(type T=int);

  static function T clone(input T from);
    return from;
  endfunction

endclass

class uvm_class_comp #(type T=int);

  static function bit comp(input T a, input T b);
    return a.compare(b);
  endfunction

endclass

class uvm_class_converter #(type T=int);

  static function string convert2string(input T t);
    return t.convert2string();
  endfunction

endclass

class uvm_class_clone #(type T=int);

  static function uvm_object clone(input T from);
    return from.clone();
  endfunction

endclass

class uvm_in_order_comparator #( type T = int , type comp_type = uvm_built_in_comp #( T ) , type convert = uvm_built_in_converter #( T ) , type pair_type = uvm_built_in_pair #( T ) ) extends uvm_component;

  typedef uvm_in_order_comparator #(T,comp_type,convert,pair_type) this_type;
  `uvm_component_param_utils(this_type)

  const static string type_name = "uvm_in_order_comparator #(T,comp_type,convert,pair_type)";

  uvm_analysis_export #(T) before_export;

  uvm_analysis_export #(T) after_export;

  uvm_analysis_port   #(pair_type) pair_ap;
  
  local uvm_tlm_analysis_fifo #(T) m_before_fifo;
  local uvm_tlm_analysis_fifo #(T) m_after_fifo;

  int m_matches, m_mismatches;

  function new(string name, uvm_component parent);

    super.new(name, parent);

    before_export = new("before_export", this);
    after_export  = new("after_export", this);
    pair_ap       = new("pair_ap", this);

    m_before_fifo = new("before", this);
    m_after_fifo  = new("after", this);
    m_matches = 0;
    m_mismatches = 0;

  endfunction
  
  virtual function string get_type_name();
    return type_name;
  endfunction

  virtual function void connect_phase(uvm_phase phase);
    before_export.connect(m_before_fifo.analysis_export);
    after_export.connect(m_after_fifo.analysis_export);
  endfunction

  virtual task run_phase(uvm_phase phase);
 
    pair_type pair;
    T b;
    T a;
  
    string s;
    super.run_phase(phase); 
    forever begin
      
      m_before_fifo.get(b);
      m_after_fifo.get(a);
      
      if(!comp_type::comp(b, a)) begin

        $sformat(s, "%s differs from %s", convert::convert2string(a), convert::convert2string(b));

        uvm_report_warning("Comparator Mismatch", s);

        m_mismatches++;

      end
      else begin
        s = convert::convert2string(b);
        uvm_report_info("Comparator Match", s);
        m_matches++;
      end

      
      pair = new("after/before");
      pair.first = a;
      pair.second = b;
      pair_ap.write(pair);
    end
  
  endtask

  virtual function void flush();
    m_matches = 0;
    m_mismatches = 0;
  endfunction
  
endclass

class uvm_in_order_built_in_comparator #(type T=int) extends uvm_in_order_comparator #(T);

  typedef uvm_in_order_built_in_comparator #(T) this_type;
  `uvm_component_param_utils(this_type)

  const static string type_name = "uvm_in_order_built_in_comparator #(T)";

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
  
  virtual function string get_type_name ();
    return type_name;
  endfunction

endclass

class uvm_in_order_class_comparator #( type T = int ) extends uvm_in_order_comparator #( T , uvm_class_comp #( T ) , uvm_class_converter #( T ) , uvm_class_pair #( T, T ) );

  typedef uvm_in_order_class_comparator #(T) this_type;
  `uvm_component_param_utils(this_type)

  const static string type_name = "uvm_in_order_class_comparator #(T)";

  function new( string name  , uvm_component parent);
    super.new( name, parent );
  endfunction
  
  virtual function string get_type_name ();
    return type_name;
  endfunction

endclass

class uvm_algorithmic_comparator #( type BEFORE=int, type AFTER=int, type TRANSFORMER=int) extends uvm_component;

  const static string type_name = "uvm_algorithmic_comparator #(BEFORE,AFTER,TRANSFORMER)";

  typedef uvm_algorithmic_comparator #( BEFORE , AFTER , TRANSFORMER ) this_type;
  
  `uvm_component_param_utils(this_type)

  uvm_analysis_imp #(BEFORE, this_type) before_export;

  uvm_analysis_export #(AFTER) after_export;

 
  local uvm_in_order_class_comparator #(AFTER) comp;
  local TRANSFORMER m_transformer;
     

 function new(string name, uvm_component parent=null, TRANSFORMER transformer=null);

    super.new( name , parent );
     
    m_transformer = transformer;
    comp = new("comp", this );
    
    before_export = new("before_analysis_export" , this );
    after_export = new("after_analysis_export" , this );
  endfunction

  virtual function string get_type_name();
    return type_name;
  endfunction

  virtual function void connect_phase(uvm_phase phase);
    after_export.connect( comp.after_export );
  endfunction

  function void write( input BEFORE b );
    comp.before_export.write( m_transformer.transform( b ) );
  endfunction
      
endclass

class uvm_random_stimulus #(type T=uvm_transaction) extends uvm_component;

  const static string type_name = "uvm_random_stimulus #(T)";

  typedef uvm_random_stimulus #(T) this_type;
  `uvm_component_param_utils(this_type)
                                                      
  uvm_blocking_put_port #(T) blocking_put_port;

  function new(string name, uvm_component parent);

    super.new(name, parent);

    blocking_put_port=new("blocking_put_port", this);
    
    uvm_report_info("uvm_stimulus", {"rand state is ", get_randstate()});

  endfunction

  local bit m_stop;

  virtual task generate_stimulus(T t=null, int max_count=0);

    T temp;
    
    if (t == null)
      t = new;
    
    for (int i=0; (max_count == 0 || i < max_count) && !m_stop; i++) begin

       if (! t.randomize() )
          uvm_report_warning ("RANDFL", "Randomization failed in generate_stimulus");
      
       $cast(temp, t.clone());
       uvm_report_info("stimulus generation", temp.convert2string()); 
       blocking_put_port.put(temp);
    end
  endtask
  
  virtual function void stop_stimulus_generation;
    m_stop = 1;
  endfunction
  

  virtual function string get_type_name();
    return type_name;
  endfunction

endclass : uvm_random_stimulus

virtual class uvm_subscriber #(type T=int) extends uvm_component;

  typedef uvm_subscriber #(T) this_type;
  uvm_analysis_imp #(T, this_type) analysis_export;

  function new (string name, uvm_component parent);
    super.new(name, parent);
    analysis_export = new("analysis_imp", this);
  endfunction

  pure virtual function void write(T t);
    
endclass

virtual class uvm_monitor extends uvm_component;
  function new (string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  const static string type_name = "uvm_monitor";

  virtual function string get_type_name ();
    return type_name;
  endfunction

endclass

typedef class uvm_sequence_item;

class uvm_driver #(type REQ=uvm_sequence_item, type RSP=REQ) extends uvm_component;

  uvm_seq_item_pull_port #(REQ, RSP) seq_item_port;
  uvm_seq_item_pull_port #(REQ, RSP) seq_item_prod_if; 
  uvm_analysis_port #(RSP) rsp_port;
  REQ req;
  RSP rsp;
  const static string type_name = "uvm_driver #(REQ,RSP)";

  function new (string name, uvm_component parent);
    super.new(name, parent);
    seq_item_port    = new("seq_item_port", this);
    rsp_port         = new("rsp_port", this);
    seq_item_prod_if = seq_item_port;
  endfunction 

  virtual function string get_type_name ();
    return type_name;
  endfunction

endclass

class uvm_push_driver #(type REQ=uvm_sequence_item, type RSP=REQ) extends uvm_component;

  uvm_blocking_put_imp #(REQ, uvm_push_driver #(REQ,RSP)) req_export;
  uvm_analysis_port #(RSP) rsp_port;
  const static string type_name = "uvm_push_driver #(REQ,RSP)";

  REQ req;
  RSP rsp;

  function new (string name, uvm_component parent);
    super.new(name, parent);
    req_export = new("req_export", this);
    rsp_port   = new("rsp_port", this);
  endfunction

  function void check_port_connections();
    if (req_export.size() != 1)
    uvm_report_fatal("Connection Error", $sformatf("Must connect to seq_item_port(%0d)", req_export.size()), UVM_NONE);
  endfunction
  
  virtual function void end_of_elaboration_phase(uvm_phase phase);
    super.end_of_elaboration_phase(phase);
    check_port_connections();
  endfunction
  
  virtual task put(REQ item);
    uvm_report_fatal("UVM_PUSH_DRIVER", "Put task for push driver is not implemented", UVM_NONE);
  endtask

  virtual function string get_type_name ();
    return type_name;
  endfunction

endclass

virtual class uvm_scoreboard extends uvm_component;

  function new (string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  const static string type_name = "uvm_scoreboard";

  virtual function string get_type_name ();
    return type_name;
  endfunction

endclass

virtual class uvm_agent extends uvm_component;
  uvm_active_passive_enum is_active = UVM_ACTIVE;

  function new (string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  virtual function void build_phase(uvm_phase phase);
     int active;
     uvm_resource_pool rp;
     uvm_resource_types::rsrc_q_t rq;
     
     super.build_phase(phase);
     rp = uvm_resource_pool::get();
     rq = rp.lookup_name(get_full_name(), "is_active", null, 0);
     uvm_resource_pool::sort_by_precedence(rq);
     for (int i = 0; i < rq.size(); i++) begin
        uvm_resource_base rsrc = rq.get(i);
        uvm_resource#(uvm_active_passive_enum) rap;

        if ($cast(rap, rsrc)) begin
           is_active = rap.read(this);
           break;
        end
        else begin
           uvm_resource#(uvm_integral_t) rit;
           if ($cast(rit, rsrc)) begin
              is_active = uvm_active_passive_enum'(rit.read(this));
              break;
           end
           else begin
              uvm_resource#(uvm_bitstream_t) rbs;
              if ($cast(rbs, rsrc)) begin
                 is_active = uvm_active_passive_enum'(rbs.read(this));
                 break;
              end
              else begin
                 uvm_resource#(int) ri;
                 if ($cast(ri, rsrc)) begin
                    is_active = uvm_active_passive_enum'(ri.read(this));
                    break;
                 end
                 else begin
                    uvm_resource#(int unsigned) riu;
                    if ($cast(riu, rsrc)) begin
                       is_active = uvm_active_passive_enum'(riu.read(this));
                       break;
                    end
                    else begin
                       uvm_resource#(string) rs;
                       if ($cast(rs, rsrc)) begin
                          void'(uvm_enum_wrapper#(uvm_active_passive_enum)::from_name(rs.read(this), is_active));
                          break;
                       end
                    end 
                 end 
              end 
           end 
        end 
     end 
     
  endfunction

  const static string type_name = "uvm_agent";

  virtual function string get_type_name ();
    return type_name;
  endfunction

  virtual function uvm_active_passive_enum get_is_active();
    return is_active;
  endfunction
endclass

virtual class uvm_env extends uvm_component;

  function new (string name="env", uvm_component parent=null);
    super.new(name,parent);
  endfunction

  const static string type_name = "uvm_env";

  virtual function string get_type_name ();
    return type_name;
  endfunction

endclass

virtual class uvm_test extends uvm_component;

  function new (string name, uvm_component parent);
    super.new(name,parent);
  endfunction

  const static string type_name = "uvm_test";

  virtual function string get_type_name ();
    return type_name;
  endfunction

endclass

typedef class uvm_sequence_base;
typedef class uvm_sequencer_base;

class uvm_sequence_item extends uvm_transaction;

  local      int                m_sequence_id = -1;
  protected  bit                m_use_sequence_info;
  protected  int                m_depth = -1;
  protected  uvm_sequencer_base m_sequencer;
  protected  uvm_sequence_base  m_parent_sequence;
  static     bit issued1,issued2;
  bit        print_sequence_info;

  function new (string name = "uvm_sequence_item");
    super.new(name);
  endfunction

  function string get_type_name();
    return "uvm_sequence_item";
  endfunction 

  `uvm_object_registry(uvm_sequence_item, "uvm_sequence_item")

  function void set_sequence_id(int id);
    m_sequence_id = id;
  endfunction

  function int get_sequence_id();
    return (m_sequence_id);
  endfunction

  function void set_item_context(uvm_sequence_base  parent_seq, uvm_sequencer_base sequencer = null);
     set_use_sequence_info(1);
     if (parent_seq != null) set_parent_sequence(parent_seq);
     if (sequencer == null && m_parent_sequence != null) sequencer = m_parent_sequence.get_sequencer();
     set_sequencer(sequencer); 
     if (m_parent_sequence != null) set_depth(m_parent_sequence.get_depth() + 1); 
     reseed();      
  endfunction

  function void set_use_sequence_info(bit value);
    m_use_sequence_info = value;
  endfunction

  function bit get_use_sequence_info();
    return (m_use_sequence_info);
  endfunction

  function void set_id_info(uvm_sequence_item item);
    if (item == null) begin
      uvm_report_fatal(get_full_name(), "set_id_info called with null parameter", UVM_NONE);
    end
    this.set_transaction_id(item.get_transaction_id());
    this.set_sequence_id(item.get_sequence_id());
  endfunction

  virtual function void set_sequencer(uvm_sequencer_base sequencer);
    m_sequencer = sequencer;
    m_set_p_sequencer();
  endfunction

  function uvm_sequencer_base get_sequencer();
    return m_sequencer;
  endfunction

  function void set_parent_sequence(uvm_sequence_base parent);
    m_parent_sequence = parent;
  endfunction

  function uvm_sequence_base get_parent_sequence();
    return (m_parent_sequence);
  endfunction 

  function void set_depth(int value);
    m_depth = value;
  endfunction

  function int get_depth();

    if (m_depth != -1) begin
      return (m_depth);
    end

    if (m_parent_sequence == null) begin
      m_depth = 1;
    end else begin
      m_depth = m_parent_sequence.get_depth() + 1;
    end

    return (m_depth);
  endfunction 

  virtual function bit is_item();
    return(1);
  endfunction

  virtual function string get_full_name();
    if(m_parent_sequence != null) 
      get_full_name = {m_parent_sequence.get_full_name(), "."};
    else if(m_sequencer!=null)
      get_full_name = {m_sequencer.get_full_name(), "."};
    if(get_name() != "") 
      get_full_name = {get_full_name, get_name()};
    else begin
      get_full_name = {get_full_name, "_item"};
    end
  endfunction

  function string get_root_sequence_name();
    uvm_sequence_base root_seq;
    root_seq = get_root_sequence();
    if (root_seq == null)
      return "";
    else
      return root_seq.get_name();
  endfunction

  virtual function void m_set_p_sequencer();
    return;
  endfunction  

  function uvm_sequence_base get_root_sequence();
    uvm_sequence_item root_seq_base;
    uvm_sequence_base root_seq;
    root_seq_base = this;
    while(1) begin
      if(root_seq_base.get_parent_sequence()!=null) begin
        root_seq_base = root_seq_base.get_parent_sequence();
        $cast(root_seq, root_seq_base);
      end
      else
        return root_seq;
    end
  endfunction

  function string get_sequence_path();
    uvm_sequence_item this_item;
    string seq_path;
    this_item = this;
    seq_path = this.get_name();
    while(1) begin
      if(this_item.get_parent_sequence()!=null) begin
        this_item = this_item.get_parent_sequence();
        seq_path = {this_item.get_name(), ".", seq_path};
      end
      else
        return seq_path;
    end
  endfunction

  virtual function uvm_report_object uvm_get_report_object();
    if(m_sequencer == null) begin
      uvm_coreservice_t cs = uvm_coreservice_t::get();
       return cs.get_root();
    end else 
      return m_sequencer;
  endfunction

  function int uvm_report_enabled(int verbosity, uvm_severity severity=UVM_INFO, string id="");
    uvm_report_object l_report_object = uvm_get_report_object();
    if (l_report_object.get_report_verbosity_level(severity, id) < verbosity)
      return 0;
    return 1;
  endfunction

  virtual function void uvm_report( uvm_severity severity, string id, string message, int verbosity = (severity == uvm_severity'(UVM_ERROR)) ? UVM_LOW : (severity == uvm_severity'(UVM_FATAL)) ? UVM_NONE : UVM_MEDIUM, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);
    uvm_report_message l_report_message;
    if (report_enabled_checked == 0) begin
      if (!uvm_report_enabled(verbosity, severity, id))
        return;
    end
    l_report_message = uvm_report_message::new_report_message();
    l_report_message.set_report_message(severity, id, message, verbosity, filename, line, context_name);
    uvm_process_report_message(l_report_message);

  endfunction

  virtual function void uvm_report_info( string id, string message, int verbosity = UVM_MEDIUM, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);

    this.uvm_report(UVM_INFO, id, message, verbosity, filename, line, context_name, report_enabled_checked);
  endfunction


  virtual function void uvm_report_warning( string id, string message, int verbosity = UVM_MEDIUM, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);

    this.uvm_report(UVM_WARNING, id, message, verbosity, filename, line, context_name, report_enabled_checked);
  endfunction


  virtual function void uvm_report_error( string id, string message, int verbosity = UVM_LOW, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);

    this.uvm_report(UVM_ERROR, id, message, verbosity, filename, line, context_name, report_enabled_checked);
  endfunction


  virtual function void uvm_report_fatal( string id, string message, int verbosity = UVM_NONE, string filename = "", int line = 0, string context_name = "", bit report_enabled_checked = 0);

    this.uvm_report(UVM_FATAL, id, message, verbosity, filename, line, context_name, report_enabled_checked);
  endfunction

  virtual function void uvm_process_report_message (uvm_report_message report_message);
    uvm_report_object l_report_object = uvm_get_report_object();
    report_message.set_report_object(l_report_object);
    if (report_message.get_context() == "")
      report_message.set_context(get_sequence_path());
    l_report_object.m_rh.process_report_message(report_message);
  endfunction

  function void do_print (uvm_printer printer);
    string temp_str0, temp_str1;
    int depth = get_depth();
    super.do_print(printer);
    if(print_sequence_info || m_use_sequence_info) begin
      printer.print_field_int("depth", depth, $bits(depth), UVM_DEC, ".", "int");
      if(m_parent_sequence != null) begin
        temp_str0 = m_parent_sequence.get_name();
        temp_str1 = m_parent_sequence.get_full_name();
      end
      printer.print_string("parent sequence (name)", temp_str0);
      printer.print_string("parent sequence (full name)", temp_str1);
      temp_str1 = "";
      if(m_sequencer != null) begin
        temp_str1 = m_sequencer.get_full_name();
      end
      printer.print_string("sequencer", temp_str1);
    end
  endfunction

endclass

typedef uvm_config_db#(uvm_sequence_base) uvm_config_seq;
typedef class uvm_sequence_request;
typedef enum {SEQ_TYPE_REQ, SEQ_TYPE_LOCK, SEQ_TYPE_GRAB} seq_req_t;

class uvm_sequence_process_wrapper;
    process pid;
    uvm_sequence_base seq;
endclass : uvm_sequence_process_wrapper

class uvm_sequencer_base extends uvm_component;

  protected uvm_sequence_request arb_sequence_q[$];
  protected bit                 arb_completed[int];
  protected uvm_sequence_base   lock_list[$];
  protected uvm_sequence_base   reg_sequences[int];
  protected int                 m_sequencer_id;
  protected int                 m_lock_arb_size;  
  protected int                 m_arb_size;       
  protected int                 m_wait_for_item_sequence_id, m_wait_for_item_transaction_id;
  protected int                 m_wait_relevant_count = 0 ;
  protected int                 m_max_zero_time_wait_relevant_count = 10;
  protected time                m_last_wait_relevant_time = 0 ;
  local uvm_sequencer_arb_mode  m_arbitration = UVM_SEQ_ARB_FIFO;
  local static int              g_request_id;
  local static int              g_sequence_id = 1;
  local static int              g_sequencer_id = 1;
  protected uvm_sequence_process_wrapper m_default_sequences[uvm_phase];
  int m_is_relevant_completed;

`ifdef UVM_DISABLE_AUTO_ITEM_RECORDING
  local bit m_auto_item_recording = 0;
`else
  local bit m_auto_item_recording = 1;
`endif

  virtual function void disable_auto_item_recording();
    m_auto_item_recording = 0;
  endfunction

  virtual function bit is_auto_item_recording_enabled();
    return m_auto_item_recording;
  endfunction

`ifndef UVM_NO_DEPRECATED

  int count = -1;
  int m_random_count;
  int m_exhaustive_count;
  int m_simple_count;
  int unsigned max_random_count = 10;
  int unsigned max_random_depth = 4;
  protected string default_sequence = "uvm_random_sequence";
  protected bit m_default_seq_set;
  string sequences[$];
  protected int sequence_ids[string];
  protected rand int seq_kind;

`endif

  function new (string name, uvm_component parent);
    super.new(name, parent);
    m_sequencer_id = g_sequencer_id++;
    m_lock_arb_size = -1;
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
  endfunction
  
  virtual function void build();
    int dummy;
    super.build();
    `ifndef UVM_NO_DEPRECATED
    if (uvm_config_string::get(this, "", "default_sequence", default_sequence)) begin
      `uvm_warning("UVM_DEPRECATED",{"default_sequence config parameter is deprecated and not ", "part of the UVM standard. See documentation for start_phase_sequence()."})
      this.m_default_seq_set = 1;
    end
    if (uvm_config_int::get(this, "", "count", count)) begin
      `uvm_warning("UVM_DEPRECATED",{"count config parameter is deprecated and not ", "part of the UVM standard"})
    end
    if (uvm_config_int::get(this, "", "max_random_count", max_random_count)) begin
      `uvm_warning("UVM_DEPRECATED",{"count config parameter is deprecated and not ", "part of the UVM standard"})
    end
    if (uvm_config_int::get(this, "", "max_random_depth", max_random_depth)) begin
      `uvm_warning("UVM_DEPRECATED",{"max_random_depth config parameter is deprecated and not ", "part of the UVM standard. Use 'uvm_sequence_library' class for ", "sequence library functionality"})
    end
    if (uvm_config_int::get(this, "", "pound_zero_count", dummy))
      `uvm_warning("UVM_DEPRECATED", {"pound_zero_count was set but ignored. ", "Sequencer/driver synchronization now uses 'uvm_wait_for_nba_region'"})
    `endif 
  endfunction
  
  virtual function void do_print (uvm_printer printer);
    super.do_print(printer);
    printer.print_array_header("arbitration_queue", arb_sequence_q.size());
    foreach (arb_sequence_q[i])
      printer.print_string($sformatf("[%0d]", i),
         $sformatf("%s@seqid%0d",arb_sequence_q[i].request.name(),arb_sequence_q[i].sequence_id), "[");
    printer.print_array_footer(arb_sequence_q.size());
  
    printer.print_array_header("lock_queue", lock_list.size());
    foreach(lock_list[i])
      printer.print_string($sformatf("[%0d]", i),
         $sformatf("%s@seqid%0d",lock_list[i].get_full_name(),lock_list[i].get_sequence_id()), "[");
    printer.print_array_footer(lock_list.size());
  endfunction
  
  virtual function void m_update_lists();
    m_lock_arb_size++;
  endfunction
  
  function string convert2string();
    string s;
    
    $sformat(s, "  -- arb i/id/type: ");
    foreach (arb_sequence_q[i]) begin
      $sformat(s, "%s %0d/%0d/%s ", s, i, arb_sequence_q[i].sequence_id, arb_sequence_q[i].request.name());
    end
    $sformat(s, "%s\n -- lock_list i/id: ", s);
    foreach (lock_list[i]) begin
      $sformat(s, "%s %0d/%0d",s, i, lock_list[i].get_sequence_id());
    end
    return(s);
  endfunction
  
  protected virtual function int  m_find_number_driver_connections();
    return 0;
  endfunction
  
  virtual function int m_register_sequence(uvm_sequence_base sequence_ptr);
  
    if (sequence_ptr.m_get_sqr_sequence_id(m_sequencer_id, 1) > 0)
      return sequence_ptr.get_sequence_id();
    
    sequence_ptr.m_set_sqr_sequence_id(m_sequencer_id, g_sequence_id++);
    reg_sequences[sequence_ptr.get_sequence_id()] = sequence_ptr;
    return sequence_ptr.get_sequence_id();
  endfunction
  
  protected function uvm_sequence_base m_find_sequence(int sequence_id);
    uvm_sequence_base seq_ptr;
    int           i;
    
    if (sequence_id == -1) begin
      if (reg_sequences.first(i)) begin
        return(reg_sequences[i]);
      end
      return(null);
    end
    
    if (!reg_sequences.exists(sequence_id))
      return null;
    return reg_sequences[sequence_id];
  endfunction  
  
  protected virtual function void m_unregister_sequence(int sequence_id);
    if (!reg_sequences.exists(sequence_id))
      return;
    reg_sequences.delete(sequence_id);
  endfunction  
  
  virtual function integer user_priority_arbitration(integer avail_sequences[$]);
    return avail_sequences[0];
  endfunction
  
  protected function void grant_queued_locks();
    begin
  	  uvm_sequence_request q[$];
  	  q = arb_sequence_q.find(item) with (item.request==SEQ_TYPE_LOCK && item.process_id.status inside {std::process::KILLED,std::process::FINISHED});
  	  foreach(q[idx]) begin
  		`uvm_error("SEQLCKZMB", $sformatf("The task responsible for requesting a lock on sequencer '%s' for sequence '%s' has been killed, to avoid a deadlock the sequence will be removed from the arbitration queues", this.get_full_name(), q[idx].sequence_ptr.get_full_name()))
  		
  		remove_sequence_from_queues(q[idx].sequence_ptr);
  	  end	
    end
    
    begin
  	uvm_sequence_request leading_lock_reqs[$],blocked_seqs[$],not_blocked_seqs[$];  
  	int q1[$];
  	int b=arb_sequence_q.size(); 
  	q1 = arb_sequence_q.find_first_index(item) with (item.request!=SEQ_TYPE_LOCK);
  	if(q1.size())
  		b=q1[0];  
  	if(b!=0) begin 
  		leading_lock_reqs = arb_sequence_q[0:b-1]; 	
  		foreach(leading_lock_reqs[i]) begin
  			uvm_sequence_request item = leading_lock_reqs[i];
  			if(is_blocked(item.sequence_ptr)!=0)
  				blocked_seqs.push_back(item);
  			else
  				not_blocked_seqs.push_back(item);
  		end
  		
  		if(b>arb_sequence_q.size()-1)
  			arb_sequence_q=blocked_seqs;
  		  else
  			arb_sequence_q={blocked_seqs,arb_sequence_q[b:arb_sequence_q.size()-1]};
  	  
  		foreach(not_blocked_seqs[idx]) begin
  			lock_list.push_back(not_blocked_seqs[idx].sequence_ptr);  
  			m_set_arbitration_completed(not_blocked_seqs[idx].request_id);
  		end
  	
  		if(not_blocked_seqs.size()) 	
  			m_update_lists();	
  	end	
    end
  endfunction
  
  protected task m_select_sequence();
     int selected_sequence;
  
      do begin
        wait_for_sequences();
        selected_sequence = m_choose_next_request();
        if (selected_sequence == -1) begin
          m_wait_for_available_sequence();
        end
      end while (selected_sequence == -1);
      if (selected_sequence >= 0) begin
        m_set_arbitration_completed(arb_sequence_q[selected_sequence].request_id);
        arb_sequence_q.delete(selected_sequence);
        m_update_lists();
      end
  endtask
  
  protected function int m_choose_next_request();
    int i, temp;
    int avail_sequence_count;
    int sum_priority_val;
    integer avail_sequences[$];
    integer highest_sequences[$];
    int highest_pri;
    string  s;
  
    avail_sequence_count = 0;
  
    grant_queued_locks();
  
    i = 0;
    while (i < arb_sequence_q.size()) begin
       if ((arb_sequence_q[i].process_id.status == std::process::KILLED) ||
           (arb_sequence_q[i].process_id.status == std::process::FINISHED)) begin
          `uvm_error("SEQREQZMB", $sformatf("The task responsible for requesting a wait_for_grant on sequencer '%s' for sequence '%s' has been killed, to avoid a deadlock the sequence will be removed from the arbitration queues", this.get_full_name(), arb_sequence_q[i].sequence_ptr.get_full_name()))
           remove_sequence_from_queues(arb_sequence_q[i].sequence_ptr);
           continue;
       end
  
      if (i < arb_sequence_q.size())
        if (arb_sequence_q[i].request == SEQ_TYPE_REQ)
          if (is_blocked(arb_sequence_q[i].sequence_ptr) == 0)
            if (arb_sequence_q[i].sequence_ptr.is_relevant() == 1) begin
              if (m_arbitration == UVM_SEQ_ARB_FIFO) begin
                return i;
              end
              else avail_sequences.push_back(i);
            end
  
      i++;
    end
  
    if (m_arbitration == UVM_SEQ_ARB_FIFO) begin
      return -1;
    end
    if (avail_sequences.size() < 1)  begin
      return -1;
    end
    
    if (avail_sequences.size() == 1) begin
      return avail_sequences[0];
    end
    
    if (lock_list.size() > 0) begin
      for (i = 0; i < avail_sequences.size(); i++) begin
        if (is_blocked(arb_sequence_q[avail_sequences[i]].sequence_ptr) != 0) begin
          avail_sequences.delete(i);
          i--;
        end
      end
      if (avail_sequences.size() < 1)
        return -1;
      if (avail_sequences.size() == 1)
        return avail_sequences[0];
    end
  
    if (m_arbitration == UVM_SEQ_ARB_WEIGHTED) begin
      sum_priority_val = 0;
      for (i = 0; i < avail_sequences.size(); i++) begin
        sum_priority_val += m_get_seq_item_priority(arb_sequence_q[avail_sequences[i]]);
      end
      
      temp = $urandom_range(sum_priority_val-1, 0);
  
      sum_priority_val = 0;
      for (i = 0; i < avail_sequences.size(); i++) begin
        if ((m_get_seq_item_priority(arb_sequence_q[avail_sequences[i]]) + 
             sum_priority_val) > temp) begin
          return avail_sequences[i];
        end
        sum_priority_val += m_get_seq_item_priority(arb_sequence_q[avail_sequences[i]]);
      end
      uvm_report_fatal("Sequencer", "UVM Internal error in weighted arbitration code", UVM_NONE);
    end
    
    if (m_arbitration == UVM_SEQ_ARB_RANDOM) begin
      i = $urandom_range(avail_sequences.size()-1, 0);
      return avail_sequences[i];
    end
  
    if ((m_arbitration == UVM_SEQ_ARB_STRICT_FIFO) || m_arbitration == UVM_SEQ_ARB_STRICT_RANDOM) begin
      highest_pri = 0;
      for (i = 0; i < avail_sequences.size(); i++) begin
        if (m_get_seq_item_priority(arb_sequence_q[avail_sequences[i]]) > highest_pri) begin
          highest_sequences.delete();
          highest_sequences.push_back(avail_sequences[i]);
          highest_pri = m_get_seq_item_priority(arb_sequence_q[avail_sequences[i]]);
        end
        else if (m_get_seq_item_priority(arb_sequence_q[avail_sequences[i]]) == highest_pri) begin
          highest_sequences.push_back(avail_sequences[i]);
        end
      end
  
      if (m_arbitration == UVM_SEQ_ARB_STRICT_FIFO) begin
        return(highest_sequences[0]);
      end
      
      i = $urandom_range(highest_sequences.size()-1, 0);
      return highest_sequences[i];
    end
  
    if (m_arbitration == UVM_SEQ_ARB_USER) begin
      i = user_priority_arbitration( avail_sequences);
  
      highest_sequences = avail_sequences.find with (item == i);
      if (highest_sequences.size() == 0) begin
        uvm_report_fatal("Sequencer", $sformatf("Error in User arbitration, sequence %0d not available\n%s", i, convert2string()), UVM_NONE);
      end
      return(i);
    end
      
    uvm_report_fatal("Sequencer", "Internal error: Failed to choose sequence", UVM_NONE);
  
  endfunction
  
  protected task m_wait_arb_not_equal();
    wait (m_arb_size != m_lock_arb_size);
  endtask
  
  protected task m_wait_for_available_sequence();
    int i;
    int is_relevant_entries[$];
  
    m_arb_size = m_lock_arb_size;
  
    for (i = 0; i < arb_sequence_q.size(); i++) begin
      if (arb_sequence_q[i].request == SEQ_TYPE_REQ) begin
        if (is_blocked(arb_sequence_q[i].sequence_ptr) == 0) begin
          if (arb_sequence_q[i].sequence_ptr.is_relevant() == 0) begin
            is_relevant_entries.push_back(i);
          end
        end
      end
    end
  
    if (is_relevant_entries.size() == 0) begin
      m_wait_arb_not_equal();
      return;
    end
  
    fork  
      begin
        fork
          begin
            fork
                begin
                  m_is_relevant_completed = 0;
                  
                  for(i = 0; i < is_relevant_entries.size(); i++) begin
                  fork
                      automatic int k = i;
                      
                    begin
                      arb_sequence_q[is_relevant_entries[k]].sequence_ptr.wait_for_relevant();
                      if ($realtime != m_last_wait_relevant_time) begin
                         m_last_wait_relevant_time = $realtime ;
                         m_wait_relevant_count = 0 ;
                      end
                      else begin
                         m_wait_relevant_count++ ;
                         if (m_wait_relevant_count > m_max_zero_time_wait_relevant_count) begin
                            `uvm_fatal("SEQRELEVANTLOOP",$sformatf("Zero time loop detected, passed wait_for_relevant %0d times without time advancing",m_wait_relevant_count))
                         end
                      end
                      m_is_relevant_completed = 1;
                    end
                  join_none
                    
                  end
                  wait (m_is_relevant_completed > 0);
                end
                
              begin
                m_wait_arb_not_equal();
              end
            join_any
          end
        join_any
        disable fork;
      end
    join
  endtask
  
  protected function int m_get_seq_item_priority(uvm_sequence_request seq_q_entry);
    if (seq_q_entry.item_priority != -1) begin
      if (seq_q_entry.item_priority <= 0) begin
        uvm_report_fatal("SEQITEMPRI", $sformatf("Sequence item from %s has illegal priority: %0d", seq_q_entry.sequence_ptr.get_full_name(), seq_q_entry.item_priority), UVM_NONE);
      end
      return seq_q_entry.item_priority;
    end
    if (seq_q_entry.sequence_ptr.get_priority() < 0) begin
      uvm_report_fatal("SEQDEFPRI", $sformatf("Sequence %s has illegal priority: %0d", seq_q_entry.sequence_ptr.get_full_name(), seq_q_entry.sequence_ptr.get_priority()), UVM_NONE);
    end
    return seq_q_entry.sequence_ptr.get_priority();
  endfunction
  
  task m_wait_for_arbitration_completed(int request_id);
    int lock_arb_size;
    
    forever 
      begin
        lock_arb_size  = m_lock_arb_size;
        
        if (arb_completed.exists(request_id)) begin
          arb_completed.delete(request_id);
          return;
        end
        wait (lock_arb_size != m_lock_arb_size);
      end
  endtask
  
  function void m_set_arbitration_completed(int request_id);
    arb_completed[request_id] = 1;
  endfunction
  
  function bit is_child (uvm_sequence_base parent,
                                             uvm_sequence_base child);
    uvm_sequence_base child_parent;
  
    if (child == null) begin
      uvm_report_fatal("uvm_sequencer", "is_child passed null child", UVM_NONE);
    end
  
    if (parent == null) begin
      uvm_report_fatal("uvm_sequencer", "is_child passed null parent", UVM_NONE);
    end
  
    child_parent = child.get_parent_sequence();
    while (child_parent != null) begin
      if (child_parent.get_inst_id() == parent.get_inst_id()) begin
        return 1;
      end
      child_parent = child_parent.get_parent_sequence();
    end
    return 0;
  endfunction
  
  virtual task execute_item(uvm_sequence_item item);
    uvm_sequence_base seq;
    
    seq = new();
    item.set_sequencer(this);
    item.set_parent_sequence(seq);
    seq.set_sequencer(this);
    seq.start_item(item);
    seq.finish_item(item);
  endtask
  
  virtual task wait_for_grant(uvm_sequence_base sequence_ptr, int item_priority = -1, bit lock_request = 0);
    uvm_sequence_request req_s;
    int my_seq_id;
  
    if (sequence_ptr == null)
      uvm_report_fatal("uvm_sequencer", "wait_for_grant passed null sequence_ptr", UVM_NONE);
  
    my_seq_id = m_register_sequence(sequence_ptr);
    
    if (lock_request == 1) begin
      req_s = new();
      req_s.grant = 0;
      req_s.sequence_id = my_seq_id;
      req_s.request = SEQ_TYPE_LOCK;
      req_s.sequence_ptr = sequence_ptr;
      req_s.request_id = g_request_id++;
      req_s.process_id = std::process::self();
      arb_sequence_q.push_back(req_s);
    end
        
    req_s = new();
    req_s.grant = 0;
    req_s.request = SEQ_TYPE_REQ;
    req_s.sequence_id = my_seq_id;
    req_s.item_priority = item_priority;
    req_s.sequence_ptr = sequence_ptr;
    req_s.request_id = g_request_id++;
    req_s.process_id = std::process::self();
    arb_sequence_q.push_back(req_s);
    m_update_lists();
  
    m_wait_for_arbitration_completed(req_s.request_id);
  
    req_s.sequence_ptr.m_wait_for_grant_semaphore++;
  
  endtask
  
  virtual task wait_for_item_done(uvm_sequence_base sequence_ptr, int transaction_id);
    int sequence_id;
  
    sequence_id = sequence_ptr.m_get_sqr_sequence_id(m_sequencer_id, 1);
    m_wait_for_item_sequence_id = -1;
    m_wait_for_item_transaction_id = -1;
  
    if (transaction_id == -1)
      wait (m_wait_for_item_sequence_id == sequence_id);
    else
      wait ((m_wait_for_item_sequence_id == sequence_id &&
             m_wait_for_item_transaction_id == transaction_id));
  endtask
  
  virtual function bit is_blocked(uvm_sequence_base sequence_ptr);
  
    if (sequence_ptr == null)
      uvm_report_fatal("uvm_sequence_controller", "is_blocked passed null sequence_ptr", UVM_NONE);
  
      foreach (lock_list[i]) begin
        if ((lock_list[i].get_inst_id() != 
             sequence_ptr.get_inst_id()) &&
            (is_child(lock_list[i], sequence_ptr) == 0)) begin
          return 1;
        end
      end 
      return 0;
  endfunction
  
  function bit has_lock(uvm_sequence_base sequence_ptr);
    int my_seq_id;
    
    if (sequence_ptr == null)
      uvm_report_fatal("uvm_sequence_controller", "has_lock passed null sequence_ptr", UVM_NONE);
    my_seq_id = m_register_sequence(sequence_ptr);
      foreach (lock_list[i]) begin
        if (lock_list[i].get_inst_id() == sequence_ptr.get_inst_id()) begin
          return 1;
        end
      end 
    return 0;
  endfunction
  
  local task m_lock_req(uvm_sequence_base sequence_ptr, bit lock);
    int my_seq_id;
    uvm_sequence_request new_req;
    
    if (sequence_ptr == null)
      uvm_report_fatal("uvm_sequence_controller", "lock_req passed null sequence_ptr", UVM_NONE);
  
    my_seq_id = m_register_sequence(sequence_ptr);
    new_req = new();
    new_req.grant = 0;
    new_req.sequence_id = sequence_ptr.get_sequence_id();
    new_req.request = SEQ_TYPE_LOCK;
    new_req.sequence_ptr = sequence_ptr;
    new_req.request_id = g_request_id++;
    new_req.process_id = std::process::self();
    
    if (lock == 1) begin
      arb_sequence_q.push_back(new_req);
    end else begin
      arb_sequence_q.push_front(new_req);
      m_update_lists();
    end
  
    grant_queued_locks();
    
    m_wait_for_arbitration_completed(new_req.request_id);
  endtask
    
  function void m_unlock_req(uvm_sequence_base sequence_ptr);
    if (sequence_ptr == null) begin
      uvm_report_fatal("uvm_sequencer", "m_unlock_req passed null sequence_ptr", UVM_NONE);
    end
   
    begin
  	  int q[$];
  	  int seqid=sequence_ptr.get_inst_id();
  	  q=lock_list.find_first_index(item) with (item.get_inst_id() == seqid);
  	  if(q.size()==1) begin
  	      lock_list.delete(q[0]);
  		  grant_queued_locks();  
  		  m_update_lists();	 
  	  end
  	  else
  		  uvm_report_warning("SQRUNL", {"Sequence '", sequence_ptr.get_full_name(), "' called ungrab / unlock, but didn't have lock"}, UVM_NONE);  
  
    end
  endfunction
  
  task lock(uvm_sequence_base sequence_ptr);
    m_lock_req(sequence_ptr, 1);
  endtask
  
  virtual task grab(uvm_sequence_base sequence_ptr);
    m_lock_req(sequence_ptr, 0);
  endtask
  
  virtual function void unlock(uvm_sequence_base sequence_ptr);
    m_unlock_req(sequence_ptr);
  endfunction
  
  virtual function void  ungrab(uvm_sequence_base sequence_ptr);
    m_unlock_req(sequence_ptr);
  endfunction
  
  local function void remove_sequence_from_queues( uvm_sequence_base sequence_ptr);
    int i;
    int seq_id;
    
    seq_id = sequence_ptr.m_get_sqr_sequence_id(m_sequencer_id, 0);
    
    i = 0;
    do 
      begin
        if (arb_sequence_q.size() > i) begin
          if ((arb_sequence_q[i].sequence_id == seq_id) ||
              (is_child(sequence_ptr, arb_sequence_q[i].sequence_ptr))) begin
            if (sequence_ptr.get_sequence_state() == UVM_FINISHED)
              `uvm_error("SEQFINERR", $sformatf("Parent sequence '%s' should not finish before all items from itself and items from descendent sequences are processed.  The item request from the sequence '%s' is being removed.", sequence_ptr.get_full_name(), arb_sequence_q[i].sequence_ptr.get_full_name()))
            arb_sequence_q.delete(i);
            m_update_lists();
          end
          else begin
            i++;
          end
        end
      end
    while (i < arb_sequence_q.size());
    
    i = 0;
    do
      begin
        if (lock_list.size() > i) begin
          if ((lock_list[i].get_inst_id() == sequence_ptr.get_inst_id()) ||
              (is_child(sequence_ptr, lock_list[i]))) begin
            if (sequence_ptr.get_sequence_state() == UVM_FINISHED)
              `uvm_error("SEQFINERR", $sformatf("Parent sequence '%s' should not finish before locks from itself and descedent sequences are removed.  The lock held by the child sequence '%s' is being removed.",sequence_ptr.get_full_name(), lock_list[i].get_full_name()))
            lock_list.delete(i);
            m_update_lists();
          end
          else begin
            i++;
          end
        end
      end
    while (i < lock_list.size());
    
    m_unregister_sequence(sequence_ptr.m_get_sqr_sequence_id(m_sequencer_id, 1));
  endfunction
  
  virtual function void stop_sequences();
    uvm_sequence_base seq_ptr;
    
    seq_ptr = m_find_sequence(-1);
    while (seq_ptr != null)
      begin
        kill_sequence(seq_ptr);
        seq_ptr = m_find_sequence(-1);
      end
  endfunction
  
  function void m_sequence_exiting(uvm_sequence_base sequence_ptr);
    remove_sequence_from_queues(sequence_ptr);
  endfunction
  
  function void kill_sequence(uvm_sequence_base sequence_ptr);
    remove_sequence_from_queues(sequence_ptr);
    sequence_ptr.m_kill();
  endfunction
  
  virtual function bit is_grabbed();
    return (lock_list.size() != 0);
  endfunction
  
  virtual function uvm_sequence_base current_grabber();
    if (lock_list.size() == 0) begin
      return null;
    end
    return lock_list[lock_list.size()-1];
  endfunction
  
  virtual function bit has_do_available();
    
    foreach (arb_sequence_q[i]) begin
      if ((arb_sequence_q[i].sequence_ptr.is_relevant() == 1) &&
          (is_blocked(arb_sequence_q[i].sequence_ptr) == 0)) begin
        return 1;
      end
    end
    return 0;
  endfunction
  
  function void set_arbitration(UVM_SEQ_ARB_TYPE val);
    m_arbitration = val;
  endfunction
  
  function UVM_SEQ_ARB_TYPE get_arbitration();
    return m_arbitration;
  endfunction
  
  virtual function void analysis_write(uvm_sequence_item t);
    return;
  endfunction
  
  virtual task wait_for_sequences();
    uvm_wait_for_nba_region();
  endtask
  
  virtual function void send_request(uvm_sequence_base sequence_ptr, uvm_sequence_item t, bit rerandomize = 0);
    return;
  endfunction
  
  virtual function void set_max_zero_time_wait_relevant_count(int new_val) ;
     m_max_zero_time_wait_relevant_count = new_val ;
  endfunction
  
  virtual function void start_phase_sequence(uvm_phase phase);
    uvm_resource_pool            rp = uvm_resource_pool::get();
    uvm_resource_types::rsrc_q_t rq;
    uvm_sequence_base            seq;
    uvm_coreservice_t cs = uvm_coreservice_t::get();
    uvm_factory                  f = cs.get_factory();
    
    rq = rp.lookup_name({get_full_name(), ".", phase.get_name(), "_phase"}, "default_sequence", null, 0);
    uvm_resource_pool::sort_by_precedence(rq);
    
    for (int i = 0; seq == null && i < rq.size(); i++) begin
      uvm_resource_base rsrc = rq.get(i);
      
      uvm_resource#(uvm_sequence_base)  sbr;
      uvm_resource#(uvm_object_wrapper) owr;
  
      if ($cast(sbr, rsrc) && sbr != null) begin
        seq = sbr.read(this);
        if (seq == null) begin
          `uvm_info("UVM/SQR/PH/DEF/SB/NULL", {"Default phase sequence for phase '", phase.get_name(),"' explicitly disabled"}, UVM_FULL)
          return;
        end
      end
      
      else if ($cast(owr, rsrc) && owr != null) begin
        uvm_object_wrapper wrapper;
  
        wrapper = owr.read(this);
        if (wrapper == null) begin
          `uvm_info("UVM/SQR/PH/DEF/OW/NULL", {"Default phase sequence for phase '", phase.get_name(),"' explicitly disabled"}, UVM_FULL)
          return;
        end
  
        if (!$cast(seq, f.create_object_by_type(wrapper, get_full_name(), wrapper.get_type_name()))
            || seq == null) begin
          `uvm_warning("PHASESEQ", {"Default sequence for phase '", phase.get_name(),"' %s is not a sequence type"})
          return;
        end
      end
    end
    
    if (seq == null) begin
      `uvm_info("PHASESEQ", {"No default phase sequence for phase '", phase.get_name(),"'"}, UVM_FULL)
      return;
    end
    
    `uvm_info("PHASESEQ", {"Starting default sequence '", seq.get_type_name(),"' for phase '", phase.get_name(),"'"}, UVM_FULL)
    
    seq.print_sequence_info = 1;
    seq.set_sequencer(this);
    seq.reseed();
    seq.set_starting_phase(phase);
    
    if (!seq.do_not_randomize && !seq.randomize()) begin
      `uvm_warning("STRDEFSEQ", {"Randomization failed for default sequence '", seq.get_type_name(),"' for phase '", phase.get_name(),"'"})
      return;
    end
    
    fork begin
      uvm_sequence_process_wrapper w = new();
      w.pid = std::process::self();
      w.seq = seq;
      w.pid.srandom(uvm_create_random_seed(seq.get_type_name(), this.get_full_name()));
      m_default_sequences[phase] = w;
      seq.start(this);
      m_default_sequences.delete(phase);
    end
    join_none
    
  endfunction
  
  virtual function void stop_phase_sequence(uvm_phase phase);
      if (m_default_sequences.exists(phase)) begin
          `uvm_info("PHASESEQ", {"Killing default sequence '", m_default_sequences[phase].seq.get_type_name(), "' for phase '", phase.get_name(), "'"}, UVM_FULL)
          m_default_sequences[phase].seq.kill();
      end
      else begin
          `uvm_info("PHASESEQ", {"No default sequence to kill for phase '", phase.get_name(), "'"}, UVM_FULL)
      end
  endfunction : stop_phase_sequence
  
  `ifndef UVM_NO_DEPRECATED
  
  function void add_sequence(string type_name);
  
    `uvm_warning("UVM_DEPRECATED",{"Registering sequence '",type_name, "' with sequencer '",get_full_name(),"' is deprecated. "})
  
    if (!sequence_ids.exists(type_name)) begin
      sequence_ids[type_name] = sequences.size();
      sequences.push_back(type_name);
    end
  endfunction
  
  function void remove_sequence(string type_name);
    sequence_ids.delete(type_name);
    for (int i = 0; i < this.sequences.size(); i++) begin
      if (this.sequences[i] == type_name)
        this.sequences.delete(i);
    end
  endfunction
  
  function void set_sequences_queue( ref string sequencer_sequence_lib[$]);
    
    for(int j=0; j < sequencer_sequence_lib.size(); j++) begin
      sequence_ids[sequencer_sequence_lib[j]] = sequences.size();
      this.sequences.push_back(sequencer_sequence_lib[j]);
    end
  endfunction
  
  virtual task start_default_sequence();
    uvm_sequence_base m_seq ;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
  
    if (default_sequence == "" || count == 0 ||
          (sequences.size() == 0 && default_sequence == "uvm_random_sequence"))
      return;
  
    if(this.m_default_seq_set == 0 && m_domain != null) begin
      default_sequence = "";
      `uvm_info("NODEFSEQ", {"The \"default_sequence\" has not been set. ", "Since this sequencer has a runtime phase schedule, the ", "uvm_random_sequence is not being started for the run phase."}, UVM_HIGH)
      return;
    end
  
    if (this.m_default_seq_set == 1 && (uvm_config_db #(uvm_sequence_base)::exists(this, "run_phase", "default_sequence", 0) || uvm_config_db #(uvm_object_wrapper)::exists(this, "run_phase", "default_sequence", 0)))
    begin
      `uvm_warning("MULDEFSEQ", {"A default phase sequence has been set via the ", "\"<phase_name>.default_sequence\" configuration option.", "The deprecated \"default_sequence\" configuration option is ignored."})
      return;
    end
  
    if(sequences.size() == 2 && sequences[0] == "uvm_random_sequence" && sequences[1] == "uvm_exhaustive_sequence") begin
      uvm_report_warning("NOUSERSEQ", {"No user sequence available. ", "Not starting the (deprecated) default sequence."}, UVM_HIGH);
      return;
    end
    
  	`uvm_warning("UVM_DEPRECATED",{"Starting (deprecated) default sequence '",default_sequence, "' on sequencer '",get_full_name(), "'. See documentation for start_phase_sequence() for information on ", "starting default sequences in UVM."})
  
      if (!$cast(m_seq, factory.create_object_by_name(default_sequence, 
                                              get_full_name(), default_sequence))) 
        begin
          uvm_report_fatal("FCTSEQ",{"Default sequence set to invalid value : ", default_sequence}, UVM_NONE);
        end
  
      if (m_seq == null) begin
        uvm_report_fatal("STRDEFSEQ", "Null m_sequencer reference", UVM_NONE);
      end
      m_seq.set_starting_phase(run_ph);
      m_seq.print_sequence_info = 1;
      m_seq.set_parent_sequence(null);
      m_seq.set_sequencer(this);
      m_seq.reseed();
      if (!m_seq.randomize()) begin
        uvm_report_warning("STRDEFSEQ", "Failed to randomize sequence");
      end
      m_seq.start(this);
  endtask
  
  function int get_seq_kind(string type_name);
  
    `uvm_warning("UVM_DEPRECATED", $sformatf("%m is deprecated"))
  
    if (sequence_ids.exists(type_name))
      return sequence_ids[type_name];
  
    `uvm_warning("SEQNF", {"Sequence type_name '",type_name,"' not registered with this sequencer."})
      
    return -1;
  endfunction
  
  function uvm_sequence_base get_sequence(int req_kind);
    uvm_coreservice_t cs = uvm_coreservice_t::get();                         
    uvm_factory factory = cs.get_factory();
    uvm_sequence_base m_seq ;
    string m_seq_type;
  
    `uvm_warning("UVM_DEPRECATED", $sformatf("%m is deprecated"))
  
    if (req_kind < 0 || req_kind >= sequences.size()) begin
      uvm_report_error("SEQRNG", $sformatf("Kind arg '%0d' out of range. Need 0-%0d", req_kind, sequences.size()-1));
    end
  
    m_seq_type = sequences[req_kind];
    if (!$cast(m_seq, factory.create_object_by_name(m_seq_type, get_full_name(), m_seq_type))) 
    begin
        uvm_report_fatal("FCTSEQ", $sformatf("Factory cannot produce a sequence of type %0s.", m_seq_type), UVM_NONE);
    end
  
    m_seq.print_sequence_info = 1;
    m_seq.set_sequencer (this);
    return m_seq;
  
  endfunction
  
  function int num_sequences();
    return sequences.size();
  endfunction
  
  virtual function void m_add_builtin_seqs(bit add_simple=1);
    if(!sequence_ids.exists("uvm_random_sequence"))
      add_sequence("uvm_random_sequence");
    if(!sequence_ids.exists("uvm_exhaustive_sequence"))
      add_sequence("uvm_exhaustive_sequence");
    if(add_simple == 1) begin
      if(!sequence_ids.exists("uvm_simple_sequence"))
        add_sequence("uvm_simple_sequence");
    end
  endfunction
  
  virtual task run_phase(uvm_phase phase);
    super.run_phase(phase);
    start_default_sequence();
  endtask

endclass

`endif 

class uvm_sequence_request;
  bit        grant;
  int        sequence_id;
  int        request_id;
  int        item_priority;
  process    process_id;
  seq_req_t  request;
  uvm_sequence_base sequence_ptr;
endclass


class uvm_sequencer_analysis_fifo #(type RSP = uvm_sequence_item) extends uvm_tlm_fifo #(RSP);

  uvm_analysis_imp #(RSP, uvm_sequencer_analysis_fifo #(RSP)) analysis_export;
  uvm_sequencer_base sequencer_ptr;

  function new (string name, uvm_component parent = null);
    super.new(name, parent, 0);
    analysis_export = new ("analysis_export", this);
  endfunction

  function void write(input RSP t);
    if (sequencer_ptr == null)
      uvm_report_fatal ("SEQRNULL", "The sequencer pointer is null when attempting a write", UVM_NONE);
    sequencer_ptr.analysis_write(t);
  endfunction 
endclass

class uvm_sequencer_param_base #(type REQ = uvm_sequence_item, type RSP = REQ) extends uvm_sequencer_base;

  typedef uvm_sequencer_param_base #( REQ , RSP) this_type;
  typedef REQ req_type;
  typedef RSP rsp_type;

  REQ m_last_req_buffer[$];
  RSP m_last_rsp_buffer[$];

  protected int m_num_last_reqs = 1;
  protected int num_last_items = m_num_last_reqs;
  protected int m_num_last_rsps = 1;
  protected int m_num_reqs_sent;
  protected int m_num_rsps_received;
  uvm_sequencer_analysis_fifo #(RSP) sqr_rsp_analysis_fifo;

  function REQ get_current_item();
    REQ t;
    if (m_req_fifo.try_peek(t) == 0)
      return null;
    return t;
  endfunction

  function REQ last_req(int unsigned n = 0);
    if(n > m_num_last_reqs) begin
      uvm_report_warning("HSTOB",
        $sformatf("Invalid last access (%0d), the max history is %0d", n,
        m_num_last_reqs));
      return null;
    end
    if(n == m_last_req_buffer.size())
      return null;
  
    return m_last_req_buffer[n];
  endfunction

  uvm_analysis_export #(RSP) rsp_export;

  function RSP last_rsp(int unsigned n = 0);
    if(n > m_num_last_rsps) begin
      uvm_report_warning("HSTOB",
        $sformatf("Invalid last access (%0d), the max history is %0d", n,
        m_num_last_rsps));
      return null;
    end
    if(n == m_last_rsp_buffer.size())
      return null;
  
    return m_last_rsp_buffer[n];
  endfunction

  uvm_tlm_fifo #(REQ) m_req_fifo;

  function new (string name, uvm_component parent);
    super.new(name, parent);
  
    rsp_export              = new("rsp_export", this);
    sqr_rsp_analysis_fifo   = new("sqr_rsp_analysis_fifo", this);
    sqr_rsp_analysis_fifo.print_enabled = 0;
    m_req_fifo              = new("req_fifo", this);
    m_req_fifo.print_enabled = 0;
  endfunction
  
  virtual function void do_print (uvm_printer printer);
    super.do_print(printer);
    printer.print_field_int("num_last_reqs", m_num_last_reqs, $bits(m_num_last_reqs), UVM_DEC);
    printer.print_field_int("num_last_rsps", m_num_last_rsps, $bits(m_num_last_rsps), UVM_DEC);
  endfunction
  
  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    rsp_export.connect(sqr_rsp_analysis_fifo.analysis_export);
  endfunction
  
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    sqr_rsp_analysis_fifo.sequencer_ptr = this;
  endfunction
  
  virtual function void send_request(uvm_sequence_base sequence_ptr, uvm_sequence_item t, bit rerandomize = 0);
    REQ param_t;
  
    if (sequence_ptr == null) begin
      uvm_report_fatal("SNDREQ", "Send request sequence_ptr is null", UVM_NONE);
    end
  
    if (sequence_ptr.m_wait_for_grant_semaphore < 1) begin
      uvm_report_fatal("SNDREQ", "Send request called without wait_for_grant", UVM_NONE);
    end
    sequence_ptr.m_wait_for_grant_semaphore--;
    
    if ($cast(param_t, t)) begin
      if (rerandomize == 1) begin
        if (!param_t.randomize()) begin
          uvm_report_warning("SQRSNDREQ", "Failed to rerandomize sequence item in send_request");
        end
      end
      if (param_t.get_transaction_id() == -1) begin
        param_t.set_transaction_id(sequence_ptr.m_next_transaction_id++);
      end
      m_last_req_push_front(param_t);
    end else begin
      uvm_report_fatal(get_name(),$sformatf("send_request failed to cast sequence item"), UVM_NONE);
    end
  
    param_t.set_sequence_id(sequence_ptr.m_get_sqr_sequence_id(m_sequencer_id, 1));
    t.set_sequencer(this);
    if (m_req_fifo.try_put(param_t) != 1) begin
      uvm_report_fatal(get_full_name(), "Concurrent calls to get_next_item() not supported. Consider using a semaphore to ensure that concurrent processes take turns in the driver", UVM_NONE);
    end
  
    m_num_reqs_sent++;
    grant_queued_locks();
  endfunction
  
  function void put_response (RSP t);
    uvm_sequence_base sequence_ptr;
    
    if (t == null) begin
      uvm_report_fatal("SQRPUT", "Driver put a null response", UVM_NONE);
    end
  
    m_last_rsp_push_front(t);
    m_num_rsps_received++;
  
    if (t.get_sequence_id() == -1) begin
  `ifndef CDNS_NO_SQR_CHK_SEQ_ID
      uvm_report_fatal("SQRPUT", "Driver put a response with null sequence_id", UVM_NONE);
  `endif
      return;
    end
      
    sequence_ptr = m_find_sequence(t.get_sequence_id());
  
    if (sequence_ptr != null) begin
      if (sequence_ptr.get_use_response_handler() == 1) begin
        sequence_ptr.response_handler(t);
        return;
      end
      
      sequence_ptr.put_response(t);
    end
    else begin
      uvm_report_info("Sequencer", 
                      $sformatf("Dropping response for sequence %0d, sequence not found.  Probable cause: sequence exited or has been killed", 
                                t.get_sequence_id()));
    end
  endfunction
  
  virtual function void analysis_write(uvm_sequence_item t);
    RSP response;
  
    if (!$cast(response, t)) begin
      uvm_report_fatal("ANALWRT", "Failure to cast analysis port write item", UVM_NONE);
    end
    put_response(response);
  endfunction
  
  function int get_num_reqs_sent();
    return m_num_reqs_sent;
  endfunction
  
  function int get_num_rsps_received();
    return m_num_rsps_received;
  endfunction
  
  function void set_num_last_reqs(int unsigned max);
    if(max > 1024) begin
      uvm_report_warning("HSTOB", 
        $sformatf("Invalid last size; 1024 is the maximum and will be used"));
      max = 1024;
    end
  
    while((m_last_req_buffer.size() != 0) && (m_last_req_buffer.size() > max))
      void'(m_last_req_buffer.pop_back());
  
    m_num_last_reqs = max;
    num_last_items = max;
  
  endfunction
  
  function int unsigned get_num_last_reqs();
    return m_num_last_reqs;
  endfunction
  
  function void m_last_req_push_front(REQ item);
    if(!m_num_last_reqs)
      return;
   
    if(m_last_req_buffer.size() == m_num_last_reqs)
      void'(m_last_req_buffer.pop_back());
  
    this.m_last_req_buffer.push_front(item);
  endfunction
  
  function void set_num_last_rsps(int unsigned max);
    if(max > 1024) begin
      uvm_report_warning("HSTOB", 
        $sformatf("Invalid last size; 1024 is the maximum and will be used"));
      max = 1024;
    end
  
    while((m_last_rsp_buffer.size() != 0) && (m_last_rsp_buffer.size() > max)) begin
      void'(m_last_rsp_buffer.pop_back());
    end
  
    m_num_last_rsps = max;
  
  endfunction
  
  function int unsigned get_num_last_rsps();
    return m_num_last_rsps;
  endfunction
  
  function void m_last_rsp_push_front(RSP item);
    if(!m_num_last_rsps)
      return;
   
    if(m_last_rsp_buffer.size() == m_num_last_rsps)
      void'(m_last_rsp_buffer.pop_back());
  
    this.m_last_rsp_buffer.push_front(item);
  endfunction

endclass


class uvm_sequencer #(type REQ=uvm_sequence_item, RSP=REQ) extends uvm_sequencer_param_base #(REQ, RSP);

   typedef uvm_sequencer #( REQ , RSP) this_type;
   
   bit sequence_item_requested;
   bit get_next_item_called;
   
   `uvm_component_param_utils(this_type)
   
   uvm_seq_item_pull_imp #(REQ, RSP, this_type) seq_item_export;
   
   function RSP                 item_done_get_trigger_data();
     return last_rsp(0);
   endfunction
   
   
   function new (string name, uvm_component parent=null);
     super.new(name, parent);
     seq_item_export = new ("seq_item_export", this);
   endfunction
   
   
   function void stop_sequences();
     REQ t;
     super.stop_sequences();
     sequence_item_requested  = 0;
     get_next_item_called     = 0;
     if (m_req_fifo.used()) begin
       uvm_report_info(get_full_name(), "Sequences stopped.  Removing request from sequencer fifo");
       while (m_req_fifo.try_get(t));
     end
   endfunction
   
   
   virtual function string get_type_name();
     return "uvm_sequencer";
   endfunction 
   
   protected virtual function int m_find_number_driver_connections();
     uvm_port_component_base provided_to_port_list[string];
     uvm_port_component_base seq_port_base;
     
     seq_port_base = seq_item_export.get_comp();
     seq_port_base.get_provided_to(provided_to_port_list);
     return provided_to_port_list.num();
   endfunction
   
   virtual task get_next_item(output REQ t);
     REQ req_item;
   
   
     if (get_next_item_called == 1)
       uvm_report_error(get_full_name(),
         "Get_next_item called twice without item_done or get in between", UVM_NONE);
     
     if (!sequence_item_requested)
       m_select_sequence();
   
     sequence_item_requested = 1;
     get_next_item_called = 1;
     m_req_fifo.peek(t);
   endtask
   
   virtual task try_next_item(output REQ t);
     int selected_sequence;
     time arb_time;
     uvm_sequence_base seq;
   
     if (get_next_item_called == 1) begin
       uvm_report_error(get_full_name(), "get_next_item/try_next_item called twice without item_done or get in between", UVM_NONE);
       return;
     end
       
     wait_for_sequences();
   
     selected_sequence = m_choose_next_request();
   
     if (selected_sequence == -1) begin
       t = null;
       return;
     end
   
     m_set_arbitration_completed(arb_sequence_q[selected_sequence].request_id);
     seq = arb_sequence_q[selected_sequence].sequence_ptr;
     arb_sequence_q.delete(selected_sequence);
     m_update_lists();
     sequence_item_requested = 1;
     get_next_item_called = 1;
   
     wait_for_sequences();
   
     if (!m_req_fifo.try_peek(t))
       uvm_report_error("TRY_NEXT_BLOCKED", {"try_next_item: the selected sequence '", seq.get_full_name(), "' did not produce an item within an NBA delay. ", "Sequences should not consume time between calls to start_item and finish_item. ", "Returning null item."}, UVM_NONE);
   
   endtask
   
   function void item_done(RSP item = null);
     REQ t;
   
     sequence_item_requested = 0;
     get_next_item_called = 0;
     
     if (m_req_fifo.try_get(t) == 0) begin
       uvm_report_fatal(get_full_name(), {"Item_done() called with no outstanding requests.", " Each call to item_done() must be paired with a previous call to get_next_item()."});
     end else begin
       m_wait_for_item_sequence_id = t.get_sequence_id();
       m_wait_for_item_transaction_id = t.get_transaction_id();
     end
     
     if (item != null) begin
       seq_item_export.put_response(item);
     end
   
     grant_queued_locks();
   endfunction
   
   virtual task put (RSP t);
     put_response(t);
   endtask
   
   task get(output REQ t);
     if (sequence_item_requested == 0) begin
       m_select_sequence();
     end
     sequence_item_requested = 1;
     m_req_fifo.peek(t);
     item_done();
   endtask
   
   task peek(output REQ t);
   
     if (sequence_item_requested == 0) begin
       m_select_sequence();
     end
     
     sequence_item_requested = 1;
     m_req_fifo.peek(t);
   endtask
   
   function void item_done_trigger(RSP item = null);
     item_done(item);
   endfunction

endclass  

   typedef uvm_sequencer #(uvm_sequence_item) uvm_virtual_sequencer;

class uvm_push_sequencer #(type REQ=uvm_sequence_item, RSP=REQ) extends uvm_sequencer_param_base #(REQ, RSP);

  typedef uvm_push_sequencer #( REQ , RSP) this_type;
  uvm_blocking_put_port #(REQ) req_port;

  function new (string name, uvm_component parent=null);
    super.new(name, parent);
    req_port = new ("req_port", this);
  endfunction 


  virtual task run_phase(uvm_phase phase);
    REQ t;
    int selected_sequence;

    fork
      super.run_phase(phase);
      forever
        begin
          m_select_sequence();
          m_req_fifo.get(t);
          req_port.put(t);
          m_wait_for_item_sequence_id = t.get_sequence_id();
          m_wait_for_item_transaction_id = t.get_transaction_id();
        end
    join
  endtask

  protected virtual function int  m_find_number_driver_connections();
    return req_port.size();
  endfunction

endclass

class uvm_sequence_base extends uvm_sequence_item;

  protected uvm_sequence_state m_sequence_state;
            int                m_next_transaction_id = 1;
  local     int                m_priority = -1;
            uvm_recorder       m_tr_recorder;
            int                m_wait_for_grant_semaphore;

  protected int m_sqr_seq_ids[int];

  protected bit children_array[uvm_sequence_base];
   
  protected uvm_sequence_item response_queue[$];
  protected int               response_queue_depth = 8;
  protected bit               response_queue_error_report_disabled;

  bit do_not_randomize;

  protected process  m_sequence_process;
  local bit m_use_response_handler;

  static string type_name = "uvm_sequence_base";

  local bit is_rel_default;
  local bit wait_rel_default;


  function new (string name = "uvm_sequence");

    super.new(name);
    m_sequence_state = UVM_CREATED;
    m_wait_for_grant_semaphore = 0;
    m_init_phase_daps(1);
  endfunction

  virtual function bit is_item();
    return 0;
  endfunction

  function uvm_sequence_state_enum get_sequence_state();
    return m_sequence_state;
  endfunction

  task wait_for_sequence_state(int unsigned state_mask);
    wait (m_sequence_state & state_mask);
  endtask

  function integer get_tr_handle();
     if (m_tr_recorder != null)
       return m_tr_recorder.get_handle();
     else
       return 0;
  endfunction

  virtual task start (uvm_sequencer_base sequencer, uvm_sequence_base parent_sequence = null, int this_priority = -1, bit call_pre_post = 1);
    bit                  old_automatic_phase_objection;
     
    set_item_context(parent_sequence, sequencer);

    if (!(m_sequence_state inside {UVM_CREATED,UVM_STOPPED,UVM_FINISHED})) begin
      uvm_report_fatal("SEQ_NOT_DONE", {"Sequence ", get_full_name(), " already started"},UVM_NONE);
    end

    if (m_parent_sequence != null) begin
       m_parent_sequence.children_array[this] = 1;
    end

    if (this_priority < -1) begin
      uvm_report_fatal("SEQPRI", $sformatf("Sequence %s start has illegal priority: %0d", get_full_name(), this_priority), UVM_NONE);
    end
    if (this_priority < 0) begin
       if (parent_sequence == null) this_priority = 100;
       else this_priority = parent_sequence.get_priority();
    end

    clear_response_queue();

    m_priority           = this_priority;

    if (m_sequencer != null) begin
       integer handle;
       uvm_tr_stream stream;
       if (m_parent_sequence == null) begin
          stream = m_sequencer.get_tr_stream(get_name(), "Transactions");
          handle = m_sequencer.begin_tr(this, get_name());
          m_tr_recorder = uvm_recorder::get_recorder_from_handle(handle);
       end else begin
          stream = m_sequencer.get_tr_stream(get_root_sequence_name(), "Transactions");
          handle = m_sequencer.begin_child_tr(this, (m_parent_sequence.m_tr_recorder == null) ? 0 : m_parent_sequence.m_tr_recorder.get_handle(), get_root_sequence_name());
          m_tr_recorder = uvm_recorder::get_recorder_from_handle(handle);
       end
    end

    set_sequence_id(-1);
    m_sqr_seq_ids.delete();

    if (m_sequencer != null) begin
      void'(m_sequencer.m_register_sequence(this));
    end

    m_sequence_state = UVM_PRE_START;
    fork
      begin
        m_sequence_process = std::process::self();

        #0;

        if (get_automatic_phase_objection()) begin
           m_safe_raise_starting_phase("automatic phase objection");
        end
         
        pre_start();

        if (call_pre_post == 1) begin
          m_sequence_state = UVM_PRE_BODY;
          #0;
          pre_body();
        end

        if (parent_sequence != null) begin
          parent_sequence.pre_do(0);    
          parent_sequence.mid_do(this); 
        end

        m_sequence_state = UVM_BODY;
        #0;
        body();

        m_sequence_state = UVM_ENDED;
        #0;

        if (parent_sequence != null) begin
          parent_sequence.post_do(this);
        end

        if (call_pre_post == 1) begin
          m_sequence_state = UVM_POST_BODY;
          #0;
          post_body();
        end

        m_sequence_state = UVM_POST_START;
        #0;
        post_start();

        if (get_automatic_phase_objection()) begin
           m_safe_drop_starting_phase("automatic phase objection");
        end
         
        m_sequence_state = UVM_FINISHED;
        #0;

      end
    join

    if (m_sequencer != null) begin      
      m_sequencer.end_tr(this);
    end
        
    if (m_sequence_state != UVM_STOPPED) begin
      if (m_sequencer != null)
        m_sequencer.m_sequence_exiting(this);
    end

    #0; 

    if ((m_parent_sequence != null) && (m_parent_sequence.children_array.exists(this))) begin
       m_parent_sequence.children_array.delete(this);
    end

    old_automatic_phase_objection = get_automatic_phase_objection();
    m_init_phase_daps(1);
    set_automatic_phase_objection(old_automatic_phase_objection);
  endtask

  virtual task pre_start();  
    return;
  endtask

  virtual task pre_body();  
    return;
  endtask

  virtual task pre_do(bit is_item);
    return;
  endtask

  virtual function void mid_do(uvm_sequence_item this_item);
    return;
  endfunction

  virtual task body();
    uvm_report_warning("uvm_sequence_base", "Body definition undefined");
    return;
  endtask  

  virtual function void post_do(uvm_sequence_item this_item);
    return;
  endfunction

  virtual task post_body();
    return;
  endtask

  virtual task post_start();  
    return;
  endtask

  local uvm_get_to_lock_dap#(bit) m_automatic_phase_objection_dap;
  local uvm_get_to_lock_dap#(uvm_phase) m_starting_phase_dap;

  function void m_init_phase_daps(bit create);
     string apo_name = $sformatf("%s.automatic_phase_objection", get_full_name());
     string sp_name = $sformatf("%s.starting_phase", get_full_name());

     if (create) begin
        m_automatic_phase_objection_dap = uvm_get_to_lock_dap#(bit)::type_id::create(apo_name, get_sequencer());
        m_starting_phase_dap = uvm_get_to_lock_dap#(uvm_phase)::type_id::create(sp_name, get_sequencer());
     end
     else begin
        m_automatic_phase_objection_dap.set_name(apo_name);
        m_starting_phase_dap.set_name(sp_name);
     end
  endfunction : m_init_phase_daps

`ifndef UVM_NO_DEPRECATED
 `define UVM_DEPRECATED_STARTING_PHASE
`endif

`ifdef UVM_DEPRECATED_STARTING_PHASE
  uvm_phase starting_phase;
  uvm_phase m_set_starting_phase;
  bit m_warn_deprecated_set;
`endif 
   
  function uvm_phase get_starting_phase();
`ifdef UVM_DEPRECATED_STARTING_PHASE
     begin
        bit throw_error;

        if (starting_phase != m_set_starting_phase) begin
           if (!m_warn_deprecated_set) begin
              `uvm_warning("UVM_DEPRECATED", "'starting_phase' is deprecated and not part of the UVM standard.  See documentation for uvm_sequence_base::set_starting_phase")
              m_warn_deprecated_set = 1;
           end
           
           if (m_starting_phase_dap.try_set(starting_phase))
             m_set_starting_phase = starting_phase;
           else begin
              uvm_phase dap_phase = m_starting_phase_dap.get();
              `uvm_error("UVM/SEQ/LOCK_DEPR",
                         {"The deprecated 'starting_phase' variable has been set to '",
                          (starting_phase == null) ? "<null>" : starting_phase.get_full_name(), 
                          "' after a call to get_starting_phase locked the value to '",
                          (dap_phase == null) ? "<null>" : dap_phase.get_full_name(), 
                          "'.  See documentation for uvm_sequence_base::set_starting_phase."})
           end
        end

     end
`endif
     return m_starting_phase_dap.get();
  endfunction : get_starting_phase

  function void set_starting_phase(uvm_phase phase);
`ifdef UVM_DEPRECATED_STARTING_PHASE
     begin
        if (starting_phase != m_set_starting_phase) begin
           if (!m_warn_deprecated_set) begin
              `uvm_warning("UVM_DEPRECATED", 
                           {"The deprecated 'starting_phase' variable has been set to '",
                            starting_phase.get_full_name(),
                            "' manually.  See documentation for uvm_sequence_base::set_starting_phase."})
              m_warn_deprecated_set = 1;
           end

           starting_phase = phase;
           m_set_starting_phase = phase;
        end
     end
`endif
           
     m_starting_phase_dap.set(phase);
  endfunction : set_starting_phase
   
  function void set_automatic_phase_objection(bit value);
     m_automatic_phase_objection_dap.set(value);
  endfunction : set_automatic_phase_objection

  function bit get_automatic_phase_objection();
     return m_automatic_phase_objection_dap.get();
  endfunction : get_automatic_phase_objection

  function void m_safe_raise_starting_phase(string description = "", int count = 1);
     uvm_phase starting_phase = get_starting_phase();
     if (starting_phase != null)
       starting_phase.raise_objection(this, description, count);
  endfunction : m_safe_raise_starting_phase

  function void m_safe_drop_starting_phase(string description = "", int count = 1);
     uvm_phase starting_phase = get_starting_phase();
     if (starting_phase != null)
       starting_phase.drop_objection(this, description, count);
  endfunction : m_safe_drop_starting_phase

  function void set_priority (int value);
    m_priority = value;
  endfunction

  function int get_priority();
    return m_priority;
  endfunction

  virtual function bit is_relevant(); 
    is_rel_default = 1;
    return 1;
  endfunction

  virtual task wait_for_relevant();
    event e;
    wait_rel_default = 1;
    if (is_rel_default != wait_rel_default)
      uvm_report_fatal("RELMSM", 
        "is_relevant() was implemented without defining wait_for_relevant()", UVM_NONE);
    @e;  
  endtask

  task lock(uvm_sequencer_base sequencer = null);
    if (sequencer == null)
      sequencer = m_sequencer;

    if (sequencer == null)
      uvm_report_fatal("LOCKSEQR", "Null m_sequencer reference", UVM_NONE);

    sequencer.lock(this);
  endtask

  task grab(uvm_sequencer_base sequencer = null);
    if (sequencer == null) begin
      if (m_sequencer == null) begin
        uvm_report_fatal("GRAB", "Null m_sequencer reference", UVM_NONE);
      end
      m_sequencer.grab(this);
    end
    else begin
      sequencer.grab(this);
    end
  endtask

  function void  unlock(uvm_sequencer_base sequencer = null);
    if (sequencer == null) begin
      if (m_sequencer == null) begin
        uvm_report_fatal("UNLOCK", "Null m_sequencer reference", UVM_NONE);
      end
      m_sequencer.unlock(this);
    end else begin
      sequencer.unlock(this);
    end
  endfunction

  function void  ungrab(uvm_sequencer_base sequencer = null);
    unlock(sequencer);
  endfunction

  function bit is_blocked();
    return m_sequencer.is_blocked(this);
  endfunction

  function bit has_lock();
    return m_sequencer.has_lock(this);
  endfunction

  function void kill();
    if (m_sequence_process != null) begin
      if (m_sequencer == null) begin
        m_kill();
        if (get_automatic_phase_objection()) begin
           m_safe_drop_starting_phase("automatic phase objection");
        end
        return;
      end
      m_sequencer.kill_sequence(this);
      if (get_automatic_phase_objection()) begin
         m_safe_drop_starting_phase("automatic phase objection");
      end
      return;
    end
  endfunction

  virtual function void do_kill();
    return;
  endfunction

  function void m_kill();
    do_kill();
    foreach(children_array[i]) begin
       i.kill();
    end
    if (m_sequence_process != null) begin
      m_sequence_process.kill;
      m_sequence_process = null;
    end
    m_sequence_state = UVM_STOPPED;
    if ((m_parent_sequence != null) && (m_parent_sequence.children_array.exists(this)))
      m_parent_sequence.children_array.delete(this);
  endfunction

  protected function uvm_sequence_item create_item(uvm_object_wrapper type_var, uvm_sequencer_base l_sequencer, string name);

    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    $cast(create_item,  factory.create_object_by_type( type_var, this.get_full_name(), name ));

    create_item.set_item_context(this, l_sequencer);
  endfunction

  virtual task start_item (uvm_sequence_item item, int set_priority = -1, uvm_sequencer_base sequencer=null);
    uvm_sequence_base seq;
     
    if(item == null) begin
      uvm_report_fatal("NULLITM",
         {"attempting to start a null item from sequence '",
          get_full_name(), "'"}, UVM_NONE);
      return;
    end
          
    if($cast(seq, item)) begin
      uvm_report_fatal("SEQNOTITM",
         {"attempting to start a sequence using start_item() from sequence '",
          get_full_name(), "'. Use seq.start() instead."}, UVM_NONE);
      return;
    end
          
    if (sequencer == null)
        sequencer = item.get_sequencer();
        
    if(sequencer == null)
        sequencer = get_sequencer();   
        
    if(sequencer == null) begin
        uvm_report_fatal("SEQ",{"neither the item's sequencer nor dedicated sequencer has been supplied to start item in ",get_full_name()},UVM_NONE);
       return;
    end

    item.set_item_context(this, sequencer);

    if (set_priority < 0)
      set_priority = get_priority();
    
    sequencer.wait_for_grant(this, set_priority);

    if (sequencer.is_auto_item_recording_enabled()) begin
      void'(sequencer.begin_child_tr(item, 
                                     (m_tr_recorder == null) ? 0 : m_tr_recorder.get_handle(), 
                                     item.get_root_sequence_name(), "Transactions"));
    end
    
    pre_do(1);

  endtask  

  virtual task finish_item (uvm_sequence_item item, int set_priority = -1);

    uvm_sequencer_base sequencer;
    
    sequencer = item.get_sequencer();

    if (sequencer == null) begin
        uvm_report_fatal("STRITM", "sequence_item has null sequencer", UVM_NONE);
    end

    mid_do(item);
    sequencer.send_request(this, item);
    sequencer.wait_for_item_done(this, -1);

    if (sequencer.is_auto_item_recording_enabled()) begin
      sequencer.end_tr(item);
    end

    post_do(item);

  endtask

  virtual task wait_for_grant(int item_priority = -1, bit lock_request = 0);
    if (m_sequencer == null) begin
      uvm_report_fatal("WAITGRANT", "Null m_sequencer reference", UVM_NONE);
    end
    m_sequencer.wait_for_grant(this, item_priority, lock_request);
  endtask

  virtual function void send_request(uvm_sequence_item request, bit rerandomize = 0);
    if (m_sequencer == null) begin
        uvm_report_fatal("SENDREQ", "Null m_sequencer reference", UVM_NONE);
      end
    m_sequencer.send_request(this, request, rerandomize);
  endfunction

  virtual task wait_for_item_done(int transaction_id = -1);
    if (m_sequencer == null) begin
        uvm_report_fatal("WAITITEMDONE", "Null m_sequencer reference", UVM_NONE);
      end
    m_sequencer.wait_for_item_done(this, transaction_id);
  endtask

  function void use_response_handler(bit enable);
    m_use_response_handler = enable;
  endfunction

  function bit get_use_response_handler();
    return m_use_response_handler;
  endfunction

  virtual function void response_handler(uvm_sequence_item response);
    return;
  endfunction

  function void set_response_queue_error_report_disabled(bit value);
    response_queue_error_report_disabled = value;
  endfunction

  function bit get_response_queue_error_report_disabled();
    return response_queue_error_report_disabled;
  endfunction

  function void set_response_queue_depth(int value);
    response_queue_depth = value;
  endfunction  

  function int get_response_queue_depth();
    return response_queue_depth;
  endfunction  

  virtual function void clear_response_queue();
    response_queue.delete();
  endfunction

  virtual function void put_base_response(input uvm_sequence_item response);
    if ((response_queue_depth == -1) ||
        (response_queue.size() < response_queue_depth)) begin
      response_queue.push_back(response);
      return;
    end
    if (response_queue_error_report_disabled == 0) begin
      uvm_report_error(get_full_name(), "Response queue overflow, response was dropped", UVM_NONE);
    end
  endfunction

  virtual function void put_response (uvm_sequence_item response_item);
    put_base_response(response_item); 
  endfunction

  virtual task get_base_response(output uvm_sequence_item response, input int transaction_id = -1);

    int queue_size, i;

    if (response_queue.size() == 0)
      wait (response_queue.size() != 0);

    if (transaction_id == -1) begin
      response = response_queue.pop_front();
      return;
    end

    forever begin
      queue_size = response_queue.size();
      for (i = 0; i < queue_size; i++) begin
        if (response_queue[i].get_transaction_id() == transaction_id) 
          begin
            $cast(response,response_queue[i]);
            response_queue.delete(i);
            return;
          end
      end
      wait (response_queue.size() != queue_size);
    end
  endtask

`ifndef UVM_NO_DEPRECATED

  rand int unsigned seq_kind;

  constraint pick_sequence { 
       (num_sequences() <= 2) || (seq_kind >= 2);
       (seq_kind <  num_sequences()) || (seq_kind == 0); }

  function int num_sequences();
    if (m_sequencer == null)
      return 0;
    return (m_sequencer.num_sequences());
  endfunction

  function int get_seq_kind(string type_name);
    `uvm_warning("UVM_DEPRECATED",$sformatf("%m deprecated."))
    if(m_sequencer != null)
      return m_sequencer.get_seq_kind(type_name);
    else 
      uvm_report_warning("NULLSQ", $sformatf("%0s sequencer is null.", get_type_name()), UVM_NONE);
  endfunction

  function uvm_sequence_base get_sequence(int unsigned req_kind);
    uvm_sequence_base m_seq;
    string m_seq_type;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    `uvm_warning("UVM_DEPRECATED",$sformatf("%m deprecated."))
    if (req_kind < 0 || req_kind >= m_sequencer.sequences.size()) begin
      uvm_report_error("SEQRNG", 
        $sformatf("Kind arg '%0d' out of range. Need 0-%0d", req_kind, m_sequencer.sequences.size()-1), UVM_NONE);
    end
    m_seq_type = m_sequencer.sequences[req_kind];
    if (!$cast(m_seq, factory.create_object_by_name(m_seq_type, get_full_name(), m_seq_type))) begin
      uvm_report_fatal("FCTSEQ", $sformatf("Factory cannot produce a sequence of type %0s.", m_seq_type), UVM_NONE);
    end
    m_seq.set_use_sequence_info(1);
    return m_seq;
  endfunction

  task do_sequence_kind(int unsigned req_kind);
    string m_seq_type;
    uvm_sequence_base m_seq;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    `uvm_warning("UVM_DEPRECATED",$sformatf("%m deprecated."))
    m_seq_type = m_sequencer.sequences[req_kind];
    if (!$cast(m_seq, factory.create_object_by_name(m_seq_type, get_full_name(), m_seq_type))) begin
      uvm_report_fatal("FCTSEQ", $sformatf("Factory cannot produce a sequence of type %0s.", m_seq_type), UVM_NONE);
    end

    m_seq.set_item_context(this, m_sequencer);
    
    if(!m_seq.randomize()) begin
      uvm_report_warning("RNDFLD", "Randomization failed in do_sequence_kind()");
    end
    m_seq.start(m_sequencer,this,get_priority(),0);
  endtask

  function uvm_sequence_base get_sequence_by_name(string seq_name);
    uvm_sequence_base m_seq;
    uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
    uvm_factory factory=cs.get_factory();
    `uvm_warning("UVM_DEPRECATED",$sformatf("%m deprecated."))
    if (!$cast(m_seq, factory.create_object_by_name(seq_name, get_full_name(), seq_name))) begin
      uvm_report_fatal("FCTSEQ", $sformatf("Factory cannot produce a sequence of type %0s.", seq_name), UVM_NONE);
    end
    m_seq.set_use_sequence_info(1);
    return m_seq;
  endfunction

  task create_and_start_sequence_by_name(string seq_name);
    uvm_sequence_base m_seq;
    `uvm_warning("UVM_DEPRECATED",$sformatf("%m deprecated."))
    m_seq = get_sequence_by_name(seq_name);
    m_seq.start(m_sequencer, this, this.get_priority(), 0);
  endtask

`endif 

  function int m_get_sqr_sequence_id(int sequencer_id, bit update_sequence_id);
    if (m_sqr_seq_ids.exists(sequencer_id)) begin
      if (update_sequence_id == 1) begin
        set_sequence_id(m_sqr_seq_ids[sequencer_id]);
      end
      return m_sqr_seq_ids[sequencer_id];
    end

    if (update_sequence_id == 1)
      set_sequence_id(-1);

    return -1;
  endfunction

  function void m_set_sqr_sequence_id(int sequencer_id, int sequence_id);
    m_sqr_seq_ids[sequencer_id] = sequence_id;
    set_sequence_id(sequence_id);
  endfunction

endclass                


virtual class uvm_sequence #(type REQ = uvm_sequence_item, type RSP = REQ) extends uvm_sequence_base;

  typedef uvm_sequencer_param_base #(REQ, RSP) sequencer_t;
  sequencer_t        param_sequencer;
  REQ                req;
  RSP                rsp;

  function new (string name = "uvm_sequence");
    super.new(name);
  endfunction

  virtual function void send_request(uvm_sequence_item request, bit rerandomize = 0);
    REQ m_request;
    
    if (m_sequencer == null) begin
      uvm_report_fatal("SSENDREQ", "Null m_sequencer reference", UVM_NONE);
    end
    if (!$cast(m_request, request)) begin
      uvm_report_fatal("SSENDREQ", "Failure to cast uvm_sequence_item to request", UVM_NONE);
    end
    m_sequencer.send_request(this, m_request, rerandomize);
  endfunction

  function REQ get_current_item();
    if (!$cast(param_sequencer, m_sequencer))
      uvm_report_fatal("SGTCURR", "Failure to cast m_sequencer to the parameterized sequencer", UVM_NONE);
    return (param_sequencer.get_current_item());
  endfunction

  virtual task get_response(output RSP response, input int transaction_id = -1);
    uvm_sequence_item rsp;
    get_base_response( rsp, transaction_id);
    $cast(response,rsp);
  endtask

  virtual function void put_response(uvm_sequence_item response_item);
    RSP response;
    if (!$cast(response, response_item)) begin
      uvm_report_fatal("PUTRSP", "Failure to cast response in put_response", UVM_NONE);
    end
    put_base_response(response_item);
  endfunction

  function void do_print (uvm_printer printer);
    super.do_print(printer);
    printer.print_object("req", req);
    printer.print_object("rsp", rsp);
  endfunction

endclass

typedef class uvm_sequence_library_cfg;

class uvm_sequence_library #(type REQ=uvm_sequence_item,RSP=REQ) extends uvm_sequence #(REQ,RSP);

   uvm_sequence_lib_mode selection_mode;
   int unsigned min_random_count=10;
   int unsigned max_random_count=10;
   protected int unsigned sequences_executed;
   rand  int unsigned sequence_count = 10;
   rand  int unsigned select_rand;
   randc bit [15:0] select_randc;
   protected int seqs_distrib[string]  = '{default:0};
   protected uvm_object_wrapper sequences[$];
   `uvm_object_param_utils(uvm_sequence_library #(REQ,RSP))
   typedef uvm_sequence_library #(REQ,RSP) this_type;
   static const string type_name = "uvm_sequence_library #(REQ,RSP)";
   static protected uvm_object_wrapper m_typewide_sequences[$];
   bit m_abort;

   constraint valid_rand_selection {
         select_rand inside {[0:sequences.size()-1]};
   }

   constraint valid_randc_selection {
         select_randc inside {[0:sequences.size()-1]};
   }

   constraint valid_sequence_count {
      sequence_count inside {[min_random_count:max_random_count]};
   }


   function new(string name="");
      super.new(name);
      init_sequence_library();
      valid_rand_selection.constraint_mode(0);
      valid_randc_selection.constraint_mode(0);
   endfunction
   
   virtual function string get_type_name();
     return type_name;
   endfunction
   
   static function bit m_add_typewide_sequence(uvm_object_wrapper seq_type);
     this_type::add_typewide_sequence(seq_type);
     return 1;
   endfunction
   
   static function void add_typewide_sequence(uvm_object_wrapper seq_type);
     if (m_static_check(seq_type))
       m_typewide_sequences.push_back(seq_type);
   endfunction
   
   static function void add_typewide_sequences(uvm_object_wrapper seq_types[$]);
     foreach (seq_types[i])
       add_typewide_sequence(seq_types[i]);
   endfunction
   
   function void add_sequence(uvm_object_wrapper seq_type);
     if (m_dyn_check(seq_type))
       sequences.push_back(seq_type);
   endfunction
   
   virtual function void add_sequences(uvm_object_wrapper seq_types[$]);
     foreach (seq_types[i])
       add_sequence(seq_types[i]);
   endfunction
   
   virtual function void remove_sequence(uvm_object_wrapper seq_type);
     foreach (sequences[i])
       if (sequences[i] == seq_type) begin
         sequences.delete(i);
         return;
       end
   endfunction
   
   virtual function void get_sequences(ref uvm_object_wrapper seq_types[$]);
     foreach (sequences[i])
       seq_types.push_back(sequences[i]);
   endfunction
   
   virtual function int unsigned select_sequence(int unsigned max);
     static int unsigned counter;
     select_sequence = counter;
     counter++;
     if (counter >= max)
       counter = 0;
   endfunction
   
   function void init_sequence_library();
     foreach (this_type::m_typewide_sequences[i])
       sequences.push_back(this_type::m_typewide_sequences[i]);
   endfunction
   
   static function bit m_static_check(uvm_object_wrapper seq_type);
     if (!m_check(seq_type,null))
       return 0;
     foreach (m_typewide_sequences[i])
       if (m_typewide_sequences[i] == seq_type)
         return 0;
     return 1;
   endfunction
   
   function bit m_dyn_check(uvm_object_wrapper seq_type);
     if (!m_check(seq_type,this))
       return 0;
     foreach (sequences[i])
       if (sequences[i] == seq_type)
         return 0;
     return 1;
   endfunction
   
   static function bit m_check(uvm_object_wrapper seq_type, this_type lib);
     uvm_object obj;
     uvm_sequence_base seq;
     uvm_root top;
     uvm_coreservice_t cs;   
     string name;
     string typ;
     obj = seq_type.create_object();
     name = (lib == null) ? type_name : lib.get_full_name();
     typ = (lib == null) ? type_name : lib.get_type_name();
     cs = uvm_coreservice_t::get();   
     top = cs.get_root();
   
     if (!$cast(seq, obj)) begin
       `uvm_error_context("SEQLIB/BAD_SEQ_TYPE", {"Object '",obj.get_type_name(), "' is not a sequence. Cannot add to sequence library '",name, "'"},top)
        return 0;
     end
     return 1;
   endfunction
   
   function void pre_randomize();
     m_get_config();
   endfunction
   
   function void m_get_config();
   
     uvm_sequence_library_cfg cfg;
     string phase_name;
     uvm_phase starting_phase = get_starting_phase();
      
     if (starting_phase != null) begin
       phase_name = {starting_phase.get_name(),"_phase"};
     end
     if (uvm_config_db #(uvm_sequence_library_cfg)::get(m_sequencer, phase_name, "default_sequence.config", cfg) ) begin
       selection_mode = cfg.selection_mode; 
       min_random_count = cfg.min_random_count; 
       max_random_count = cfg.max_random_count; 
     end
     else begin
       void'(uvm_config_db #(int unsigned)::get(m_sequencer, phase_name, "default_sequence.min_random_count", min_random_count) );
   
       void'(uvm_config_db #(int unsigned)::get(m_sequencer, phase_name, "default_sequence.max_random_count", max_random_count) );
   
       void'(uvm_config_db #(uvm_sequence_lib_mode)::get(m_sequencer, phase_name, "default_sequence.selection_mode", selection_mode) );
     end
   
     if (max_random_count == 0) begin
       `uvm_warning("SEQLIB/MAX_ZERO", $sformatf("max_random_count (%0d) zero. Nothing will be done.",
          max_random_count))
       if (min_random_count > max_random_count)
         min_random_count = max_random_count;
     end
     else if (min_random_count > max_random_count) begin
       `uvm_error("SEQLIB/MIN_GT_MAX", $sformatf("min_random_count (%0d) greater than max_random_count (%0d). Setting min to max.",
          min_random_count,max_random_count))
       min_random_count = max_random_count;
     end
     else begin
       if (selection_mode == UVM_SEQ_LIB_ITEM) begin
         uvm_sequencer #(REQ,RSP) seqr;
         uvm_object_wrapper lhs = REQ::get_type();
         uvm_object_wrapper rhs = uvm_sequence_item::get_type();
         if (lhs == rhs) begin
           `uvm_error("SEQLIB/BASE_ITEM", {"selection_mode cannot be UVM_SEQ_LIB_ITEM when ", "the REQ type is the base uvm_sequence_item. Using UVM_SEQ_LIB_RAND mode"})
           selection_mode = UVM_SEQ_LIB_RAND;
         end
         if (m_sequencer == null || !$cast(seqr,m_sequencer)) begin
           `uvm_error("SEQLIB/VIRT_SEQ", {"selection_mode cannot be UVM_SEQ_LIB_ITEM when ", "running as a virtual sequence. Using UVM_SEQ_LIB_RAND mode"})
           selection_mode = UVM_SEQ_LIB_RAND;
         end
       end
     end
   
   endfunction
   
   task body();
   
     uvm_object_wrapper wrap;
     uvm_phase starting_phase = get_starting_phase();
      
     if (m_sequencer == null) begin
       `uvm_fatal("SEQLIB/VIRT_SEQ", {"Sequence library 'm_sequencer' handle is null; ", " no current support for running as a virtual sequence."})
        return;
     end
   
     if (sequences.size() == 0) begin
       `uvm_error("SEQLIB/NOSEQS", "Sequence library does not contain any sequences. Did you forget to call init_sequence_library() in the constructor?")
       return;
     end
   
     if (do_not_randomize)
       m_get_config();
   
     m_safe_raise_starting_phase({"starting sequence library ",get_full_name()," (", get_type_name(),")"});
   
     `uvm_info("SEQLIB/START",
        $sformatf("Starting sequence library %s in %s phase: %0d iterations in mode %s", get_type_name(), (starting_phase != null ? starting_phase.get_name() : "unknown"), sequence_count, selection_mode.name()),UVM_LOW)
   
      `uvm_info("SEQLIB/SPRINT",{"\n",sprint(uvm_default_table_printer)},UVM_FULL)
   
       case (selection_mode)
   
         UVM_SEQ_LIB_RAND: begin
           valid_rand_selection.constraint_mode(1);
           valid_sequence_count.constraint_mode(0);
           for (int i=1; i<=sequence_count; i++) begin
             if (!randomize(select_rand)) begin
               `uvm_error("SEQLIB/RAND_FAIL", "Random sequence selection failed")
               break;
             end
             else begin
               wrap = sequences[select_rand];
             end
             execute(wrap);
           end
           valid_rand_selection.constraint_mode(0);
           valid_sequence_count.constraint_mode(1);
         end
   
         UVM_SEQ_LIB_RANDC: begin
           uvm_object_wrapper q[$];
           valid_randc_selection.constraint_mode(1);
           valid_sequence_count.constraint_mode(0);
           for (int i=1; i<=sequence_count; i++) begin
             if (!randomize(select_randc)) begin
               `uvm_error("SEQLIB/RANDC_FAIL", "Random sequence selection failed")
               break;
             end
             else begin
               wrap = sequences[select_randc];
             end
             q.push_back(wrap);
           end
           valid_randc_selection.constraint_mode(0);
           valid_sequence_count.constraint_mode(1);
           foreach(q[i])
             execute(q[i]);
           valid_randc_selection.constraint_mode(0);
           valid_sequence_count.constraint_mode(1);
         end
   
         UVM_SEQ_LIB_ITEM: begin
           for (int i=1; i<=sequence_count; i++) begin
             wrap = REQ::get_type();
             execute(wrap);
           end
         end
   
         UVM_SEQ_LIB_USER: begin
           for (int i=1; i<=sequence_count; i++) begin
             int user_selection;
             user_selection = select_sequence(sequences.size()-1);
             if (user_selection >= sequences.size()) begin
               `uvm_error("SEQLIB/USER_FAIL", "User sequence selection out of range")
               wrap = REQ::get_type();
             end
             else begin
               wrap = sequences[user_selection];
             end
             execute(wrap);
           end
         end
   
         default: begin
           `uvm_fatal("SEQLIB/RAND_MODE", 
              $sformatf("Unknown random sequence selection mode: %0d",selection_mode))
         end
        endcase
   
     `uvm_info("SEQLIB/END",{"Ending sequence library in phase ", (starting_phase != null ? starting_phase.get_name() : "unknown")},UVM_LOW)
    
     `uvm_info("SEQLIB/DSTRB",$sformatf("%p",seqs_distrib),UVM_HIGH)
   
     m_safe_drop_starting_phase({"starting sequence library ",get_full_name()," (", get_type_name(),")"});
   
   endtask
   
   virtual task execute(uvm_object_wrapper wrap);
   
     uvm_object obj;
     uvm_sequence_item seq_or_item;
     uvm_sequence_base seq_base;
     REQ req_item;
     
     uvm_coreservice_t cs = uvm_coreservice_t::get();                                                     
     uvm_factory factory=cs.get_factory();
   
     obj = factory.create_object_by_type(wrap,get_full_name(), $sformatf("%s:%0d",wrap.get_type_name(),sequences_executed+1));
   
     if (!$cast(seq_base, obj)) begin
        if (!$cast(req_item, obj)) begin
           `uvm_error("SEQLIB/WRONG_ITEM_TYPE", {"The item created by '", get_full_name(), "' when in 'UVM_SEQ_LIB_ITEM' mode doesn't match the REQ type which  was passed in to the uvm_sequence_library#(REQ[,RSP]), this can happen if the REQ type which was passed in was a pure-virtual type.  Either configure the factory overrides to properly generate items for this sequence library, or do not execute this sequence library in UVM_SEQ_LIB_ITEM mode."})
            return;
        end
     end
      
     void'($cast(seq_or_item,obj));  
      
     `uvm_info("SEQLIB/EXEC",{"Executing ",(seq_or_item.is_item() ? "item " : "sequence "),seq_or_item.get_name(), " (",seq_or_item.get_type_name(),")"},UVM_FULL)
     seq_or_item.print_sequence_info = 1;
     `uvm_rand_send(seq_or_item)
     seqs_distrib[seq_or_item.get_type_name()] = seqs_distrib[seq_or_item.get_type_name()]+1;
   
     sequences_executed++;
   
   endtask
   
   function void do_print(uvm_printer printer);
      printer.print_field_int("min_random_count",min_random_count,32,UVM_DEC,,"int unsigned");
      printer.print_field_int("max_random_count",max_random_count,32,UVM_DEC,,"int unsigned");
      printer.print_generic("selection_mode","uvm_sequence_lib_mode",32,selection_mode.name());
      printer.print_field_int("sequence_count",sequence_count,32,UVM_DEC,,"int unsigned");
   
      printer.print_array_header("typewide_sequences",m_typewide_sequences.size(),"queue_object_types");
      foreach (m_typewide_sequences[i])
        printer.print_generic($sformatf("[%0d]",i),"uvm_object_wrapper","-",m_typewide_sequences[i].get_type_name());
      printer.print_array_footer();
   
      printer.print_array_header("sequences",sequences.size(),"queue_object_types");
      foreach (sequences[i])
        printer.print_generic($sformatf("[%0d]",i),"uvm_object_wrapper","-",sequences[i].get_type_name());
      printer.print_array_footer();
   
      printer.print_array_header("seqs_distrib",seqs_distrib.num(),"as_int_string");
      foreach (seqs_distrib[typ]) begin
        printer.print_field_int({"[",typ,"]"},seqs_distrib[typ],32,,UVM_DEC,"int unsigned");
      end
      printer.print_array_footer();
   endfunction

endclass

class uvm_sequence_library_cfg extends uvm_object;
  `uvm_object_utils(uvm_sequence_library_cfg)
  uvm_sequence_lib_mode selection_mode;
  int unsigned min_random_count;
  int unsigned max_random_count;
  function new(string name="", uvm_sequence_lib_mode mode=UVM_SEQ_LIB_RAND, int unsigned min=1, int unsigned max=10);
    super.new(name);
    selection_mode = mode;
    min_random_count = min;
    max_random_count = max;
  endfunction
endclass

`ifndef UVM_NO_DEPRECATED

class uvm_random_sequence extends uvm_sequence #(uvm_sequence_item);

  rand protected int unsigned l_count=-1;
  local int unsigned l_exhaustive_seq_kind;
  local int unsigned max_kind;
  rand local int unsigned l_kind;
  protected bit m_success;

  function int unsigned get_count();
    if(l_count == -1)
      return m_sequencer.count;
    return l_count;
  endfunction
  
  function new(string name="uvm_random_sequence");
    super.new(name);
  endfunction
  
  virtual task body();
    pick_sequence.constraint_mode(0);
    if (m_sequencer.count == -1) begin
      if (!randomize(l_count) with { l_count > 0 &&
                                     l_count < m_sequencer.max_random_count; })
        uvm_report_fatal("RANDSEQ", "Randomization for l_count failed in random sequence body", UVM_NONE);
      m_sequencer.count = l_count;
    end
    else
      l_count = m_sequencer.count;
    max_kind = m_sequencer.sequences.size();
    l_exhaustive_seq_kind = m_sequencer.get_seq_kind("uvm_exhaustive_sequence");
    repeat (l_count) begin
      if (!randomize(l_kind) with { l_kind > l_exhaustive_seq_kind && 
        l_kind < max_kind; })
        uvm_report_fatal("RANDSEQ", "Randomization for l_kind failed in random sequence body", UVM_NONE);
      do_sequence_kind(l_kind);
    end
    m_sequencer.m_random_count++;
    pick_sequence.constraint_mode(1);
  endtask 
  
  function void do_copy (uvm_object rhs);
    uvm_random_sequence seq;
    if(rhs==null) return;
    if(!$cast(seq, rhs)) return;
    l_count = seq.l_count;
  endfunction
  
  function bit do_compare (uvm_object rhs, uvm_comparer comparer);
    uvm_random_sequence seq;
    do_compare = 1;
    if(rhs==null) return 0;
    if(!$cast(seq, rhs)) return 0;
    do_compare &= comparer.compare_field_int("l_count", l_count, seq.l_count, 
      $bits(l_count));
  endfunction
  
  virtual function void do_print (uvm_printer printer);
    printer.print_field_int("l_count", l_count, $bits(l_count));
  endfunction
  
  function void do_record (uvm_recorder recorder);
    recorder.record_field_int("l_count", l_count, $bits(l_count));
  endfunction 

  function uvm_object create (string name="");
    uvm_random_sequence i; i=new(name);
    return i;
  endfunction

  virtual function string get_type_name();
     return "uvm_random_sequence";
  endfunction

  `uvm_object_registry(uvm_random_sequence, "uvm_random_sequence")

endclass



class uvm_exhaustive_sequence extends uvm_sequence #(uvm_sequence_item);

  rand protected int unsigned l_count;
  local int unsigned l_exhaustive_seq_kind;
  local int unsigned max_kind;
  randc local bit[9:0] l_kind;
  protected bit m_success;

  function new(string name="uvm_exhaustive_sequence");
    super.new(name);
  endfunction
  
  task body();
    int i;
      
    pick_sequence.constraint_mode(0);
      
    l_count = m_sequencer.sequences.size() - 2;
    max_kind = m_sequencer.sequences.size();
    l_exhaustive_seq_kind = m_sequencer.get_seq_kind("uvm_exhaustive_sequence");
    repeat (l_count) begin
      if (!randomize(l_kind) with { l_kind > l_exhaustive_seq_kind; 
        l_kind < max_kind; }) 
        uvm_report_fatal("RANDSEQ", "Randomization for l_kind failed in exhaustive sequence body", UVM_NONE);
  
      do_sequence_kind(l_kind);
    end
    m_sequencer.m_exhaustive_count++;
    pick_sequence.constraint_mode(1);
  endtask 
  
  
  function void do_copy (uvm_object rhs);
    uvm_exhaustive_sequence seq;
    if(rhs==null) return;
    if(!$cast(seq, rhs)) return;
    l_count = seq.l_count;
  endfunction
  
  function bit do_compare (uvm_object rhs, uvm_comparer comparer);
    uvm_exhaustive_sequence seq;
    do_compare = 1;
    if(rhs==null) return 0;
    if(!$cast(seq, rhs)) return 0;
    do_compare &= comparer.compare_field_int("l_count", l_count, seq.l_count, 
      $bits(l_count));
  endfunction
  
  function void do_print (uvm_printer printer);
    printer.print_field_int("l_count", l_count, $bits(l_count));
  endfunction
  
  function void do_record (uvm_recorder recorder);
    recorder.record_field_int("l_count", l_count, $bits(l_count));
  endfunction 
  
  function uvm_object create (string name="");
    uvm_exhaustive_sequence i; i=new(name);
    return i;
  endfunction
  
  virtual function string get_type_name();
     return "uvm_exhaustive_sequence";
  endfunction
  
  `uvm_object_registry(uvm_exhaustive_sequence, "uvm_exhaustive_sequence")

endclass

class uvm_simple_sequence extends uvm_sequence #(uvm_sequence_item);

  protected rand uvm_sequence_item item;

  function new (string name="uvm_simple_sequence");
    super.new(name);
    item = new;
  endfunction

  task body();
    `uvm_do(item)
    m_sequencer.m_simple_count++;
  endtask

  function uvm_object create (string name="");
    uvm_simple_sequence i;
    i=new(name);
    return i;
  endfunction

  virtual function string get_type_name();
     return "uvm_simple_sequence";
  endfunction

  `uvm_object_registry(uvm_simple_sequence, "uvm_simple_sequence")

endclass

`endif 


typedef uvm_sequence  #(uvm_sequence_item, uvm_sequence_item) uvm_default_sequence_type;
typedef uvm_sequencer #(uvm_sequence_item, uvm_sequence_item) uvm_default_sequencer_type;
typedef uvm_driver    #(uvm_sequence_item, uvm_sequence_item) uvm_default_driver_type;
typedef uvm_sequencer_param_base #(uvm_sequence_item, uvm_sequence_item) uvm_default_sequencer_param_type;

`define UVM_TLM_NB_FW_MASK  (1<<0)
`define UVM_TLM_NB_BW_MASK  (1<<1)
`define UVM_TLM_B_MASK      (1<<2)

class uvm_tlm_time;

   static local real m_resolution = 1.0e-12; 
   local real m_res;
   local time m_time;  
   local string m_name;

   static function void set_time_resolution(real res);
      m_resolution = res;
   endfunction

   function new(string name = "uvm_tlm_time", real res = 0);
      m_name = name;
      m_res = (res == 0) ? m_resolution : res;
      reset();
   endfunction

   function string get_name();
      return m_name;
   endfunction

   function void reset();
      m_time = 0;
   endfunction

   local function real to_m_res(real t, time scaled, real secs);
      return t/real'(scaled) * (secs/m_res);
   endfunction
   
   function real get_realtime(time scaled, real secs = 1.0e-9);
      return m_time*real'(scaled) * m_res/secs;
   endfunction

   function void incr(real t, time scaled, real secs = 1.0e-9);
      if (t < 0.0) begin
         `uvm_error("UVM/TLM/TIMENEG", {"Cannot increment uvm_tlm_time variable ", m_name, " by a negative value"});
         return;
      end
      if (scaled == 0) begin
         `uvm_fatal("UVM/TLM/BADSCALE", "uvm_tlm_time::incr() called with a scaled time literal that is smaller than the current timescale")
      end

      m_time += to_m_res(t, scaled, secs);
   endfunction

   function void decr(real t, time scaled, real secs);
      if (t < 0.0) begin
         `uvm_error("UVM/TLM/TIMENEG", {"Cannot decrement uvm_tlm_time variable ", m_name, " by a negative value"});
         return;
      end
      if (scaled == 0) begin
         `uvm_fatal("UVM/TLM/BADSCALE", "uvm_tlm_time::decr() called with a scaled time literal that is smaller than the current timescale")
      end
      
      m_time -= to_m_res(t, scaled, secs);

      if (m_time < 0.0) begin
         `uvm_error("UVM/TLM/TOODECR", {"Cannot decrement uvm_tlm_time variable ", m_name, " to a negative value"});
         reset();
      end
   endfunction

   function real get_abstime(real secs);
      return m_time*m_res/secs;
   endfunction

   function void set_abstime(real t, real secs);
      m_time = t*secs/m_res;
   endfunction
endclass

typedef enum
{
    UVM_TLM_READ_COMMAND,
    UVM_TLM_WRITE_COMMAND,
    UVM_TLM_IGNORE_COMMAND
} uvm_tlm_command_e;

typedef enum
{
    UVM_TLM_OK_RESPONSE = 1,
    UVM_TLM_INCOMPLETE_RESPONSE = 0,
    UVM_TLM_GENERIC_ERROR_RESPONSE = -1,
    UVM_TLM_ADDRESS_ERROR_RESPONSE = -2,
    UVM_TLM_COMMAND_ERROR_RESPONSE = -3,
    UVM_TLM_BURST_ERROR_RESPONSE = -4,
    UVM_TLM_BYTE_ENABLE_ERROR_RESPONSE = -5
} uvm_tlm_response_status_e;

typedef class uvm_tlm_extension_base;

class uvm_tlm_generic_payload extends uvm_sequence_item;
   
  rand bit [63:0]             m_address;
  rand uvm_tlm_command_e          m_command;
  rand byte unsigned             m_data[];
  rand int unsigned           m_length;
  rand uvm_tlm_response_status_e  m_response_status;
  bit m_dmi;
  rand byte unsigned          m_byte_enable[];
  rand int unsigned m_byte_enable_length;
  rand int unsigned m_streaming_width;
  protected uvm_tlm_extension_base m_extensions [uvm_tlm_extension_base];
  local rand uvm_tlm_extension_base m_rand_exts[];

  `uvm_object_utils(uvm_tlm_generic_payload)

  function new(string name="");
    super.new(name);
    m_address = 0;
    m_command = UVM_TLM_IGNORE_COMMAND;
    m_length = 0;
    m_response_status = UVM_TLM_INCOMPLETE_RESPONSE;
    m_dmi = 0;
    m_byte_enable_length = 0;
    m_streaming_width = 0;
  endfunction


  function void do_print(uvm_printer printer);
    byte unsigned be;
    super.do_print(printer);
    printer.print_field_int     ("address", m_address, 64, UVM_HEX);
    printer.print_generic ("command", "uvm_tlm_command_e", 32, m_command.name());
    printer.print_generic ("response_status", "uvm_tlm_response_status_e", 32, m_response_status.name());
    printer.print_field_int     ("streaming_width", m_streaming_width, 32, UVM_HEX);

    printer.print_array_header("data", m_length, "darray(byte)");
    for (int i=0; i < m_length && i < m_data.size(); i++) begin
      if (m_byte_enable_length) begin
        be = m_byte_enable[i % m_byte_enable_length];
        printer.print_generic ($sformatf("[%0d]",i), "byte", 8, $sformatf("'h%h%s",m_data[i],((be=='hFF) ? "" : " x")));
      end
      else 
        printer.print_generic ($sformatf("[%0d]",i), "byte", 8, $sformatf("'h%h",m_data[i]));
    end
    printer.print_array_footer();

    begin
    string name;
    printer.print_array_header("extensions", m_extensions.num(), "aa(obj,obj)");
    foreach (m_extensions[ext_]) begin
      uvm_tlm_extension_base ext = m_extensions[ext_];
      name = {"[",ext.get_name(),"]"};
      printer.print_object(name, ext, "[");
    end
    printer.print_array_footer();
    end
  endfunction


  function void do_copy(uvm_object rhs);
    uvm_tlm_generic_payload gp;
    super.do_copy(rhs);
    $cast(gp, rhs);
    m_address            = gp.m_address;
    m_command            = gp.m_command;
    m_data               = gp.m_data;
    m_dmi                = gp.m_dmi;
    m_length             = gp.m_length;
    m_response_status    = gp.m_response_status;
    m_byte_enable        = gp.m_byte_enable;
    m_streaming_width    = gp.m_streaming_width;
    m_byte_enable_length = gp.m_byte_enable_length;

    m_extensions.delete();
    foreach (gp.m_extensions[ext])
       $cast(m_extensions[ext], gp.m_extensions[ext].clone());
    
  endfunction
   

  function bit do_compare(uvm_object rhs, uvm_comparer comparer);
    uvm_tlm_generic_payload gp;
    do_compare = super.do_compare(rhs, comparer);
    $cast(gp, rhs);

    do_compare = (m_address == gp.m_address && m_command == gp.m_command && m_length  == gp.m_length  && m_dmi     == gp.m_dmi && m_byte_enable_length == gp.m_byte_enable_length  && m_response_status    == gp.m_response_status && m_streaming_width    == gp.m_streaming_width );
    
    if (do_compare && m_length == gp.m_length) begin
        byte unsigned lhs_be, rhs_be;
        for (int i=0; do_compare && i < m_length && i < m_data.size(); i++) begin
          if (m_byte_enable_length) begin
            lhs_be = m_byte_enable[i % m_byte_enable_length];
            rhs_be = gp.m_byte_enable[i % gp.m_byte_enable_length];
            do_compare = ((m_data[i] & lhs_be) == (gp.m_data[i] & rhs_be));
          end
          else begin
            do_compare = (m_data[i] == gp.m_data[i]);
          end
        end
     end

    if (do_compare)
      foreach (m_extensions[ext_]) begin
         uvm_tlm_extension_base ext = ext_;
         uvm_tlm_extension_base rhs_ext = gp.m_extensions.exists(ext) ?  gp.m_extensions[ext] : null;
         do_compare = comparer.compare_object(ext.get_name(), m_extensions[ext], rhs_ext);
         if (!do_compare) break;
      end

    if (do_compare)
      foreach (gp.m_extensions[ext_]) begin
        uvm_tlm_extension_base ext = ext_;
        if (!m_extensions.exists(ext)) begin
              do_compare = comparer.compare_object(ext.get_name(), null, gp.m_extensions[ext]);
          if (!do_compare) break;
        end
      end

    if (!do_compare && comparer.show_max > 0) begin
      string msg = $sformatf("GP miscompare between '%s' and '%s':\nlhs = %s\nrhs = %s", get_full_name(), gp.get_full_name(), this.convert2string(), gp.convert2string());
      case (comparer.sev)
        UVM_WARNING: `uvm_warning("MISCMP", msg)
        UVM_ERROR:   `uvm_error("MISCMP", msg)
        default:     `uvm_info("MISCMP", msg, UVM_LOW)
      endcase
    end

  endfunction
   

  function void do_pack(uvm_packer packer);
    super.do_pack(packer);
    if (m_length > m_data.size())
       `uvm_fatal("PACK_DATA_ARR",
         $sformatf("Data array m_length property (%0d) greater than m_data.size (%0d)", m_length,m_data.size()))
    if (m_byte_enable_length > m_byte_enable.size())
       `uvm_fatal("PACK_DATA_ARR",
         $sformatf("Data array m_byte_enable_length property (%0d) greater than m_byte_enable.size (%0d)", m_byte_enable_length,m_byte_enable.size()))
    `uvm_pack_intN  (m_address,64)
    `uvm_pack_enumN (m_command,32)
    `uvm_pack_intN  (m_length,32)
    for (int i=0; i<m_length; i++)
      `uvm_pack_intN(m_data[i],8)
    `uvm_pack_enumN (m_response_status,32)
    `uvm_pack_intN  (m_byte_enable_length,32)
    for (int i=0; i<m_byte_enable_length; i++)
      `uvm_pack_intN(m_byte_enable[i],8)
    `uvm_pack_intN  (m_streaming_width,32)

  endfunction


  function void do_unpack(uvm_packer packer);
    super.do_unpack(packer);
    `uvm_unpack_intN  (m_address,64)
    `uvm_unpack_enumN (m_command, 32, uvm_tlm_command_e)
    `uvm_unpack_intN  (m_length,32)
    if (m_data.size() < m_length)
      m_data = new[m_length];
    foreach (m_data[i])
      `uvm_unpack_intN(m_data[i],8)
    `uvm_unpack_enumN (m_response_status, 32, uvm_tlm_response_status_e)
    `uvm_unpack_intN  (m_byte_enable_length,32)
    if (m_byte_enable.size() < m_byte_enable_length)
      m_byte_enable = new[m_byte_enable_length];
    for (int i=0; i<m_byte_enable_length; i++)
      `uvm_unpack_intN(m_byte_enable[i],8)
    `uvm_unpack_intN  (m_streaming_width,32)

  endfunction


  function void do_record(uvm_recorder recorder);
    if (!is_recording_enabled())
      return;
    super.do_record(recorder);
    `uvm_record_int("address",m_address,$bits(m_address))
    `uvm_record_string("command",m_command.name())
    `uvm_record_int("data_length",m_length,$bits(m_length))
    `uvm_record_int("byte_enable_length",m_byte_enable_length,$bits(m_byte_enable_length))
    `uvm_record_string("response_status",m_response_status.name())
    `uvm_record_int("streaming_width",m_streaming_width,$bits(m_streaming_width))

    for (int i=0; i < m_length; i++)
      `uvm_record_int($sformatf("\\data[%0d] ", i), m_data[i], $bits(m_data[i]))

    for (int i=0; i < m_byte_enable_length; i++)
      `uvm_record_int($sformatf("\\byte_en[%0d] ", i), m_byte_enable[i], $bits(m_byte_enable[i]))

    foreach (m_extensions[ext])
      recorder.record_object(ext.get_name(),m_extensions[ext]);
  endfunction


  function string convert2string();

    string msg;
    string s;

    $sformat(msg, "%s %s [0x%16x] =", super.convert2string(), m_command.name(), m_address);

    for(int unsigned i = 0; i < m_length; i++) begin
      if (!m_byte_enable_length || (m_byte_enable[i % m_byte_enable_length] == 'hFF))
        $sformat(s, " %02x", m_data[i]);
      else
        $sformat(s, " --");
      msg = { msg , s };
    end

    msg = { msg, " (status=", get_response_string(), ")" };

    return msg;

  endfunction




  virtual function uvm_tlm_command_e get_command();
    return m_command;
  endfunction

   
  virtual function void set_command(uvm_tlm_command_e command);
    m_command = command;
  endfunction

   
  virtual function bit is_read();
    return (m_command == UVM_TLM_READ_COMMAND);
  endfunction
 
   
  virtual function void set_read();
    set_command(UVM_TLM_READ_COMMAND);
  endfunction

 
  virtual function bit is_write();
    return (m_command == UVM_TLM_WRITE_COMMAND);
  endfunction
 

  virtual function void set_write();
    set_command(UVM_TLM_WRITE_COMMAND);
  endfunction
  
  virtual function void set_address(bit [63:0] addr);
    m_address = addr;
  endfunction

 
  virtual function bit [63:0] get_address();
    return m_address;
  endfunction

 
  virtual function void get_data (output byte unsigned p []);
    p = m_data;
  endfunction


  virtual function void set_data(ref byte unsigned p []);
    m_data = p;
  endfunction 
  
   
  virtual function int unsigned get_data_length();
    return m_length;
  endfunction

   
   virtual function void set_data_length(int unsigned length);
    m_length = length;
  endfunction

  
  virtual function int unsigned get_streaming_width();
    return m_streaming_width;
  endfunction

 
   
  virtual function void set_streaming_width(int unsigned width);
    m_streaming_width = width;
  endfunction

  virtual function void get_byte_enable(output byte unsigned p[]);
    p = m_byte_enable;
  endfunction

   
  virtual function void set_byte_enable(ref byte unsigned p[]);
    m_byte_enable = p;
  endfunction

   
  virtual function int unsigned get_byte_enable_length();
    return m_byte_enable_length;
  endfunction

   
 virtual function void set_byte_enable_length(int unsigned length);
    m_byte_enable_length = length;
  endfunction

   
  virtual function void set_dmi_allowed(bit dmi);
    m_dmi = dmi;
  endfunction
   

 virtual function bit is_dmi_allowed();
    return m_dmi;
  endfunction

   
  virtual function uvm_tlm_response_status_e get_response_status();
    return m_response_status;
  endfunction


  virtual function void set_response_status(uvm_tlm_response_status_e status);
    m_response_status = status;
  endfunction


  virtual function bit is_response_ok();
    return (int'(m_response_status) > 0);
  endfunction


  virtual function bit is_response_error();
    return !is_response_ok();
  endfunction


  virtual function string get_response_string();

    case(m_response_status)
      UVM_TLM_OK_RESPONSE                : return "OK";
      UVM_TLM_INCOMPLETE_RESPONSE        : return "INCOMPLETE";
      UVM_TLM_GENERIC_ERROR_RESPONSE     : return "GENERIC_ERROR";
      UVM_TLM_ADDRESS_ERROR_RESPONSE     : return "ADDRESS_ERROR";
      UVM_TLM_COMMAND_ERROR_RESPONSE     : return "COMMAND_ERROR";
      UVM_TLM_BURST_ERROR_RESPONSE       : return "BURST_ERROR";
      UVM_TLM_BYTE_ENABLE_ERROR_RESPONSE : return "BYTE_ENABLE_ERROR";
    endcase

    return "UNKNOWN_RESPONSE";

  endfunction


   
  function uvm_tlm_extension_base set_extension(uvm_tlm_extension_base ext);
    uvm_tlm_extension_base ext_handle = ext.get_type_handle();
    if(!m_extensions.exists(ext_handle))
      set_extension = null;
    else
      set_extension = m_extensions[ext_handle];
    m_extensions[ext_handle] = ext;
  endfunction


   
  function int get_num_extensions();
    return m_extensions.num();
  endfunction: get_num_extensions
   

   
  function uvm_tlm_extension_base get_extension(uvm_tlm_extension_base ext_handle);
    if(!m_extensions.exists(ext_handle))
      return null;
    return m_extensions[ext_handle];
  endfunction
   

   
  function void clear_extension(uvm_tlm_extension_base ext_handle);
    if(m_extensions.exists(ext_handle))
      m_extensions.delete(ext_handle);
    else
      `uvm_info("GP_EXT", $sformatf("Unable to find extension to clear"), UVM_MEDIUM);
  endfunction


   
  function void clear_extensions();
    m_extensions.delete();
  endfunction


  function void pre_randomize();
    int i;
    m_rand_exts = new [m_extensions.num()];
    foreach (m_extensions[ext_]) begin
      uvm_tlm_extension_base ext = ext_;
      m_rand_exts[i++] = m_extensions[ext];
    end
  endfunction

  function void post_randomize();
     m_rand_exts.delete();
  endfunction
endclass


typedef uvm_tlm_generic_payload uvm_tlm_gp;


virtual class uvm_tlm_extension_base extends uvm_object;

  function new(string name = "");
    super.new(name);
  endfunction


  pure virtual function uvm_tlm_extension_base get_type_handle();


  pure virtual function string get_type_handle_name();

  virtual function void do_copy(uvm_object rhs);
    super.do_copy(rhs);
  endfunction

   
  virtual function uvm_object create (string name="");
    return null;
  endfunction

endclass



class uvm_tlm_extension #(type T=int) extends uvm_tlm_extension_base;

   typedef uvm_tlm_extension#(T) this_type;

   local static this_type m_my_tlm_ext_type = ID();


   function new(string name="");
     super.new(name);
   endfunction

  static function this_type ID();
    if (m_my_tlm_ext_type == null)
      m_my_tlm_ext_type = new();
    return m_my_tlm_ext_type;
  endfunction

  virtual function uvm_tlm_extension_base get_type_handle();
     return ID();
  endfunction

  virtual function string get_type_handle_name();
    return `uvm_typename(T);
  endfunction

  virtual function uvm_object create (string name="");
    return null;
  endfunction

endclass


typedef enum
  {
    UNINITIALIZED_PHASE,
    BEGIN_REQ,
    END_REQ,
    BEGIN_RESP,
    END_RESP
  } uvm_tlm_phase_e;

typedef enum 
  {
    UVM_TLM_ACCEPTED,
    UVM_TLM_UPDATED,
    UVM_TLM_COMPLETED
  } uvm_tlm_sync_e;

`define UVM_TLM_TASK_ERROR "TLM-2 interface task not implemented"

`define UVM_TLM_FUNCTION_ERROR "TLM-2 interface function not implemented"

class uvm_tlm_if #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e);
   
  virtual function uvm_tlm_sync_e nb_transport_fw(T t, ref P p, input uvm_tlm_time delay);
    `uvm_error("nb_transport_fw", `UVM_TLM_FUNCTION_ERROR)
    return UVM_TLM_ACCEPTED;
  endfunction
   
  virtual function uvm_tlm_sync_e nb_transport_bw(T t, ref P p, input uvm_tlm_time delay);
    `uvm_error("nb_transport_bw", `UVM_TLM_FUNCTION_ERROR)
    return UVM_TLM_ACCEPTED;
  endfunction
   
  virtual task b_transport(T t, uvm_tlm_time delay);
    `uvm_error("b_transport", `UVM_TLM_TASK_ERROR)
  endtask

endclass


`define UVM_TLM_NB_TRANSPORT_FW_IMP(imp, T, P, t, p, delay)              \
  function uvm_tlm_sync_e nb_transport_fw(T t, ref P p, input uvm_tlm_time delay);  \
    if (delay == null) begin \
       `uvm_error("UVM/TLM/NULLDELAY", \
                  {get_full_name(), \
                   ".nb_transport_fw() called with 'null' delay"}) \
       return UVM_TLM_COMPLETED; \
    end \
    return imp.nb_transport_fw(t, p, delay);                          \
  endfunction


`define UVM_TLM_NB_TRANSPORT_BW_IMP(imp, T, P, t, p, delay) \
  function uvm_tlm_sync_e nb_transport_bw(T t, ref P p, input uvm_tlm_time delay);  \
    if (delay == null) begin \
       `uvm_error("UVM/TLM/NULLDELAY", \
                  {get_full_name(), \
                   ".nb_transport_bw() called with 'null' delay"}) \
       return UVM_TLM_COMPLETED; \
    end \
    return imp.nb_transport_bw(t, p, delay); \
  endfunction

`define UVM_TLM_B_TRANSPORT_IMP(imp, T, t, delay)                        \
  task b_transport(T t, uvm_tlm_time delay);                              \
    if (delay == null) begin \
       `uvm_error("UVM/TLM/NULLDELAY", \
                  {get_full_name(), \
                   ".b_transport() called with 'null' delay"}) \
       return; \
    end \
    imp.b_transport(t, delay);                                        \
  endtask

class uvm_tlm_b_transport_imp #(type T=uvm_tlm_generic_payload, type IMP=int) extends uvm_port_base #(uvm_tlm_if #(T));
  `UVM_IMP_COMMON(`UVM_TLM_B_MASK, "uvm_tlm_b_transport_imp", IMP)
  `UVM_TLM_B_TRANSPORT_IMP(m_imp, T, t, delay)
endclass

class uvm_tlm_nb_transport_fw_imp #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e, type IMP=int)
  extends uvm_port_base #(uvm_tlm_if #(T,P));
  `UVM_IMP_COMMON(`UVM_TLM_NB_FW_MASK, "uvm_tlm_nb_transport_fw_imp", IMP)
  `UVM_TLM_NB_TRANSPORT_FW_IMP(m_imp, T, P, t, p, delay)
endclass

class uvm_tlm_nb_transport_bw_imp #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e, type IMP=int)
  extends uvm_port_base #(uvm_tlm_if #(T,P));
  `UVM_IMP_COMMON(`UVM_TLM_NB_BW_MASK, "uvm_tlm_nb_transport_bw_imp", IMP)
  `UVM_TLM_NB_TRANSPORT_BW_IMP(m_imp, T, P, t, p, delay)
endclass

class uvm_tlm_b_transport_port #(type T=uvm_tlm_generic_payload) extends uvm_port_base #(uvm_tlm_if #(T));
  `UVM_PORT_COMMON(`UVM_TLM_B_MASK, "uvm_tlm_b_transport_port")
  `UVM_TLM_B_TRANSPORT_IMP(this.m_if, T, t, delay)
endclass
  
class uvm_tlm_nb_transport_fw_port #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e) extends uvm_port_base #(uvm_tlm_if #(T,P));
  `UVM_PORT_COMMON(`UVM_TLM_NB_FW_MASK, "uvm_tlm_nb_transport_fw_port")
  `UVM_TLM_NB_TRANSPORT_FW_IMP(this.m_if, T, P, t, p, delay)
endclass
  
class uvm_tlm_nb_transport_bw_port #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e) extends uvm_port_base #(uvm_tlm_if #(T,P));

  `UVM_PORT_COMMON(`UVM_TLM_NB_BW_MASK, "uvm_tlm_nb_transport_bw_port")
  `UVM_TLM_NB_TRANSPORT_BW_IMP(this.m_if, T, P, t, p, delay)
endclass


class uvm_tlm_b_transport_export #(type T=uvm_tlm_generic_payload) extends uvm_port_base #(uvm_tlm_if #(T));
  `UVM_EXPORT_COMMON(`UVM_TLM_B_MASK, "uvm_tlm_b_transport_export")
  `UVM_TLM_B_TRANSPORT_IMP(this.m_if, T, t, delay)
endclass

class uvm_tlm_nb_transport_fw_export #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e) extends uvm_port_base #(uvm_tlm_if #(T,P));
  `UVM_EXPORT_COMMON(`UVM_TLM_NB_FW_MASK, "uvm_tlm_nb_transport_fw_export")
  `UVM_TLM_NB_TRANSPORT_FW_IMP(this.m_if, T, P, t, p, delay)
endclass

class uvm_tlm_nb_transport_bw_export #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e) extends uvm_port_base #(uvm_tlm_if #(T,P));
  `UVM_EXPORT_COMMON(`UVM_TLM_NB_BW_MASK, "uvm_tlm_nb_transport_bw_export")
  `UVM_TLM_NB_TRANSPORT_BW_IMP(this.m_if, T, P, t, p, delay)
endclass

class uvm_tlm_b_target_socket_base #(type T=uvm_tlm_generic_payload) extends uvm_port_base #(uvm_tlm_if #(T));
  function new (string name, uvm_component parent);
    super.new (name, parent, UVM_IMPLEMENTATION, 1, 1);
    m_if_mask = `UVM_TLM_B_MASK;
  endfunction

  `UVM_TLM_GET_TYPE_NAME("uvm_tlm_b_target_socket")

endclass

class uvm_tlm_b_initiator_socket_base #(type T=uvm_tlm_generic_payload) extends uvm_port_base #(uvm_tlm_if #(T));

  `UVM_PORT_COMMON(`UVM_TLM_B_MASK, "uvm_tlm_b_initiator_socket")
  `UVM_TLM_B_TRANSPORT_IMP(this.m_if, T, t, delay)

endclass

class uvm_tlm_nb_target_socket_base #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e) extends uvm_port_base #(uvm_tlm_if #(T,P));

  uvm_tlm_nb_transport_bw_port #(T,P) bw_port;

  function new (string name, uvm_component parent);
    super.new (name, parent, UVM_IMPLEMENTATION, 1, 1);
    m_if_mask = `UVM_TLM_NB_FW_MASK;
  endfunction

  `UVM_TLM_GET_TYPE_NAME("uvm_tlm_nb_target_socket")

  `UVM_TLM_NB_TRANSPORT_BW_IMP(bw_port, T, P, t, p, delay)

endclass

class uvm_tlm_nb_initiator_socket_base #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e) extends uvm_port_base #(uvm_tlm_if #(T,P));

  function new (string name, uvm_component parent);
    super.new (name, parent, UVM_PORT, 1, 1);
    m_if_mask = `UVM_TLM_NB_FW_MASK;
  endfunction

  `UVM_TLM_GET_TYPE_NAME("uvm_tlm_nb_initiator_socket")

  `UVM_TLM_NB_TRANSPORT_FW_IMP(this.m_if, T, P, t, p, delay)

endclass


class uvm_tlm_nb_passthrough_initiator_socket_base #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e) extends uvm_port_base #(uvm_tlm_if #(T,P));

  uvm_tlm_nb_transport_bw_export #(T,P) bw_export;

  function new (string name, uvm_component parent,
                int min_size=1, int max_size=1);
    super.new (name, parent, UVM_PORT, min_size, max_size);
    m_if_mask = `UVM_TLM_NB_FW_MASK;
    bw_export = new("bw_export", get_comp());
  endfunction

  `UVM_TLM_GET_TYPE_NAME("uvm_tlm_nb_passthrough_initiator_socket")

  `UVM_TLM_NB_TRANSPORT_FW_IMP(this.m_if, T, P, t, p, delay)
  `UVM_TLM_NB_TRANSPORT_BW_IMP(bw_export, T, P, t, p, delay)

endclass

class uvm_tlm_nb_passthrough_target_socket_base #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e) extends uvm_port_base #(uvm_tlm_if #(T,P));

  uvm_tlm_nb_transport_bw_port #(T,P) bw_port;

  function new (string name, uvm_component parent,
                int min_size=1, int max_size=1);
    super.new (name, parent, UVM_EXPORT, min_size, max_size);
    m_if_mask = `UVM_TLM_NB_FW_MASK;
    bw_port = new("bw_port", get_comp());
  endfunction

  `UVM_TLM_GET_TYPE_NAME("uvm_tlm_nb_passthrough_target_socket")

  `UVM_TLM_NB_TRANSPORT_FW_IMP(this.m_if, T, P, t, p, delay)
  `UVM_TLM_NB_TRANSPORT_BW_IMP(bw_port, T, P, t, p, delay)

endclass

class uvm_tlm_b_passthrough_initiator_socket_base #(type T=uvm_tlm_generic_payload) extends uvm_port_base #(uvm_tlm_if #(T));

  `UVM_PORT_COMMON(`UVM_TLM_B_MASK, "uvm_tlm_b_passthrough_initiator_socket")
  `UVM_TLM_B_TRANSPORT_IMP(this.m_if, T, t, delay)

endclass


class uvm_tlm_b_passthrough_target_socket_base #(type T=uvm_tlm_generic_payload) extends uvm_port_base #(uvm_tlm_if #(T));

  `UVM_EXPORT_COMMON(`UVM_TLM_B_MASK, "uvm_tlm_b_passthrough_target_socket")
  `UVM_TLM_B_TRANSPORT_IMP(this.m_if, T, t, delay)

endclass

class uvm_tlm_b_initiator_socket #(type T=uvm_tlm_generic_payload) extends uvm_tlm_b_initiator_socket_base #(T);

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction 
   
  virtual function void connect(this_type provider);

    uvm_tlm_b_passthrough_initiator_socket_base #(T) initiator_pt_socket;
    uvm_tlm_b_passthrough_target_socket_base #(T) target_pt_socket;
    uvm_tlm_b_target_socket_base #(T) target_socket;

    uvm_component c;

    super.connect(provider);

    if($cast(initiator_pt_socket, provider)  || $cast(target_pt_socket, provider)     || $cast(target_socket, provider))
      return;

    c = get_comp();
    `uvm_error_context(get_type_name(), "type mismatch in connect -- connection cannot be completed", c)

  endfunction

endclass

class uvm_tlm_b_target_socket #(type IMP=int, type T=uvm_tlm_generic_payload) extends uvm_tlm_b_target_socket_base #(T);

  local IMP m_imp;

  function new (string name, uvm_component parent, IMP imp = null);
    super.new (name, parent);
    if (imp == null) $cast(m_imp, parent);
    else m_imp = imp;
    if (m_imp == null)
       `uvm_error("UVM/TLM2/NOIMP", {"b_target socket ", name, " has no implementation"});
  endfunction

  virtual function void connect(this_type provider);

    uvm_component c;

    super.connect(provider);

    c = get_comp();
    `uvm_error_context(get_type_name(),
       "You cannot call connect() on a target termination socket", c)
  endfunction

  `UVM_TLM_B_TRANSPORT_IMP(m_imp, T, t, delay)

endclass

class uvm_tlm_nb_initiator_socket #(type IMP=int, type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e)
  extends uvm_tlm_nb_initiator_socket_base #(T,P);

  uvm_tlm_nb_transport_bw_imp #(T,P,IMP) bw_imp;

  function new(string name, uvm_component parent, IMP imp = null);
    super.new (name, parent);
    if (imp == null) $cast(imp, parent);
    if (imp == null)
       `uvm_error("UVM/TLM2/NOIMP", {"nb_initiator socket ", name, " has no implementation"});
    bw_imp = new("bw_imp", imp);
  endfunction

  virtual  function void connect(this_type provider);

    uvm_tlm_nb_passthrough_initiator_socket_base #(T,P) initiator_pt_socket;
    uvm_tlm_nb_passthrough_target_socket_base #(T,P) target_pt_socket;
    uvm_tlm_nb_target_socket_base #(T,P) target_socket;

    uvm_component c;

    super.connect(provider);

    if($cast(initiator_pt_socket, provider)) begin
      initiator_pt_socket.bw_export.connect(bw_imp);
      return;
    end
    if($cast(target_pt_socket, provider)) begin
      target_pt_socket.bw_port.connect(bw_imp);
      return;
    end

    if($cast(target_socket, provider)) begin
      target_socket.bw_port.connect(bw_imp);
      return;
    end
    
    c = get_comp();
    `uvm_error_context(get_type_name(),
        "type mismatch in connect -- connection cannot be completed", c)

  endfunction

endclass

class uvm_tlm_nb_target_socket #(type IMP=int, type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e)
  extends uvm_tlm_nb_target_socket_base #(T,P);

  local IMP m_imp;

  function new (string name, uvm_component parent, IMP imp = null);
    super.new (name, parent);
    if (imp == null) $cast(m_imp, parent);
    else m_imp = imp;
    bw_port = new("bw_port", get_comp());
    if (m_imp == null)
       `uvm_error("UVM/TLM2/NOIMP", {"nb_target socket ", name, " has no implementation"});
  endfunction

  function void connect(this_type provider);

    uvm_component c;

    super.connect(provider);

    c = get_comp();
    `uvm_error_context(get_type_name(),
       "You cannot call connect() on a target termination socket", c)
  endfunction

  `UVM_TLM_NB_TRANSPORT_FW_IMP(m_imp, T, P, t, p, delay)

endclass

class uvm_tlm_b_passthrough_initiator_socket #(type T=uvm_tlm_generic_payload)
  extends uvm_tlm_b_passthrough_initiator_socket_base #(T);

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  virtual function void connect(this_type provider);

    uvm_tlm_b_passthrough_initiator_socket_base #(T) initiator_pt_socket;
    uvm_tlm_b_passthrough_target_socket_base #(T) target_pt_socket;
    uvm_tlm_b_target_socket_base #(T) target_socket;

    uvm_component c;

    super.connect(provider);

    if($cast(initiator_pt_socket, provider) || $cast(target_pt_socket, provider)    || $cast(target_socket, provider))
      return;

    c = get_comp();
    `uvm_error_context(get_type_name(), "type mismatch in connect -- connection cannot be completed", c)

  endfunction

endclass

class uvm_tlm_b_passthrough_target_socket #(type T=uvm_tlm_generic_payload) extends uvm_tlm_b_passthrough_target_socket_base #(T);

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction 
   
  virtual function void connect(this_type provider);

    uvm_tlm_b_passthrough_target_socket_base #(T) target_pt_socket;
    uvm_tlm_b_target_socket_base #(T) target_socket;

    uvm_component c;

    super.connect(provider);

    if($cast(target_pt_socket, provider)    ||
       $cast(target_socket, provider))
      return;

    c = get_comp();
    `uvm_error_context(get_type_name(), "type mismatch in connect -- connection cannot be completed", c)
  endfunction

endclass

class uvm_tlm_nb_passthrough_initiator_socket #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e) extends uvm_tlm_nb_passthrough_initiator_socket_base #(T,P);

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  virtual function void connect(this_type provider);

    uvm_tlm_nb_passthrough_initiator_socket_base #(T,P) initiator_pt_socket;
    uvm_tlm_nb_passthrough_target_socket_base #(T,P) target_pt_socket;
    uvm_tlm_nb_target_socket_base #(T,P) target_socket;

    uvm_component c;

    super.connect(provider);

    if($cast(initiator_pt_socket, provider)) begin
      bw_export.connect(initiator_pt_socket.bw_export);
      return;
    end

    if($cast(target_pt_socket, provider)) begin
      target_pt_socket.bw_port.connect(bw_export);
      return;
    end

    if($cast(target_socket, provider)) begin
      target_socket.bw_port.connect(bw_export);
      return;
    end

    c = get_comp();
    `uvm_error_context(get_type_name(), "type mismatch in connect -- connection cannot be completed", c)

  endfunction

endclass


class uvm_tlm_nb_passthrough_target_socket #(type T=uvm_tlm_generic_payload, type P=uvm_tlm_phase_e) extends uvm_tlm_nb_passthrough_target_socket_base #(T,P);

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  virtual function void connect(this_type provider);

    uvm_tlm_nb_passthrough_target_socket_base #(T,P) target_pt_socket;
    uvm_tlm_nb_target_socket_base #(T,P) target_socket;

    uvm_component c;

    super.connect(provider);

    if($cast(target_pt_socket, provider)) begin
      target_pt_socket.bw_port.connect(bw_port);
      return;
    end

    if($cast(target_socket, provider)) begin
      target_socket.bw_port.connect(bw_port);
      return;
    end

    c = get_comp();
    `uvm_error_context(get_type_name(), "type mismatch in connect -- connection cannot be completed", c)

  endfunction

endclass

`ifndef UVM_REG_MODEL__SV
`define UVM_REG_MODEL__SV

typedef class uvm_reg_field;
typedef class uvm_vreg_field;
typedef class uvm_reg;
typedef class uvm_reg_file;
typedef class uvm_vreg;
typedef class uvm_reg_block;
typedef class uvm_mem;
typedef class uvm_reg_item;
typedef class uvm_reg_map;
typedef class uvm_reg_map_info;
typedef class uvm_reg_sequence;
typedef class uvm_reg_adapter;
typedef class uvm_reg_indirect_data;

typedef  bit unsigned [`UVM_REG_DATA_WIDTH-1:0]  uvm_reg_data_t ;
typedef  logic unsigned [`UVM_REG_DATA_WIDTH-1:0]  uvm_reg_data_logic_t ;
typedef  bit unsigned [`UVM_REG_ADDR_WIDTH-1:0]  uvm_reg_addr_t ;
typedef  logic unsigned [`UVM_REG_ADDR_WIDTH-1:0]  uvm_reg_addr_logic_t ;
typedef  bit unsigned [`UVM_REG_BYTENABLE_WIDTH-1:0]  uvm_reg_byte_en_t ;
typedef  bit [`UVM_REG_CVR_WIDTH-1:0]  uvm_reg_cvr_t ;

typedef struct {
   string path;
   int offset;
   int size;
} uvm_hdl_path_slice;

typedef uvm_resource_db#(uvm_reg_cvr_t) uvm_reg_cvr_rsrc_db;

typedef enum {
   UVM_IS_OK,
   UVM_NOT_OK,
   UVM_HAS_X
} uvm_status_e;

typedef enum {
   UVM_FRONTDOOR,
   UVM_BACKDOOR,
   UVM_PREDICT,
   UVM_DEFAULT_PATH
} uvm_path_e;

typedef enum {
   UVM_NO_CHECK,
   UVM_CHECK
} uvm_check_e;

typedef enum {
   UVM_NO_ENDIAN,
   UVM_LITTLE_ENDIAN,
   UVM_BIG_ENDIAN,
   UVM_LITTLE_FIFO,
   UVM_BIG_FIFO
} uvm_endianness_e;

typedef enum {
   UVM_REG,
   UVM_FIELD,
   UVM_MEM
} uvm_elem_kind_e;

typedef enum {
   UVM_READ,
   UVM_WRITE,
   UVM_BURST_READ,
   UVM_BURST_WRITE
} uvm_access_e;

typedef enum {
   UVM_NO_HIER,
   UVM_HIER
} uvm_hier_e;

typedef enum {
   UVM_PREDICT_DIRECT,
   UVM_PREDICT_READ,
   UVM_PREDICT_WRITE
} uvm_predict_e;

typedef enum uvm_reg_cvr_t {
   UVM_NO_COVERAGE      = 'h0000,
   UVM_CVR_REG_BITS     = 'h0001,
   UVM_CVR_ADDR_MAP     = 'h0002,
   UVM_CVR_FIELD_VALS   = 'h0004,
   UVM_CVR_ALL          = -1
} uvm_coverage_model_e;

typedef enum bit [63:0] {
  UVM_DO_REG_HW_RESET      = 64'h0000_0000_0000_0001,
  UVM_DO_REG_BIT_BASH      = 64'h0000_0000_0000_0002,
  UVM_DO_REG_ACCESS        = 64'h0000_0000_0000_0004,
  UVM_DO_MEM_ACCESS        = 64'h0000_0000_0000_0008,
  UVM_DO_SHARED_ACCESS     = 64'h0000_0000_0000_0010,
  UVM_DO_MEM_WALK          = 64'h0000_0000_0000_0020,
  UVM_DO_ALL_REG_MEM_TESTS = 64'hffff_ffff_ffff_ffff 
} uvm_reg_mem_tests_e;

class uvm_hdl_path_concat;

   uvm_hdl_path_slice slices[];

   function void set(uvm_hdl_path_slice t[]);
      slices = t;
   endfunction

   function void add_slice(uvm_hdl_path_slice slice);
      slices = new [slices.size()+1] (slices);
      slices[slices.size()-1] = slice;
   endfunction

   function void add_path(string path, int unsigned offset = -1, int unsigned size = -1);
      uvm_hdl_path_slice t;
      t.offset = offset;
      t.path   = path;
      t.size   = size;
      add_slice(t);
   endfunction
   
endclass

function automatic string uvm_hdl_concat2string(uvm_hdl_path_concat concat);
   string image = "{";
   
   if (concat.slices.size() == 1 && concat.slices[0].offset == -1 && concat.slices[0].size == -1)
      return concat.slices[0].path;

   foreach (concat.slices[i]) begin
      uvm_hdl_path_slice slice=concat.slices[i];

      image = { image, (i == 0) ? "" : ", ", slice.path };
      if (slice.offset >= 0)
         image = { image, "@", $sformatf("[%0d +: %0d]", slice.offset, slice.size) };
   end

   image = { image, "}" };

   return image;
endfunction

typedef struct packed {
  uvm_reg_addr_t min;
  uvm_reg_addr_t max;
  int unsigned stride;
  } uvm_reg_map_addr_range;

class uvm_reg_item extends uvm_sequence_item;

  `uvm_object_utils(uvm_reg_item)

  uvm_elem_kind_e element_kind;
  uvm_object element;
  rand uvm_access_e kind;
  rand uvm_reg_data_t value[];
  rand uvm_reg_addr_t offset;
  uvm_status_e status;
  uvm_reg_map local_map;
  uvm_reg_map map;
  uvm_path_e path;
  rand uvm_sequence_base parent;
  int prior = -1;
  rand uvm_object extension;
  string bd_kind;
  string fname;
  int lineno;

  constraint max_values { value.size() > 0 && value.size() < 1000; }

  function new(string name="");
    super.new(name);
    value = new[1];
  endfunction

  virtual function string convert2string();
    string s,value_s;
    s = {"kind=",kind.name(), " ele_kind=",element_kind.name(), " ele_name=",element==null?"null":element.get_full_name() };

    if (value.size() > 1 && uvm_report_enabled(UVM_HIGH, UVM_INFO, "RegModel")) begin
      value_s = "'{";
      foreach (value[i])
         value_s = {value_s,$sformatf("%0h,",value[i])};
      value_s[value_s.len()-1]="}";
    end
    else
      value_s = $sformatf("%0h",value[0]);
    s = {s, " value=",value_s};

    if (element_kind == UVM_MEM)
      s = {s, $sformatf(" offset=%0h",offset)};
    s = {s," map=",(map==null?"null":map.get_full_name())," path=",path.name()};
    s = {s," status=",status.name()};
    return s;
  endfunction

  virtual function void do_copy(uvm_object rhs);
    uvm_reg_item rhs_;
    if (rhs == null)
     `uvm_fatal("REG/NULL","do_copy: rhs argument is null") 

    if (!$cast(rhs_,rhs)) begin
      `uvm_error("WRONG_TYPE","Provided rhs is not of type uvm_reg_item")
      return;
    end
    super.copy(rhs);
    element_kind = rhs_.element_kind;
    element = rhs_.element;
    kind = rhs_.kind;
    value = rhs_.value;
    offset = rhs_.offset;
    status = rhs_.status;
    local_map = rhs_.local_map;
    map = rhs_.map;
    path = rhs_.path;
    extension = rhs_.extension;
    bd_kind = rhs_.bd_kind;
    parent = rhs_.parent;
    prior = rhs_.prior;
    fname = rhs_.fname;
    lineno = rhs_.lineno;
  endfunction

endclass

typedef struct {

  uvm_access_e kind;
  uvm_reg_addr_t addr;
  uvm_reg_data_t data;
  int n_bits;
  uvm_reg_byte_en_t byte_en;
  uvm_status_e status;
} uvm_reg_bus_op;

virtual class uvm_reg_adapter extends uvm_object;

  bit supports_byte_enable;
  bit provides_responses; 
  uvm_sequence_base parent_sequence; 
  local uvm_reg_item m_item;

  function new(string name="");
    super.new(name);
  endfunction
  
  pure virtual function uvm_sequence_item reg2bus(const ref uvm_reg_bus_op rw);
  pure virtual function void bus2reg(uvm_sequence_item bus_item, ref uvm_reg_bus_op rw);

  virtual function uvm_reg_item get_item();
    return m_item;
  endfunction
  
  virtual function void m_set_item(uvm_reg_item item);
    m_item = item;
  endfunction

endclass

class uvm_reg_tlm_adapter extends uvm_reg_adapter;

  `uvm_object_utils(uvm_reg_tlm_adapter)

  function new(string name = "uvm_reg_tlm_adapter");
    super.new(name);
  endfunction

  virtual function uvm_sequence_item reg2bus(const ref uvm_reg_bus_op rw);

     uvm_tlm_gp gp = uvm_tlm_gp::type_id::create("tlm_gp",, this.get_full_name());
     int nbytes = (rw.n_bits-1)/8+1;
     uvm_reg_addr_t addr=rw.addr;

     if (rw.kind == UVM_WRITE)
        gp.set_command(UVM_TLM_WRITE_COMMAND);
     else
        gp.set_command(UVM_TLM_READ_COMMAND);

     gp.set_address(addr);

     gp.m_byte_enable = new [nbytes];
     gp.m_byte_enable_length = nbytes;

     gp.set_streaming_width (nbytes);

     gp.m_data = new [gp.get_streaming_width()];
     gp.m_length = nbytes; 

     for (int i = 0; i < nbytes; i++) begin
        gp.m_data[i] = rw.data[i*8+:8];
        gp.m_byte_enable[i] = (i > nbytes) ? 8'h00 : (rw.byte_en[i] ? 8'hFF : 8'h00);
     end

     return gp;

  endfunction


  virtual function void bus2reg(uvm_sequence_item bus_item, ref uvm_reg_bus_op rw);

    uvm_tlm_gp gp;
    int nbytes;

    if (bus_item == null)
     `uvm_fatal("REG/NULL_ITEM","bus2reg: bus_item argument is null") 

    if (!$cast(gp,bus_item)) begin
      `uvm_error("WRONG_TYPE","Provided bus_item is not of type uvm_tlm_gp")
      return;
    end

    if (gp.get_command() == UVM_TLM_WRITE_COMMAND)
      rw.kind = UVM_WRITE;
    else
      rw.kind = UVM_READ;

    rw.addr = gp.get_address();

    rw.byte_en = 0;
    foreach (gp.m_byte_enable[i]) rw.byte_en[i] = gp.m_byte_enable[i];

    rw.data = 0;
    foreach (gp.m_data[i]) rw.data[i*8+:8] = gp.m_data[i];

    rw.status = (gp.is_response_ok()) ? UVM_IS_OK : UVM_NOT_OK;


  endfunction

endclass

class uvm_predict_s;
   bit addr[uvm_reg_addr_t];
   uvm_reg_item reg_item;
endclass

class uvm_reg_predictor #(type BUSTYPE=int) extends uvm_component;

  `uvm_component_param_utils(uvm_reg_predictor#(BUSTYPE))

  uvm_analysis_imp #(BUSTYPE, uvm_reg_predictor #(BUSTYPE)) bus_in;
  uvm_analysis_port #(uvm_reg_item) reg_ap;
  uvm_reg_map map;
  uvm_reg_adapter adapter;
  static string type_name = "";
  local uvm_predict_s m_pending[uvm_reg];

  function new (string name, uvm_component parent);
    super.new(name, parent);
    bus_in = new("bus_in", this);
    reg_ap = new("reg_ap", this);
  endfunction

  virtual function string get_type_name();
    if (type_name == "") begin
      BUSTYPE t;
      t = BUSTYPE::type_id::create("t");
      type_name = {"uvm_reg_predictor #(", t.get_type_name(), ")"};
    end
    return type_name;
  endfunction
  
  virtual function void pre_predict(uvm_reg_item rw);
  endfunction

  virtual function void write(BUSTYPE tr);
     uvm_reg rg;
     uvm_reg_bus_op rw;
    if (adapter == null)
     `uvm_fatal("REG/WRITE/NULL","write: adapter handle is null") 

     rw.byte_en = -1;
     adapter.bus2reg(tr,rw);
     rg = map.get_reg_by_offset(rw.addr, (rw.kind == UVM_READ));


     if (rg != null) begin
       bit found;
       uvm_reg_item reg_item;
       uvm_reg_map local_map;
       uvm_reg_map_info map_info;
       uvm_predict_s predict_info;
       uvm_reg_indirect_data ireg;
       uvm_reg ir;
 
       if (!m_pending.exists(rg)) begin
         uvm_reg_item item = new;
         predict_info =new;
         item.element_kind = UVM_REG;
         item.element      = rg;
         item.path         = UVM_PREDICT;
         item.map          = map;
         item.kind         = rw.kind;
         predict_info.reg_item = item;
         m_pending[rg] = predict_info;
       end
       predict_info = m_pending[rg];
       reg_item = predict_info.reg_item;

       if (predict_info.addr.exists(rw.addr)) begin
          `uvm_error("REG_PREDICT_COLLISION",{"Collision detected for register '", rg.get_full_name(),"'"})
          m_pending.delete(rg);
       end

       local_map = rg.get_local_map(map,"predictor::write()");
       map_info = local_map.get_reg_map_info(rg);
       ir=($cast(ireg, rg))?ireg.get_indirect_reg():rg;

       foreach (map_info.addr[i]) begin
         if (rw.addr == map_info.addr[i]) begin
            found = 1;
           reg_item.value[0] |= rw.data << (i * map.get_n_bytes()*8);
           predict_info.addr[rw.addr] = 1;
           if (predict_info.addr.num() == map_info.addr.size()) begin
              uvm_predict_e predict_kind = (reg_item.kind == UVM_WRITE) ? UVM_PREDICT_WRITE : UVM_PREDICT_READ;

              if (reg_item.kind == UVM_READ &&
                  local_map.get_check_on_read() &&
                  reg_item.status != UVM_NOT_OK) begin
                 void'(rg.do_check(ir.get_mirrored_value(), reg_item.value[0], local_map));
              end
              
              pre_predict(reg_item);

              ir.XsampleX(reg_item.value[0], rw.byte_en, reg_item.kind == UVM_READ, local_map);
              begin
                 uvm_reg_block blk = rg.get_parent();
                 blk.XsampleX(map_info.offset, reg_item.kind == UVM_READ, local_map);
              end

              rg.do_predict(reg_item, predict_kind, rw.byte_en);
              if(reg_item.kind == UVM_WRITE)
                `uvm_info("REG_PREDICT", {"Observed WRITE transaction to register ", ir.get_full_name(), ": value='h", $sformatf("%0h",reg_item.value[0]), " : updated value = 'h", $sformatf("%0h",ir.get())},UVM_HIGH)
              else
                `uvm_info("REG_PREDICT", {"Observed READ transaction to register ", ir.get_full_name(), ": value='h", $sformatf("%0h",reg_item.value[0])},UVM_HIGH)
              reg_ap.write(reg_item);
              m_pending.delete(rg);
           end
           break;
         end
       end
       if (!found)
         `uvm_error("REG_PREDICT_INTERNAL",{"Unexpected failed address lookup for register '", rg.get_full_name(),"'"})
     end
     else begin
       `uvm_info("REG_PREDICT_NOT_FOR_ME", {"Observed transaction does not target a register: ", $sformatf("%p",tr)},UVM_FULL)
     end
  endfunction

  virtual function void check_phase(uvm_phase phase);
	 string q[$];
     super.check_phase(phase);
            
     foreach (m_pending[l]) begin
	     uvm_reg rg=l;
         q.push_back($sformatf("\n%s",rg.get_full_name()));
     end
            
    if (m_pending.num() > 0) begin
      `uvm_error("PENDING REG ITEMS", $sformatf("There are %0d incomplete register transactions still pending completion:%s",m_pending.num(),`UVM_STRING_QUEUE_STREAMING_PACK(q)))

    end
  endfunction

endclass

class uvm_reg_sequence #(type BASE=uvm_sequence #(uvm_reg_item)) extends BASE;

  `uvm_object_param_utils(uvm_reg_sequence #(BASE))

  uvm_reg_block model;
  uvm_reg_adapter adapter;
  uvm_sequencer #(uvm_reg_item) reg_seqr;

  function new (string name="uvm_reg_sequence_inst");
    super.new(name);
  endfunction

  virtual task body();
    if (m_sequencer == null) begin
      `uvm_fatal("NO_SEQR", {"Sequence executing as translation sequence, ", "but is not associated with a sequencer (m_sequencer == null)"})
    end
    if (reg_seqr == null) begin
      `uvm_warning("REG_XLATE_NO_SEQR", {"Executing RegModel translation sequence on sequencer ", m_sequencer.get_full_name(),"' does not have an upstream sequencer defined. ", "Execution of register items available only via direct calls to 'do_reg_item'"})
      wait(0);
    end
    `uvm_info("REG_XLATE_SEQ_START", {"Starting RegModel translation sequence on sequencer ", m_sequencer.get_full_name(),"'"},UVM_LOW)
    forever begin
      uvm_reg_item reg_item;
      reg_seqr.peek(reg_item);
      do_reg_item(reg_item);
      reg_seqr.get(reg_item);
      #0;
    end
  endtask

  typedef enum { LOCAL, UPSTREAM } seq_parent_e;
  seq_parent_e parent_select = LOCAL;
  uvm_sequence_base upstream_parent;

  virtual task do_reg_item(uvm_reg_item rw);
     string rws=rw.convert2string();
    if (m_sequencer == null)
     `uvm_fatal("REG/DO_ITEM/NULL","do_reg_item: m_sequencer is null") 
    if (adapter == null)
     `uvm_fatal("REG/DO_ITEM/NULL","do_reg_item: adapter handle is null") 

    `uvm_info("DO_RW_ACCESS",{"Doing transaction: ",rws},UVM_HIGH)

    if (parent_select == LOCAL) begin
      upstream_parent = rw.parent;
      rw.parent = this;
    end

    if (rw.kind == UVM_WRITE)
      rw.local_map.do_bus_write(rw, m_sequencer, adapter);
    else
      rw.local_map.do_bus_read(rw, m_sequencer, adapter);
    
    if (parent_select == LOCAL)
       rw.parent = upstream_parent;
  endtask

   virtual task write_reg(input  uvm_reg           rg, output uvm_status_e      status, input  uvm_reg_data_t    value, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      if (rg == null)
        `uvm_error("NO_REG","Register argument is null")
      else
        rg.write(status,value,path,map,this,prior,extension,fname,lineno);
   endtask


   virtual task read_reg(input  uvm_reg           rg, output uvm_status_e      status, output uvm_reg_data_t    value, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      if (rg == null)
        `uvm_error("NO_REG","Register argument is null")
      else
        rg.read(status,value,path,map,this,prior,extension,fname,lineno);
   endtask

   virtual task poke_reg(input  uvm_reg           rg, output uvm_status_e      status, input  uvm_reg_data_t    value, input  string            kind = "", input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      if (rg == null)
        `uvm_error("NO_REG","Register argument is null")
      else
        rg.poke(status,value,kind,this,extension,fname,lineno);
   endtask

   virtual task peek_reg(input  uvm_reg           rg, output uvm_status_e      status, output uvm_reg_data_t    value, input  string            kind = "", input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      if (rg == null)
        `uvm_error("NO_REG","Register argument is null")
      else
        rg.peek(status,value,kind,this,extension,fname,lineno);
   endtask

   virtual task update_reg(input  uvm_reg           rg, output uvm_status_e      status, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      if (rg == null)
        `uvm_error("NO_REG","Register argument is null")
      else
        rg.update(status,path,map,this,prior,extension,fname,lineno);
   endtask

   virtual task mirror_reg(input  uvm_reg       rg, output uvm_status_e  status, input  uvm_check_e   check  = UVM_NO_CHECK, input  uvm_path_e    path = UVM_DEFAULT_PATH, input  uvm_reg_map   map = null, input  int           prior = -1, input  uvm_object    extension = null, input  string        fname = "", input  int           lineno = 0);
      if (rg == null)
        `uvm_error("NO_REG","Register argument is null")
      else
        rg.mirror(status,check,path,map,this,prior,extension,fname,lineno);
   endtask

   virtual task write_mem(input  uvm_mem           mem, output uvm_status_e      status, input  uvm_reg_addr_t    offset, input  uvm_reg_data_t    value, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      if (mem == null)
        `uvm_error("NO_MEM","Memory argument is null")
      else
        mem.write(status,offset,value,path,map,this,prior,extension,fname,lineno);
   endtask

   virtual task read_mem(input  uvm_mem           mem, output uvm_status_e      status, input  uvm_reg_addr_t    offset, output uvm_reg_data_t    value, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      if (mem == null)
        `uvm_error("NO_MEM","Memory argument is null")
      else
        mem.read(status,offset,value,path,map,this,prior,extension,fname,lineno);
   endtask

   virtual task poke_mem(input  uvm_mem           mem, output uvm_status_e      status, input  uvm_reg_addr_t    offset, input  uvm_reg_data_t    value, input  string            kind = "", input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      if (mem == null)
        `uvm_error("NO_MEM","Memory argument is null")
      else
        mem.poke(status,offset,value,kind,this,extension,fname,lineno);
   endtask

   virtual task peek_mem(input  uvm_mem           mem, output uvm_status_e      status, input  uvm_reg_addr_t    offset, output uvm_reg_data_t    value, input  string            kind = "", input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      if (mem == null)
        `uvm_error("NO_MEM","Memory argument is null")
      else
        mem.peek(status,offset,value,kind,this,extension,fname,lineno);
   endtask

   virtual function void put_response(uvm_sequence_item response_item);
    put_base_response(response_item);
  endfunction

endclass


virtual class uvm_reg_frontdoor extends uvm_reg_sequence #(uvm_sequence #(uvm_sequence_item));

   uvm_reg_item rw_info;
   uvm_sequencer_base sequencer;
   string fname;
   int lineno;
   function new(string name="");
      super.new(name);
   endfunction

endclass: uvm_reg_frontdoor

typedef class uvm_reg;
typedef class uvm_mem;
typedef class uvm_reg_backdoor;

virtual class uvm_reg_cbs extends uvm_callback;

   function new(string name = "uvm_reg_cbs");
      super.new(name);
   endfunction

   virtual task pre_write(uvm_reg_item rw); endtask
   virtual task post_write(uvm_reg_item rw); endtask
   virtual task pre_read(uvm_reg_item rw); endtask
   virtual task post_read(uvm_reg_item rw); endtask
   virtual function void post_predict(input uvm_reg_field  fld, input uvm_reg_data_t previous, inout uvm_reg_data_t value, input uvm_predict_e  kind, input uvm_path_e     path, input uvm_reg_map    map);
   endfunction
   virtual function void encode(ref uvm_reg_data_t data[]);
   endfunction
   virtual function void decode(ref uvm_reg_data_t data[]);
   endfunction

endclass


typedef uvm_callbacks#(uvm_reg, uvm_reg_cbs) uvm_reg_cb;
typedef uvm_callback_iter#(uvm_reg, uvm_reg_cbs) uvm_reg_cb_iter;
typedef uvm_callbacks#(uvm_reg_backdoor, uvm_reg_cbs) uvm_reg_bd_cb;
typedef uvm_callback_iter#(uvm_reg_backdoor, uvm_reg_cbs) uvm_reg_bd_cb_iter;
typedef uvm_callbacks#(uvm_mem, uvm_reg_cbs) uvm_mem_cb;
typedef uvm_callback_iter#(uvm_mem, uvm_reg_cbs) uvm_mem_cb_iter;
typedef uvm_callbacks#(uvm_reg_field, uvm_reg_cbs) uvm_reg_field_cb;
typedef uvm_callback_iter#(uvm_reg_field, uvm_reg_cbs) uvm_reg_field_cb_iter;


class uvm_reg_read_only_cbs extends uvm_reg_cbs;

   local static uvm_reg_read_only_cbs m_me;

   function new(string name = "uvm_reg_read_only_cbs");
      super.new(name);
   endfunction

   `uvm_object_utils(uvm_reg_read_only_cbs)
   
   virtual task pre_write(uvm_reg_item rw);
      string name = rw.element.get_full_name();
      
      if (rw.status != UVM_IS_OK)
         return;

      if (rw.element_kind == UVM_FIELD) begin
         uvm_reg_field fld;
         uvm_reg rg;
         $cast(fld, rw.element);
         rg = fld.get_parent();
         name = rg.get_full_name();
      end
      
      `uvm_error("UVM/REG/READONLY", {name, " is read-only. Cannot call write() method."});

      rw.status = UVM_NOT_OK;
   endtask

   local static function uvm_reg_read_only_cbs get();
      if (m_me == null) m_me = new;
      return m_me;
   endfunction

   static function void add(uvm_reg rg);
      uvm_reg_field flds[$];
      
      uvm_reg_cb::add(rg, get());
      rg.get_fields(flds);
      foreach (flds[i]) begin
         uvm_reg_field_cb::add(flds[i], get());
      end
   endfunction

   static function void remove(uvm_reg rg);
      uvm_reg_cb_iter cbs = new(rg);
      uvm_reg_field flds[$];

      void'(cbs.first());
      while (cbs.get_cb() != get()) begin
         if (cbs.get_cb() == null)
            return;
         void'(cbs.next());
      end
      uvm_reg_cb::delete(rg, get());
      rg.get_fields(flds);
      foreach (flds[i]) begin
         uvm_reg_field_cb::delete(flds[i], get());
      end
   endfunction

endclass

class uvm_reg_write_only_cbs extends uvm_reg_cbs;

   function new(string name = "uvm_reg_write_only_cbs");
      super.new(name);
   endfunction

   `uvm_object_utils(uvm_reg_write_only_cbs)
   
   virtual task pre_read(uvm_reg_item rw);
      string name = rw.element.get_full_name();
      
      if (rw.status != UVM_IS_OK)
         return;

      if (rw.element_kind == UVM_FIELD) begin
         uvm_reg_field fld;
         uvm_reg rg;
         $cast(fld, rw.element);
         rg = fld.get_parent();
         name = rg.get_full_name();
      end
      
      `uvm_error("UVM/REG/WRTEONLY", {name, " is write-only. Cannot call read() method."});

      rw.status = UVM_NOT_OK;
   endtask

   local static uvm_reg_write_only_cbs m_me;
   local static function uvm_reg_write_only_cbs get();
      if (m_me == null) m_me = new;
      return m_me;
   endfunction

   static function void add(uvm_reg rg);
      uvm_reg_field flds[$];
      
      uvm_reg_cb::add(rg, get());
      rg.get_fields(flds);
      foreach (flds[i]) begin
         uvm_reg_field_cb::add(flds[i], get());
      end
   endfunction

   static function void remove(uvm_reg rg);
      uvm_reg_cb_iter cbs = new(rg);
      uvm_reg_field flds[$];

      void'(cbs.first());
      while (cbs.get_cb() != get()) begin
         if (cbs.get_cb() == null)
            return;
         void'(cbs.next());
      end
      uvm_reg_cb::delete(rg, get());
      rg.get_fields(flds);
      foreach (flds[i]) begin
         uvm_reg_field_cb::delete(flds[i], get());
      end
   endfunction

endclass

typedef class uvm_reg_cbs;

class uvm_reg_backdoor extends uvm_object;

   function new(string name = "");
      super.new(name);
   endfunction: new
   
   protected task do_pre_read(uvm_reg_item rw);
      pre_read(rw);
      `uvm_do_obj_callbacks(uvm_reg_backdoor, uvm_reg_cbs, this, pre_read(rw))
   endtask

   protected task do_post_read(uvm_reg_item rw);
      uvm_callback_iter#(uvm_reg_backdoor, uvm_reg_cbs) iter = new(this);
      for(uvm_reg_cbs cb = iter.last(); cb != null; cb=iter.prev())
         cb.decode(rw.value);
      `uvm_do_obj_callbacks(uvm_reg_backdoor,uvm_reg_cbs,this,post_read(rw))
      post_read(rw);
   endtask

   protected task do_pre_write(uvm_reg_item rw);
      uvm_callback_iter#(uvm_reg_backdoor, uvm_reg_cbs) iter = new(this);
      pre_write(rw);
      `uvm_do_obj_callbacks(uvm_reg_backdoor,uvm_reg_cbs,this,pre_write(rw))
      for(uvm_reg_cbs cb = iter.first(); cb != null; cb = iter.next())
         cb.encode(rw.value);
   endtask

   protected task do_post_write(uvm_reg_item rw);
      `uvm_do_obj_callbacks(uvm_reg_backdoor,uvm_reg_cbs,this,post_write(rw))
      post_write(rw);
   endtask

   virtual task pre_read(uvm_reg_item rw); endtask
   virtual task post_read(uvm_reg_item rw); endtask
   virtual task pre_write(uvm_reg_item rw); endtask
   virtual task post_write(uvm_reg_item rw); endtask

   string fname;
   int lineno;

`ifdef UVM_USE_PROCESS_CONTAINER
   local process_container_c m_update_thread[uvm_object];
`else
   local process m_update_thread[uvm_object];
`endif 

   `uvm_object_utils(uvm_reg_backdoor)
   `uvm_register_cb(uvm_reg_backdoor, uvm_reg_cbs)

   function bit is_auto_updated(uvm_reg_field field);
      return 0;
   endfunction
   
   task wait_for_change(uvm_object element);
      `uvm_fatal("RegModel", "wait_for_change() method has not been overloaded");
   endtask
   
   function void start_update_thread(uvm_object element);
      uvm_reg rg;
      if (this.m_update_thread.exists(element)) begin
         this.kill_update_thread(element);
      end
      if (!$cast(rg,element))
        return; 
   
      fork
         begin
            uvm_reg_field fields[$];
   
   `ifdef UVM_USE_PROCESS_CONTAINER         
            this.m_update_thread[element] = new(process::self());
   `else
            this.m_update_thread[element] = process::self();
   `endif
         
            rg.get_fields(fields);
            forever begin
               uvm_status_e status;
               uvm_reg_data_t  val;
               uvm_reg_item r_item = new("bd_r_item");
               r_item.element = rg;
               r_item.element_kind = UVM_REG;
               this.read(r_item);
               val = r_item.value[0];
               if (r_item.status != UVM_IS_OK) begin
                  `uvm_error("RegModel", $sformatf("Backdoor read of register '%s' failed.", rg.get_name()));
               end
               foreach (fields[i]) begin
                  if (this.is_auto_updated(fields[i])) begin
                     r_item.value[0] = (val >> fields[i].get_lsb_pos()) & ((1 << fields[i].get_n_bits())-1);
                     fields[i].do_predict(r_item);
                   end
               end
               this.wait_for_change(element);
            end
         end
      join_none
   endfunction
   
   function void kill_update_thread(uvm_object element);
      if (this.m_update_thread.exists(element)) begin
   
   `ifdef UVM_USE_PROCESS_CONTAINER
         this.m_update_thread[element].p.kill();
   `else 
         this.m_update_thread[element].kill();
   `endif
   
         this.m_update_thread.delete(element);
      end
   endfunction
   
   function bit has_update_threads();
      return this.m_update_thread.num() > 0;
   endfunction
   
   task write(uvm_reg_item rw);
      `uvm_fatal("RegModel", "write() method has not been overloaded");
   endtask
   
   task read(uvm_reg_item rw);
      do_pre_read(rw);
      read_func(rw);
      do_post_read(rw);
   endtask
   
   function void read_func(uvm_reg_item rw);
      `uvm_fatal("RegModel", "read_func() method has not been overloaded");
      rw.status = UVM_NOT_OK;
   endfunction

endclass: uvm_reg_backdoor

typedef class uvm_reg_cbs;
typedef class uvm_reg_map_info;

class uvm_reg_field extends uvm_object;

   rand  uvm_reg_data_t  value; 
   local uvm_reg_data_t  m_mirrored; 
   local uvm_reg_data_t  m_desired;  
   local string          m_access;
   local uvm_reg         m_parent;
   local int unsigned    m_lsb;
   local int unsigned    m_size;
   local bit             m_volatile;
   local uvm_reg_data_t  m_reset[string];
   local bit             m_written;
   local bit             m_read_in_progress;
   local bit             m_write_in_progress;
   local string          m_fname;
   local int             m_lineno;
   local int             m_cover_on;
   local bit             m_individually_accessible;
   local uvm_check_e     m_check;
   
   local static int m_max_size;
   local static bit m_policy_names[string];
   
   constraint uvm_reg_field_valid {
      if (`UVM_REG_DATA_WIDTH > m_size) {
         value < (`UVM_REG_DATA_WIDTH'h1 << m_size);
      }
   }
   
   `uvm_object_utils(uvm_reg_field)
   
   local static bit m_predefined = m_predefine_policies();
   
   `uvm_register_cb(uvm_reg_field, uvm_reg_cbs)
   
   
   virtual task pre_write  (uvm_reg_item rw); endtask
   virtual task post_write (uvm_reg_item rw); endtask
   virtual task pre_read (uvm_reg_item rw); endtask
   virtual task post_read  (uvm_reg_item rw); endtask
   
   function new(string name = "uvm_reg_field");
      super.new(name);
   endfunction: new
   
   function void configure(uvm_reg        parent, int unsigned   size, int unsigned   lsb_pos, string         access, bit            volatile, uvm_reg_data_t reset, bit            has_reset, bit            is_rand, bit            individually_accessible); 
      m_parent = parent;
      if (size == 0) begin
         `uvm_error("RegModel", $sformatf("Field \"%s\" cannot have 0 bits", get_full_name()));
         size = 1;
      end
   
      m_size      = size;
      m_volatile  = volatile;
      m_access    = access.toupper();
      m_lsb       = lsb_pos;
      m_cover_on  = UVM_NO_COVERAGE;
      m_written   = 0;
      m_check     = volatile ? UVM_NO_CHECK : UVM_CHECK;
      m_individually_accessible = individually_accessible;
   
      if (has_reset)
         set_reset(reset);
      else
         uvm_resource_db#(bit)::set({"REG::", get_full_name()}, "NO_REG_HW_RESET_TEST", 1);
   
      m_parent.add_field(this);
   
      if (!m_policy_names.exists(m_access)) begin
         `uvm_error("RegModel", {"Access policy '",access, "' for field '",get_full_name(),"' is not defined. Setting to RW"})
         m_access = "RW";
      end
   
      if (size > m_max_size)
         m_max_size = size;
      
      case (access)
       "RO", "RC", "RS", "WC", "WS",
         "W1C", "W1S", "W1T", "W0C", "W0S", "W0T",
         "W1SRC", "W1CRS", "W0SRC", "W0CRS", "WSRC", "WCRS",
         "WOC", "WOS": is_rand = 0;
      endcase
   
      if (!is_rand)
        value.rand_mode(0);
   
   endfunction: configure
   
   function uvm_reg get_parent();
      return m_parent;
   endfunction: get_parent
   
   virtual function string get_full_name();
      return {m_parent.get_full_name(), ".", get_name()};
   endfunction: get_full_name
   
   function uvm_reg get_register();
      return m_parent;
   endfunction: get_register
   
   function int unsigned get_lsb_pos();
      return m_lsb;
   endfunction: get_lsb_pos
   
   function int unsigned get_n_bits();
      return m_size;
   endfunction: get_n_bits
   
   static function int unsigned get_max_size();
      return m_max_size;
   endfunction: get_max_size
   
   function bit is_known_access(uvm_reg_map map = null);
      string acc = get_access(map);
      case (acc)
       "RO", "RW", "RC", "RS", "WC", "WS",
         "W1C", "W1S", "W1T", "W0C", "W0S", "W0T",
         "WRC", "WRS", "W1SRC", "W1CRS", "W0SRC", "W0CRS", "WSRC", "WCRS",
         "WO", "WOC", "WOS", "W1", "WO1" : return 1;
      endcase
      return 0;
   endfunction
   
   function string get_access(uvm_reg_map map = null);
      string field_access = m_access;
   
      if (map == uvm_reg_map::backdoor())
        return field_access;
   
      case (m_parent.get_rights(map))
        "RW":
          return field_access;
   
        "RO":
          case (field_access)
           "RW", "RO", "WC", "WS",
             "W1C", "W1S", "W1T", "W0C", "W0S", "W0T",
             "W1"
           : field_access = "RO";
           
           "RC", "WRC", "W1SRC", "W0SRC", "WSRC"
           : field_access = "RC";
           
           "RS", "WRS", "W1CRS", "W0CRS", "WCRS"
           : field_access = "RS";
           
            "WO", "WOC", "WOS", "WO1": begin
               field_access = "NOACCESS";
            end
   
          endcase
   
        "WO":
          case (field_access)
            "RW",
            "WO": field_access = "WO";
            default: begin
               field_access = "NOACCESS";
            end
   
          endcase
   
        default:
          begin
            field_access = "NOACCESS";
            `uvm_warning("RegModel", {"Register '",m_parent.get_full_name(), "' containing field '",get_name(),"' is mapped in map '", map.get_full_name(),"' with unknown access right '", m_parent.get_rights(map), "'"})
          end
      endcase
      return field_access;
   endfunction: get_access
   
   function string set_access(string mode);
      set_access = m_access;
      m_access = mode.toupper();
      if (!m_policy_names.exists(m_access)) begin
         `uvm_error("RegModel", {"Access policy '",m_access, "' is not a defined field access policy"})
         m_access = set_access;
      end
   endfunction: set_access
   
   static function bit define_access(string name);
      if (!m_predefined) m_predefined = m_predefine_policies();
   
      name = name.toupper();
   
      if (m_policy_names.exists(name)) return 0;
   
      m_policy_names[name] = 1;
      return 1;
   endfunction
   
   local static function bit m_predefine_policies();
      if (m_predefined) return 1;
   
      m_predefined = 1;
      
      void'(define_access("RO"));
      void'(define_access("RW"));
      void'(define_access("RC"));
      void'(define_access("RS"));
      void'(define_access("WRC"));
      void'(define_access("WRS"));
      void'(define_access("WC"));
      void'(define_access("WS"));
      void'(define_access("WSRC"));
      void'(define_access("WCRS"));
      void'(define_access("W1C"));
      void'(define_access("W1S"));
      void'(define_access("W1T"));
      void'(define_access("W0C"));
      void'(define_access("W0S"));
      void'(define_access("W0T"));
      void'(define_access("W1SRC"));
      void'(define_access("W1CRS"));
      void'(define_access("W0SRC"));
      void'(define_access("W0CRS"));
      void'(define_access("WO"));
      void'(define_access("WOC"));
      void'(define_access("WOS"));
      void'(define_access("W1"));
      void'(define_access("WO1"));
      return 1;
   endfunction
   
   function void set_volatility(bit volatile);
      m_volatile = volatile;
   endfunction
   
   function bit is_volatile();
      return m_volatile;
   endfunction
   
   function uvm_reg_data_t XpredictX (uvm_reg_data_t cur_val, uvm_reg_data_t wr_val, uvm_reg_map    map);
      uvm_reg_data_t mask = ('b1 << m_size)-1;
      
      case (get_access(map))
        "RO":    return cur_val;
        "RW":    return wr_val;
        "RC":    return cur_val;
        "RS":    return cur_val;
        "WC":    return '0;
        "WS":    return mask;
        "WRC":   return wr_val;
        "WRS":   return wr_val;
        "WSRC":  return mask;
        "WCRS":  return '0;
        "W1C":   return cur_val & (~wr_val);
        "W1S":   return cur_val | wr_val;
        "W1T":   return cur_val ^ wr_val;
        "W0C":   return cur_val & wr_val;
        "W0S":   return cur_val | (~wr_val & mask);
        "W0T":   return cur_val ^ (~wr_val & mask);
        "W1SRC": return cur_val | wr_val;
        "W1CRS": return cur_val & (~wr_val);
        "W0SRC": return cur_val | (~wr_val & mask);
        "W0CRS": return cur_val & wr_val;
        "WO":    return wr_val;
        "WOC":   return '0;
        "WOS":   return mask;
        "W1":    return (m_written) ? cur_val : wr_val;
        "WO1":   return (m_written) ? cur_val : wr_val;
        "NOACCESS": return cur_val;
        default: return wr_val;
      endcase
   
      `uvm_fatal("RegModel", "XpredictX(): Internal error");
      return 0;
   endfunction: XpredictX
   
   function bit predict (uvm_reg_data_t    value, uvm_reg_byte_en_t be = -1, uvm_predict_e     kind = UVM_PREDICT_DIRECT, uvm_path_e        path = UVM_FRONTDOOR, uvm_reg_map       map = null, string            fname = "", int               lineno = 0);
     uvm_reg_item rw = new;
     rw.value[0] = value;
     rw.path = path;
     rw.map = map;
     rw.fname = fname;
     rw.lineno = lineno;
     do_predict(rw, kind, be);
     predict = (rw.status == UVM_NOT_OK) ? 0 : 1;
   endfunction: predict
   
   function void do_predict(uvm_reg_item      rw, uvm_predict_e     kind = UVM_PREDICT_DIRECT, uvm_reg_byte_en_t be = -1);
      
      uvm_reg_data_t field_val = rw.value[0] & ((1 << m_size)-1);
   
      if (rw.status != UVM_NOT_OK)
        rw.status = UVM_IS_OK;
   
      if (!be[0])
        return;
   
      m_fname = rw.fname;
      m_lineno = rw.lineno;
   
      case (kind)
   
        UVM_PREDICT_WRITE:
          begin
            uvm_reg_field_cb_iter cbs = new(this);
   
            if (rw.path == UVM_FRONTDOOR || rw.path == UVM_PREDICT)
               field_val = XpredictX(m_mirrored, field_val, rw.map);
   
            m_written = 1;
   
            for (uvm_reg_cbs cb = cbs.first(); cb != null; cb = cbs.next())
               cb.post_predict(this, m_mirrored, field_val, UVM_PREDICT_WRITE, rw.path, rw.map);
   
            field_val &= ('b1 << m_size)-1;
   
          end
   
        UVM_PREDICT_READ:
          begin
            uvm_reg_field_cb_iter cbs = new(this);
   
            if (rw.path == UVM_FRONTDOOR || rw.path == UVM_PREDICT) begin
   
               string acc = get_access(rw.map);
   
               if (acc == "RC" || acc == "WRC" || acc == "WSRC" || acc == "W1SRC" || acc == "W0SRC")
                 field_val = 0;  
   
               else if (acc == "RS" || acc == "WRS" || acc == "WCRS" || acc == "W1CRS" || acc == "W0CRS")
                 field_val = ('b1 << m_size)-1; 
   
               else if (acc == "WO" || acc == "WOC" || acc == "WOS" || acc == "WO1" || acc == "NOACCESS")
                 return;
            end
   
            for (uvm_reg_cbs cb = cbs.first(); cb != null; cb = cbs.next())
               cb.post_predict(this, m_mirrored, field_val, UVM_PREDICT_READ, rw.path, rw.map);
   
            field_val &= ('b1 << m_size)-1;
   
          end
   
        UVM_PREDICT_DIRECT:
          begin
            if (m_parent.is_busy()) begin
              `uvm_warning("RegModel", {"Trying to predict value of field '", get_name(),"' while register '",m_parent.get_full_name(), "' is being accessed"})
              rw.status = UVM_NOT_OK;
            end
          end
      endcase
   
      m_mirrored = field_val;
      m_desired  = field_val;
      this.value = field_val;
   
   endfunction: do_predict
   
   function uvm_reg_data_t  XupdateX();
      XupdateX = 0;
   
      case (m_access)
         "RO":    XupdateX = m_desired;
         "RW":    XupdateX = m_desired;
         "RC":    XupdateX = m_desired;
         "RS":    XupdateX = m_desired;
         "WRC":   XupdateX = m_desired;
         "WRS":   XupdateX = m_desired;
         "WC":    XupdateX = m_desired;  
         "WS":    XupdateX = m_desired;  
         "WSRC":  XupdateX = m_desired;  
         "WCRS":  XupdateX = m_desired;  
         "W1C":   XupdateX = ~m_desired;
         "W1S":   XupdateX = m_desired;
         "W1T":   XupdateX = m_desired ^ m_mirrored;
         "W0C":   XupdateX = m_desired;
         "W0S":   XupdateX = ~m_desired;
         "W0T":   XupdateX = ~(m_desired ^ m_mirrored);
         "W1SRC": XupdateX = m_desired;
         "W1CRS": XupdateX = ~m_desired;
         "W0SRC": XupdateX = ~m_desired;
         "W0CRS": XupdateX = m_desired;
         "WO":    XupdateX = m_desired;
         "WOC":   XupdateX = m_desired;  
         "WOS":   XupdateX = m_desired;  
         "W1":    XupdateX = m_desired;
         "WO1":   XupdateX = m_desired;
         default: XupdateX = m_desired;      
      endcase
      XupdateX &= (1 << m_size) - 1;
      
   endfunction: XupdateX
   
   
   
   function void set(uvm_reg_data_t  value, string          fname = "", int             lineno = 0);
      uvm_reg_data_t mask = ('b1 << m_size)-1;
   
      m_fname = fname;
      m_lineno = lineno;
      if (value >> m_size) begin
         `uvm_warning("RegModel", $sformatf("Specified value (0x%h) greater than field \"%s\" size (%0d bits)", value, get_name(), m_size));
         value &= mask;
      end
   
      if (m_parent.is_busy()) begin
         `uvm_warning("UVM/FLD/SET/BSY", $sformatf("Setting the value of field \"%s\" while containing register \"%s\" is being accessed may result in loss of desired field value. A race condition between threads concurrently accessing the register model is the likely cause of the problem.", get_name(), m_parent.get_full_name()))
      end
   
      case (m_access)
         "RO":    m_desired = m_desired;
         "RW":    m_desired = value;
         "RC":    m_desired = m_desired;
         "RS":    m_desired = m_desired;
         "WC":    m_desired = '0;
         "WS":    m_desired = mask;
         "WRC":   m_desired = value;
         "WRS":   m_desired = value;
         "WSRC":  m_desired = mask;
         "WCRS":  m_desired = '0;
         "W1C":   m_desired = m_desired & (~value);
         "W1S":   m_desired = m_desired | value;
         "W1T":   m_desired = m_desired ^ value;
         "W0C":   m_desired = m_desired & value;
         "W0S":   m_desired = m_desired | (~value & mask);
         "W0T":   m_desired = m_desired ^ (~value & mask);
         "W1SRC": m_desired = m_desired | value;
         "W1CRS": m_desired = m_desired & (~value);
         "W0SRC": m_desired = m_desired | (~value & mask);
         "W0CRS": m_desired = m_desired & value;
         "WO":    m_desired = value;
         "WOC":   m_desired = '0;
         "WOS":   m_desired = mask;
         "W1":    m_desired = (m_written) ? m_desired : value;
         "WO1":   m_desired = (m_written) ? m_desired : value;
         default: m_desired = value;
      endcase
      this.value = m_desired;
   endfunction: set
   
   function uvm_reg_data_t  get(string  fname = "", int     lineno = 0);
      m_fname = fname;
      m_lineno = lineno;
      get = m_desired;
   endfunction: get
   
   
   function uvm_reg_data_t  get_mirrored_value(string  fname = "", int     lineno = 0);
      m_fname = fname;
      m_lineno = lineno;
      get_mirrored_value = m_mirrored;
   endfunction: get_mirrored_value
   
   
   function void reset(string kind = "HARD");
   
      if (!m_reset.exists(kind))
         return;
      
      m_mirrored = m_reset[kind];
      m_desired  = m_mirrored;
      value      = m_mirrored;
   
      if (kind == "HARD")
         m_written  = 0;
   
   endfunction: reset
   
   function bit has_reset(string kind = "HARD", bit    delete = 0);
   
      if (!m_reset.exists(kind)) return 0;
   
      if (delete) m_reset.delete(kind);
   
      return 1;
   endfunction: has_reset
   
   function uvm_reg_data_t get_reset(string kind = "HARD");
   
      if (!m_reset.exists(kind))
         return m_desired;
   
      return m_reset[kind];
   
   endfunction: get_reset
   
   function void set_reset(uvm_reg_data_t value, string kind = "HARD");
      m_reset[kind] = value & ((1<<m_size) - 1);
   endfunction: set_reset
   
   function bit needs_update();
      needs_update = (m_mirrored != m_desired) | m_volatile;
   endfunction: needs_update
   
   function bit Xcheck_accessX(input uvm_reg_item rw, output uvm_reg_map_info map_info, input string caller);
   
                           
      if (rw.path == UVM_DEFAULT_PATH) begin
        uvm_reg_block blk = m_parent.get_block();
        rw.path = blk.get_default_path();
      end
   
      if (rw.path == UVM_BACKDOOR) begin
         if (m_parent.get_backdoor() == null && !m_parent.has_hdl_path()) begin
            `uvm_warning("RegModel", {"No backdoor access available for field '",get_full_name(), "' . Using frontdoor instead."})
            rw.path = UVM_FRONTDOOR;
         end
         else
           rw.map = uvm_reg_map::backdoor();
      end
   
      if (rw.path != UVM_BACKDOOR) begin
   
        rw.local_map = m_parent.get_local_map(rw.map,caller);
   
        if (rw.local_map == null) begin
           `uvm_error(get_type_name(), {"No transactor available to physically access memory from map '", rw.map.get_full_name(),"'"})
           rw.status = UVM_NOT_OK;
           return 0;
        end
   
        map_info = rw.local_map.get_reg_map_info(m_parent);
   
        if (map_info.frontdoor == null && map_info.unmapped) begin
           `uvm_error("RegModel", {"Field '",get_full_name(), "' in register that is unmapped in map '", rw.map.get_full_name(), "' and does not have a user-defined frontdoor"})
           rw.status = UVM_NOT_OK;
           return 0;
        end
   
        if (rw.map == null)
          rw.map = rw.local_map;
      end
   
      return 1;
   endfunction
   
   task write(output uvm_status_e       status, input  uvm_reg_data_t     value, input  uvm_path_e         path = UVM_DEFAULT_PATH, input  uvm_reg_map        map = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
   
      uvm_reg_item rw;
      rw = uvm_reg_item::type_id::create("field_write_item",,get_full_name());
      rw.element      = this;
      rw.element_kind = UVM_FIELD;
      rw.kind         = UVM_WRITE;
      rw.value[0]     = value;
      rw.path         = path;
      rw.map          = map;
      rw.parent       = parent;
      rw.prior        = prior;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      do_write(rw);
   
      status = rw.status;
   
   endtask
   
   task do_write(uvm_reg_item rw);
   
      uvm_reg_data_t   value_adjust;
      uvm_reg_map_info map_info;
      uvm_reg_field    fields[$];
      bit bad_side_effect;
   
      m_parent.XatomicX(1);
      m_fname  = rw.fname;
      m_lineno = rw.lineno;
   
      if (!Xcheck_accessX(rw,map_info,"write()"))
        return;
   
      m_write_in_progress = 1'b1;
   
      if (rw.value[0] >> m_size) begin
         `uvm_warning("RegModel", {"write(): Value greater than field '",
                             get_full_name(),"'"})
         rw.value[0] &= ((1<<m_size)-1);
      end
   
      m_parent.get_fields(fields);
      foreach (fields[i]) begin
   
         if (fields[i] == this) begin
            value_adjust |= rw.value[0] << m_lsb;
            continue;
         end
   
         case (fields[i].get_access(rw.local_map))
           "RO", "RC", "RS", "W1C", "W1S", "W1T", "W1SRC", "W1CRC": value_adjust |= 0;
   
           "W0C", "W0S", "W0T", "W0SRC", "W0CRS":
             value_adjust |= ((1<<fields[i].get_n_bits())-1) << fields[i].get_lsb_pos();
   
           "WC", "WS", "WCRS", "WSRC", "WOC", "WOS": bad_side_effect = 1;
   
           default:
              value_adjust |= fields[i].m_mirrored << fields[i].get_lsb_pos();
   
         endcase
      end
   
   `ifdef UVM_REG_NO_INDIVIDUAL_FIELD_ACCESS
      rw.element_kind = UVM_REG;
      rw.element = m_parent;
      rw.value[0] = value_adjust;
      m_parent.do_write(rw);   
   `else        
   
      if (!is_indv_accessible(rw.path,rw.local_map)) begin
         rw.element_kind = UVM_REG;
         rw.element = m_parent;
         rw.value[0] = value_adjust;
         m_parent.do_write(rw);
   
         if (bad_side_effect) begin
            `uvm_warning("RegModel", $sformatf("Writing field \"%s\" will cause unintended side effects in adjoining Write-to-Clear or Write-to-Set fields in the same register", this.get_full_name()));
         end
      end
      else begin
   
        uvm_reg_map system_map = rw.local_map.get_root_map();
        uvm_reg_field_cb_iter cbs = new(this);
   
        m_parent.Xset_busyX(1);
   
        rw.status = UVM_IS_OK;
         
        pre_write(rw);
        for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
           cb.pre_write(rw);
   
        if (rw.status != UVM_IS_OK) begin
           m_write_in_progress = 1'b0;
           m_parent.Xset_busyX(0);
           m_parent.XatomicX(0);
           
           return;
        end
               
        rw.local_map.do_write(rw);
   
        if (system_map.get_auto_predict())
           do_predict(rw, UVM_PREDICT_WRITE);
   
        post_write(rw);
        for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
           cb.post_write(rw);
   
        m_parent.Xset_busyX(0);
         
      end
   
   `endif
   
      m_write_in_progress = 1'b0;
      m_parent.XatomicX(0);
   
   endtask: do_write
   
   task read(output uvm_status_e       status, output uvm_reg_data_t     value, input  uvm_path_e         path = UVM_DEFAULT_PATH, input  uvm_reg_map        map = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
   
      uvm_reg_item rw;
      rw = uvm_reg_item::type_id::create("field_read_item",,get_full_name());
      rw.element      = this;
      rw.element_kind = UVM_FIELD;
      rw.kind         = UVM_READ;
      rw.value[0]     = 0;
      rw.path         = path;
      rw.map          = map;
      rw.parent       = parent;
      rw.prior        = prior;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      do_read(rw);
   
      value = rw.value[0];
      status = rw.status;
   
   endtask: read
   
   task do_read(uvm_reg_item rw);
   
      uvm_reg_map_info map_info;
      bit bad_side_effect;
   
      m_parent.XatomicX(1);
      m_fname  = rw.fname;
      m_lineno = rw.lineno;
      m_read_in_progress = 1'b1;
     
      if (!Xcheck_accessX(rw,map_info,"read()"))
        return;
   
   `ifdef UVM_REG_NO_INDIVIDUAL_FIELD_ACCESS
      rw.element_kind = UVM_REG;
      rw.element = m_parent;
      m_parent.do_read(rw);
      rw.value[0] = (rw.value[0] >> m_lsb) & ((1<<m_size))-1;
      bad_side_effect = 1;
   `else
   
      if (!is_indv_accessible(rw.path,rw.local_map)) begin
         rw.element_kind = UVM_REG;
         rw.element = m_parent;
         bad_side_effect = 1;
         m_parent.do_read(rw);
         rw.value[0] = (rw.value[0] >> m_lsb) & ((1<<m_size))-1;
      end
      else begin
   
        uvm_reg_map system_map = rw.local_map.get_root_map();
        uvm_reg_field_cb_iter cbs = new(this);
   
        m_parent.Xset_busyX(1);
   
        rw.status = UVM_IS_OK;
         
        pre_read(rw);
        for (uvm_reg_cbs cb = cbs.first(); cb != null; cb = cbs.next())
           cb.pre_read(rw);
   
        if (rw.status != UVM_IS_OK) begin
           m_read_in_progress = 1'b0;
           m_parent.Xset_busyX(0);
           m_parent.XatomicX(0);
   
           return;
        end
               
        rw.local_map.do_read(rw);
   
   
        if (system_map.get_auto_predict())
           do_predict(rw, UVM_PREDICT_READ);
   
        post_read(rw);
        for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
           cb.post_read(rw);
   
        m_parent.Xset_busyX(0);
         
      end
   
   `endif
   
      m_read_in_progress = 1'b0;
      m_parent.XatomicX(0);
   
      if (bad_side_effect) begin
         uvm_reg_field fields[$];
         m_parent.get_fields(fields);
         foreach (fields[i]) begin
            string mode;
            if (fields[i] == this)
               continue;
            mode = fields[i].get_access();
            if (mode == "RC" || mode == "RS" || mode == "WRC" || mode == "WRS" || mode == "WSRC" || mode == "WCRS" || mode == "W1SRC" || mode == "W1CRS" || mode == "W0SRC" || mode == "W0CRS") begin
               `uvm_warning("RegModel", {"Reading field '",get_full_name(), "' will cause unintended side effects in adjoining ", "Read-to-Clear or Read-to-Set fields in the same register"})
            end
         end
      end
   
   endtask: do_read
   
   function bit is_indv_accessible(uvm_path_e  path, uvm_reg_map local_map);
      if (path == UVM_BACKDOOR) begin
         `uvm_warning("RegModel", {"Individual BACKDOOR field access not available for field '", get_full_name(), "'. Accessing complete register instead."})
         return 0;
      end
   
      if (!m_individually_accessible) begin
            `uvm_warning("RegModel", {"Individual field access not available for field '", get_full_name(), "'. Accessing complete register instead."})
         return 0;
      end
   
      if (m_parent.get_frontdoor(local_map) != null) begin
         `uvm_warning("RegModel", {"Individual field access not available for field '", get_name(), "' because register '", m_parent.get_full_name(), "' has a user-defined front-door. Accessing complete register instead."})
         return 0;
      end
      
      begin
        uvm_reg_map system_map = local_map.get_root_map();
        uvm_reg_adapter adapter = system_map.get_adapter();
        if (adapter.supports_byte_enable)
          return 1;
      end
   
      begin
        int fld_idx;
        int bus_width = local_map.get_n_bytes();
        uvm_reg_field fields[$];
        bit sole_field;
   
        m_parent.get_fields(fields);
   
        if (fields.size() == 1) begin
           sole_field = 1;
        end
        else begin
           int prev_lsb,this_lsb,next_lsb; 
           int prev_sz,this_sz,next_sz; 
           int bus_sz = bus_width*8;
   
           foreach (fields[i]) begin
              if (fields[i] == this) begin
                 fld_idx = i;
                 break;
              end
           end
   
           this_lsb = fields[fld_idx].get_lsb_pos();
           this_sz  = fields[fld_idx].get_n_bits();
   
           if (fld_idx>0) begin
             prev_lsb = fields[fld_idx-1].get_lsb_pos();
             prev_sz  = fields[fld_idx-1].get_n_bits();
           end
   
           if (fld_idx < fields.size()-1) begin
             next_lsb = fields[fld_idx+1].get_lsb_pos();
             next_sz  = fields[fld_idx+1].get_n_bits();
           end
   
           if (fld_idx == 0 &&
              ((next_lsb % bus_sz) == 0 ||
               (next_lsb - this_sz) > (next_lsb % bus_sz)))
              return 1;
   
           else if (fld_idx == (fields.size()-1) &&
               ((this_lsb % bus_sz) == 0 ||
                (this_lsb - (prev_lsb + prev_sz)) >= (this_lsb % bus_sz)))
              return 1;
   
           else begin
              if ((this_lsb % bus_sz) == 0) begin
                 if ((next_lsb % bus_sz) == 0 ||
                     (next_lsb - (this_lsb + this_sz)) >= (next_lsb % bus_sz))
                    return 1;
              end 
              else begin
                 if ( (next_lsb - (this_lsb + this_sz)) >= (next_lsb % bus_sz) &&
                     ((this_lsb - (prev_lsb + prev_sz)) >= (this_lsb % bus_sz)) )
                    return 1;
              end
           end
        end
      end
      
      `uvm_warning("RegModel", {"Target bus does not support byte enabling, and the field '", get_full_name(),"' is not the only field within the entire bus width. ", "Individual field access will not be available. ", "Accessing complete register instead."})
   
      return 0;
   
   endfunction
   
   task poke(output uvm_status_e      status, input  uvm_reg_data_t    value, input  string            kind = "", input  uvm_sequence_base parent = null, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      uvm_reg_data_t  tmp;
   
      m_fname = fname;
      m_lineno = lineno;
   
      if (value >> m_size) begin
         `uvm_warning("RegModel", {"poke(): Value exceeds size of field '",
             get_name(),"'"})
         value &= value & ((1<<m_size)-1);
      end
   
   
      m_parent.XatomicX(1);
      m_parent.m_is_locked_by_field = 1'b1;
   
      tmp = 0;
   
      m_parent.peek(status, tmp, kind, parent, extension, fname, lineno);
   
      if (status == UVM_NOT_OK) begin
         `uvm_error("RegModel", {"poke(): Peek of register '", m_parent.get_full_name(),"' returned status ",status.name()})
         m_parent.XatomicX(0);
         m_parent.m_is_locked_by_field = 1'b0;
         return;
      end
   
      tmp &= ~(((1<<m_size)-1) << m_lsb);
      tmp |= value << m_lsb;
      m_parent.poke(status, tmp, kind, parent, extension, fname, lineno);
   
      m_parent.XatomicX(0);
      m_parent.m_is_locked_by_field = 1'b0;
   endtask: poke
   
   task peek(output uvm_status_e      status, output uvm_reg_data_t    value, input  string            kind = "", input  uvm_sequence_base parent = null, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      uvm_reg_data_t  reg_value;
   
      m_fname = fname;
      m_lineno = lineno;
   
      m_parent.peek(status, reg_value, kind, parent, extension, fname, lineno);
      value = (reg_value >> m_lsb) & ((1<<m_size))-1;
   
   endtask: peek
   
   task mirror(output uvm_status_e      status, input  uvm_check_e       check = UVM_NO_CHECK, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  uvm_sequence_base parent = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      m_fname = fname;
      m_lineno = lineno;
      m_parent.mirror(status, check, path, map, parent, prior, extension, fname, lineno);
   endtask: mirror
   
   function void set_compare(uvm_check_e check=UVM_CHECK);
     m_check = check;
   endfunction
   
   function uvm_check_e get_compare();
     return m_check;
   endfunction
   
   function void pre_randomize();
      value = m_desired;
   endfunction: pre_randomize
   
   function void post_randomize();
      m_desired = value;
   endfunction: post_randomize
   
   function void do_print (uvm_printer printer);
     printer.print_generic(get_name(), get_type_name(), -1, convert2string());
   endfunction
   
   function string convert2string();
      string fmt;
      string res_str;
      string t_str;
      bit with_debug_info;
      string prefix;
      uvm_reg reg_=get_register();
   
      $sformat(fmt, "%0d'h%%%0dh", get_n_bits(), (get_n_bits()-1)/4 + 1);
      $sformat(convert2string, {"%s %s %s[%0d:%0d]=",fmt,"%s"}, prefix, get_access(), reg_.get_name(), get_lsb_pos() + get_n_bits() - 1, get_lsb_pos(), m_desired, (m_desired != m_mirrored) ? $sformatf({" (Mirror: ",fmt,")"}, m_mirrored) : ""); 
   
      if (m_read_in_progress == 1'b1) begin
         if (m_fname != "" && m_lineno != 0)
            $sformat(res_str, " from %s:%0d",m_fname, m_lineno);
         convert2string = {convert2string, "\n", "currently being read", res_str}; 
      end
      if (m_write_in_progress == 1'b1) begin
         if (m_fname != "" && m_lineno != 0)
            $sformat(res_str, " from %s:%0d",m_fname, m_lineno);
         convert2string = {convert2string, "\n", res_str, "currently being written"}; 
      end
   endfunction: convert2string
   
   function uvm_object clone();
     `uvm_fatal("RegModel","RegModel field cannot be cloned")
     return null;
   endfunction
   
   function void do_copy(uvm_object rhs);
     `uvm_warning("RegModel","RegModel field copy not yet implemented")
   endfunction
   
   function bit do_compare (uvm_object  rhs, uvm_comparer comparer);
     `uvm_warning("RegModel","RegModel field compare not yet implemented")
     return 0;
   endfunction
   
   function void do_pack (uvm_packer packer);
     `uvm_warning("RegModel","RegModel field cannot be packed")
   endfunction
   
   function void do_unpack (uvm_packer packer);
     `uvm_warning("RegModel","RegModel field cannot be unpacked")
   endfunction

endclass: uvm_reg_field


typedef class uvm_vreg_field_cbs;
typedef uvm_callbacks#(uvm_vreg_field, uvm_vreg_field_cbs) uvm_vreg_field_cb;
typedef uvm_callback_iter#(uvm_vreg_field, uvm_vreg_field_cbs) uvm_vreg_field_cb_iter;

class uvm_vreg_field extends uvm_object;

   `uvm_object_utils(uvm_vreg_field)
   `uvm_register_cb(uvm_vreg_field, uvm_vreg_field_cbs)
   
   local uvm_vreg parent;
   local int unsigned lsb;
   local int unsigned size;
   local string fname;
   local int lineno;
   local bit read_in_progress;
   local bit write_in_progress;
   
   virtual task pre_write(longint unsigned     idx, ref uvm_reg_data_t   wdat, ref uvm_path_e  path, ref uvm_reg_map   map);
   endtask: pre_write
   
   virtual task post_write(longint unsigned       idx, uvm_reg_data_t         wdat, uvm_path_e        path, uvm_reg_map         map, ref uvm_status_e  status);
   endtask: post_write
   
   virtual task pre_read(longint unsigned      idx, ref uvm_path_e   path, ref uvm_reg_map    map);
   endtask: pre_read
   
   virtual task post_read(longint unsigned       idx, ref uvm_reg_data_t     rdat, uvm_path_e        path, uvm_reg_map         map, ref uvm_status_e  status);
   endtask: post_read
   
   function new(string name="uvm_vreg_field");
      super.new(name);
   endfunction: new
   
   function void configure(uvm_vreg  parent, int unsigned  size, int unsigned  lsb_pos);
      this.parent = parent;
      if (size == 0) begin
         `uvm_error("RegModel", $sformatf("Virtual field \"%s\" cannot have 0 bits", this.get_full_name()));
         size = 1;
      end
      if (size > `UVM_REG_DATA_WIDTH) begin
         `uvm_error("RegModel", $sformatf("Virtual field \"%s\" cannot have more than %0d bits", this.get_full_name(), `UVM_REG_DATA_WIDTH));
         size = `UVM_REG_DATA_WIDTH;
      end
   
      this.size   = size;
      this.lsb    = lsb_pos;
   
      this.parent.add_field(this);
   endfunction: configure
   
   virtual function string get_full_name();
      get_full_name = {this.parent.get_full_name(), ".", this.get_name()};
   endfunction: get_full_name
   
   virtual function uvm_vreg get_register();
      get_register = this.parent;
   endfunction: get_register
   
   virtual function uvm_vreg get_parent();
      get_parent = this.parent;
   endfunction: get_parent
   
   virtual function int unsigned get_lsb_pos_in_register();
      get_lsb_pos_in_register = this.lsb;
   endfunction: get_lsb_pos_in_register
   
   virtual function int unsigned get_n_bits();
      get_n_bits = this.size;
   endfunction: get_n_bits
   
   virtual function string get_access(uvm_reg_map map = null);
      if (this.parent.get_memory() == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call get_rights() on unimplemented virtual field \"%s\"", this.get_full_name()));
         return "RW";
      end
   
      return this.parent.get_access(map);
   endfunction: get_access
   
   virtual task write(input  longint unsigned    idx, output uvm_status_e   status, input  uvm_reg_data_t      value, input  uvm_path_e     path = UVM_DEFAULT_PATH, input  uvm_reg_map      map = null, input  uvm_sequence_base   parent = null, input  uvm_object          extension = null, input  string              fname = "", input  int                 lineno = 0);
      uvm_reg_data_t  tmp;
      uvm_reg_data_t  segval;
      uvm_reg_addr_t  segoff;
      uvm_status_e st;
   
      int flsb, fmsb, rmwbits;
      int segsiz, segn;
      uvm_mem    mem;
      uvm_path_e rm_path;
   
      uvm_vreg_field_cb_iter cbs = new(this);
   
      this.fname = fname;
      this.lineno = lineno;
   
      write_in_progress = 1'b1;
      mem = this.parent.get_memory();
      if (mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call write() on unimplemented virtual register \"%s\"", this.get_full_name()));
         status = UVM_NOT_OK;
         return;
      end
   
      if (path == UVM_DEFAULT_PATH) begin
         uvm_reg_block blk = this.parent.get_block();
         path = blk.get_default_path();
      end
   
      status = UVM_IS_OK;
   
      this.parent.XatomicX(1);
   
      if (value >> this.size) begin
         `uvm_warning("RegModel", $sformatf("Writing value 'h%h that is greater than field \"%s\" size (%0d bits)", value, this.get_full_name(), this.get_n_bits()));
         value &= value & ((1<<this.size)-1);
      end
      tmp = 0;
   
      this.pre_write(idx, value, path, map);
      for (uvm_vreg_field_cbs cb = cbs.first(); cb != null;
           cb = cbs.next()) begin
         cb.fname = this.fname;
         cb.lineno = this.lineno;
         cb.pre_write(this, idx, value, path, map);
      end
   
      segsiz = mem.get_n_bytes() * 8;
      flsb    = this.get_lsb_pos_in_register();
      segoff  = this.parent.get_offset_in_memory(idx) + (flsb / segsiz);
   
      rm_path = UVM_DEFAULT_PATH;
      if (mem.get_backdoor() != null) rm_path = UVM_BACKDOOR;
   
      rmwbits = flsb % segsiz;
   
      segn = (rmwbits + this.get_n_bits() - 1) / segsiz + 1;
   
      if (rmwbits > 0) begin
         uvm_reg_addr_t  segn;
   
         mem.read(st, segoff, tmp, rm_path, map, parent, , extension, fname, lineno);
         if (st != UVM_IS_OK && st != UVM_HAS_X) begin
            `uvm_error("RegModel", $sformatf("Unable to read LSB bits in %s[%0d] to for RMW cycle on virtual field %s.", mem.get_full_name(), segoff, this.get_full_name()));
            status = UVM_NOT_OK;
            this.parent.XatomicX(0);
            return;
         end
   
         value = (value << rmwbits) | (tmp & ((1<<rmwbits)-1));
      end
   
      fmsb = rmwbits + this.get_n_bits() - 1;
      rmwbits = (fmsb+1) % segsiz;
      if (rmwbits > 0) begin
         if (segn > 0) begin
            mem.read(st, segoff + segn - 1, tmp, rm_path, map, parent,, extension, fname, lineno);
            if (st != UVM_IS_OK && st != UVM_HAS_X) begin
               `uvm_error("RegModel", $sformatf("Unable to read MSB bits in %s[%0d] to for RMW cycle on virtual field %s.", mem.get_full_name(), segoff+segn-1, this.get_full_name()));
               status = UVM_NOT_OK;
               this.parent.XatomicX(0);
               return;
            end
         end
         value |= (tmp & ~((1<<rmwbits)-1)) << ((segn-1)*segsiz);
      end
   
      tmp = value;
      repeat (segn) begin
         mem.write(st, segoff, tmp, path, map, parent,, extension, fname, lineno);
         if (st != UVM_IS_OK && st != UVM_HAS_X) status = UVM_NOT_OK;
   
         segoff++;
         tmp = tmp >> segsiz;
      end
   
      this.post_write(idx, value, path, map, status);
      for (uvm_vreg_field_cbs cb = cbs.first(); cb != null;
           cb = cbs.next()) begin
         cb.fname = this.fname;
         cb.lineno = this.lineno;
         cb.post_write(this, idx, value, path, map, status);
      end
   
      this.parent.XatomicX(0);
   
   
      `uvm_info("RegModel", $sformatf("Wrote virtual field \"%s\"[%0d] via %s with: 'h%h", this.get_full_name(), idx, (path == UVM_FRONTDOOR) ? "frontdoor" : "backdoor", value),UVM_MEDIUM); 
      
      write_in_progress = 1'b0;
      this.fname = "";
      this.lineno = 0;
   endtask: write
   
   
   virtual task read(input longint unsigned     idx, output uvm_status_e   status, output uvm_reg_data_t      value, input  uvm_path_e     path = UVM_DEFAULT_PATH, input  uvm_reg_map      map = null, input  uvm_sequence_base   parent = null, input  uvm_object          extension = null, input  string              fname = "", input  int                 lineno = 0);
      uvm_reg_data_t  tmp;
      uvm_reg_data_t  segval;
      uvm_reg_addr_t  segoff;
      uvm_status_e st;
   
      int flsb, lsb;
      int segsiz, segn;
      uvm_mem    mem;
   
      uvm_vreg_field_cb_iter cbs = new(this);
   
      this.fname = fname;
      this.lineno = lineno;
   
      read_in_progress = 1'b1;
      mem = this.parent.get_memory();
      if (mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call read() on unimplemented virtual register \"%s\"", this.get_full_name()));
         status = UVM_NOT_OK;
         return;
      end
   
      if (path == UVM_DEFAULT_PATH) begin
         uvm_reg_block blk = this.parent.get_block();
         path = blk.get_default_path();
      end
   
      status = UVM_IS_OK;
   
      this.parent.XatomicX(1);
   
      value = 0;
   
      this.pre_read(idx, path, map);
      for (uvm_vreg_field_cbs cb = cbs.first(); cb != null;
           cb = cbs.next()) begin
         cb.fname = this.fname;
         cb.lineno = this.lineno;
         cb.pre_read(this, idx, path, map);
      end
   
      segsiz = mem.get_n_bytes() * 8;
      flsb    = this.get_lsb_pos_in_register();
      segoff  = this.parent.get_offset_in_memory(idx) + (flsb / segsiz);
      lsb = flsb % segsiz;
   
      segn = (lsb + this.get_n_bits() - 1) / segsiz + 1;
   
      segoff += segn - 1;
      repeat (segn) begin
         value = value << segsiz;
   
         mem.read(st, segoff, tmp, path, map, parent, , extension, fname, lineno);
         if (st != UVM_IS_OK && st != UVM_HAS_X) status = UVM_NOT_OK;
   
         segoff--;
         value |= tmp;
      end
   
      value = value >> lsb;
   
      value &= (1<<this.get_n_bits()) - 1;
   
      this.post_read(idx, value, path, map, status);
      for (uvm_vreg_field_cbs cb = cbs.first(); cb != null;
           cb = cbs.next()) begin
         cb.fname = this.fname;
         cb.lineno = this.lineno;
         cb.post_read(this, idx, value, path, map, status);
      end
   
      this.parent.XatomicX(0);
   
      `uvm_info("RegModel", $sformatf("Read virtual field \"%s\"[%0d] via %s: 'h%h", this.get_full_name(), idx, (path == UVM_FRONTDOOR) ? "frontdoor" : "backdoor", value),UVM_MEDIUM); 
   
      read_in_progress = 1'b0;
      this.fname = "";
      this.lineno = 0;
   endtask: read
                  
   
   virtual task poke(input  longint unsigned  idx, output uvm_status_e status, input  uvm_reg_data_t    value, input  uvm_sequence_base parent = null, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      uvm_reg_data_t  tmp;
      uvm_reg_data_t  segval;
      uvm_reg_addr_t  segoff;
      uvm_status_e st;
   
      int flsb, fmsb, rmwbits;
      int segsiz, segn;
      uvm_mem    mem;
      uvm_path_e rm_path;
      this.fname = fname;
      this.lineno = lineno;
   
      mem = this.parent.get_memory();
      if (mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call poke() on unimplemented virtual register \"%s\"", this.get_full_name()));
         status = UVM_NOT_OK;
         return;
      end
   
      status = UVM_IS_OK;
   
      this.parent.XatomicX(1);
   
      if (value >> this.size) begin
         `uvm_warning("RegModel", $sformatf("Writing value 'h%h that is greater than field \"%s\" size (%0d bits)", value, this.get_full_name(), this.get_n_bits()));
         value &= value & ((1<<this.size)-1);
      end
      tmp = 0;
   
      segsiz = mem.get_n_bytes() * 8;
      flsb    = this.get_lsb_pos_in_register();
      segoff  = this.parent.get_offset_in_memory(idx) + (flsb / segsiz);
   
      rmwbits = flsb % segsiz;
   
      segn = (rmwbits + this.get_n_bits() - 1) / segsiz + 1;
   
      if (rmwbits > 0) begin
         uvm_reg_addr_t  segn;
   
         mem.peek(st, segoff, tmp, "", parent, extension, fname, lineno);
         if (st != UVM_IS_OK && st != UVM_HAS_X) begin
            `uvm_error("RegModel", $sformatf("Unable to read LSB bits in %s[%0d] to for RMW cycle on virtual field %s.", mem.get_full_name(), segoff, this.get_full_name()));
            status = UVM_NOT_OK;
            this.parent.XatomicX(0);
            return;
         end
   
         value = (value << rmwbits) | (tmp & ((1<<rmwbits)-1));
      end
   
      fmsb = rmwbits + this.get_n_bits() - 1;
      rmwbits = (fmsb+1) % segsiz;
      if (rmwbits > 0) begin
         if (segn > 0) begin
            mem.peek(st, segoff + segn - 1, tmp, "", parent, extension, fname, lineno);
            if (st != UVM_IS_OK && st != UVM_HAS_X) begin
               `uvm_error("RegModel", $sformatf("Unable to read MSB bits in %s[%0d] to for RMW cycle on virtual field %s.", mem.get_full_name(), segoff+segn-1, this.get_full_name()));
               status = UVM_NOT_OK;
               this.parent.XatomicX(0);
               return;
            end
         end
         value |= (tmp & ~((1<<rmwbits)-1)) << ((segn-1)*segsiz);
      end
   
      tmp = value;
      repeat (segn) begin
         mem.poke(st, segoff, tmp, "", parent, extension, fname, lineno);
         if (st != UVM_IS_OK && st != UVM_HAS_X) status = UVM_NOT_OK;
   
         segoff++;
         tmp = tmp >> segsiz;
      end
   
      this.parent.XatomicX(0);
   
      `uvm_info("RegModel", $sformatf("Wrote virtual field \"%s\"[%0d] with: 'h%h", this.get_full_name(), idx, value),UVM_MEDIUM);
   
      this.fname = "";
      this.lineno = 0;
   endtask: poke
   
   virtual task peek(input  longint unsigned  idx, output uvm_status_e status, output uvm_reg_data_t    value, input  uvm_sequence_base parent = null, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      uvm_reg_data_t  tmp;
      uvm_reg_data_t  segval;
      uvm_reg_addr_t  segoff;
      uvm_status_e st;
   
      int flsb, lsb;
      int segsiz, segn;
      uvm_mem    mem;
      this.fname = fname;
      this.lineno = lineno;
   
      mem = this.parent.get_memory();
      if (mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call peek() on unimplemented virtual register \"%s\"", this.get_full_name()));
         status = UVM_NOT_OK;
         return;
      end
   
      status = UVM_IS_OK;
   
      this.parent.XatomicX(1);
   
      value = 0;
   
      segsiz = mem.get_n_bytes() * 8;
      flsb    = this.get_lsb_pos_in_register();
      segoff  = this.parent.get_offset_in_memory(idx) + (flsb / segsiz);
      lsb = flsb % segsiz;
   
      segn = (lsb + this.get_n_bits() - 1) / segsiz + 1;
   
      segoff += segn - 1;
      repeat (segn) begin
         value = value << segsiz;
   
         mem.peek(st, segoff, tmp, "", parent, extension, fname, lineno);
   
         if (st != UVM_IS_OK && st != UVM_HAS_X) status = UVM_NOT_OK;
   
         segoff--;
         value |= tmp;
      end
   
      value = value >> lsb;
   
      value &= (1<<this.get_n_bits()) - 1;
   
      this.parent.XatomicX(0);
   
      `uvm_info("RegModel", $sformatf("Peeked virtual field \"%s\"[%0d]: 'h%h", this.get_full_name(), idx, value),UVM_MEDIUM);
   
      this.fname = "";
      this.lineno = 0;
   endtask: peek
                  
   virtual function void do_print (uvm_printer printer);
     super.do_print(printer);
     printer.print_generic("initiator", parent.get_type_name(), -1, convert2string());
   endfunction
   
   virtual function string convert2string();
      string res_str;
      string t_str;
      bit with_debug_info = 1'b0;
      $sformat(convert2string, {"%s[%0d-%0d]"}, this.get_name(), this.get_lsb_pos_in_register() + this.get_n_bits() - 1, this.get_lsb_pos_in_register()); if (read_in_progress == 1'b1) begin
         if (fname != "" && lineno != 0)
            $sformat(res_str, "%s:%0d ",fname, lineno);
         convert2string = {convert2string, "\n", res_str, "currently executing read method"}; 
      end
      if ( write_in_progress == 1'b1) begin
         if (fname != "" && lineno != 0)
            $sformat(res_str, "%s:%0d ",fname, lineno);
         convert2string = {convert2string, "\n", res_str, "currently executing write method"}; 
      end
   
   endfunction
   
   virtual function uvm_object clone();
     return null;
   endfunction
   
   virtual function void do_copy   (uvm_object rhs);
   endfunction
   
   virtual function bit do_compare (uvm_object  rhs, uvm_comparer comparer);
     return 0;
   endfunction
   
   virtual function void do_pack (uvm_packer packer);
   endfunction
   
   virtual function void do_unpack (uvm_packer packer);
   endfunction

endclass: uvm_vreg_field

class uvm_vreg_field_cbs extends uvm_callback;
   string fname;
   int    lineno;

   function new(string name = "uvm_vreg_field_cbs");
      super.new(name);
   endfunction
   
   virtual task pre_write(uvm_vreg_field       field, longint unsigned     idx, ref uvm_reg_data_t   wdat, ref uvm_path_e  path, ref uvm_reg_map   map);
   endtask: pre_write

   virtual task post_write(uvm_vreg_field        field, longint unsigned      idx, uvm_reg_data_t        wdat, uvm_path_e       path, uvm_reg_map        map, ref uvm_status_e status);
   endtask: post_write

   virtual task pre_read(uvm_vreg_field        field, longint unsigned      idx, ref uvm_path_e   path, ref uvm_reg_map    map);
   endtask: pre_read

   virtual task post_read(uvm_vreg_field         field, longint unsigned       idx, ref uvm_reg_data_t     rdat, uvm_path_e        path, uvm_reg_map         map, ref uvm_status_e  status);
   endtask: post_read

endclass: uvm_vreg_field_cbs

typedef class uvm_reg_cbs;
typedef class uvm_reg_frontdoor;

virtual class uvm_reg extends uvm_object;

   local bit               m_locked;
   local uvm_reg_block     m_parent;
   local uvm_reg_file      m_regfile_parent;
   local int unsigned      m_n_bits;
   local int unsigned      m_n_used_bits;
   protected bit           m_maps[uvm_reg_map];
   protected uvm_reg_field m_fields[$];   
   local int               m_has_cover;
   local int               m_cover_on;
   local semaphore         m_atomic;
   local process           m_process;
   local string            m_fname;
   local int               m_lineno;
   local bit               m_read_in_progress;
   local bit               m_write_in_progress; 
   protected bit           m_update_in_progress;
   bit           m_is_busy;
   bit           m_is_locked_by_field;
   local uvm_reg_backdoor  m_backdoor;
   local static int unsigned m_max_size;
   local uvm_object_string_pool #(uvm_queue #(uvm_hdl_path_concat)) m_hdl_paths_pool;
   
   virtual task  backdoor_watch(); endtask
   
   protected virtual function void sample(uvm_reg_data_t  data, uvm_reg_data_t  byte_en, bit             is_read, uvm_reg_map     map);
   endfunction
   
   virtual function void sample_values();
   endfunction
   
   function void XsampleX(uvm_reg_data_t  data, uvm_reg_data_t  byte_en, bit             is_read, uvm_reg_map     map);
      sample(data, byte_en, is_read, map);
   endfunction
   
   `uvm_register_cb(uvm_reg, uvm_reg_cbs)
   
   virtual task pre_write(uvm_reg_item rw); endtask
   virtual task post_write(uvm_reg_item rw); endtask
   virtual task pre_read(uvm_reg_item rw); endtask
   virtual task post_read(uvm_reg_item rw); endtask
   
   function new(string name="", int unsigned n_bits, int has_coverage);
      super.new(name);
      if (n_bits == 0) begin
         `uvm_error("RegModel", $sformatf("Register \"%s\" cannot have 0 bits", get_name()));
         n_bits = 1;
      end
      m_n_bits      = n_bits;
      m_has_cover   = has_coverage;
      m_atomic      = new(1);
      m_n_used_bits = 0;
      m_locked      = 0;
      m_is_busy     = 0;
      m_is_locked_by_field = 1'b0;
      m_hdl_paths_pool = new("hdl_paths");
   
      if (n_bits > m_max_size)
         m_max_size = n_bits;
   
   endfunction: new
   
   function void configure (uvm_reg_block blk_parent, uvm_reg_file regfile_parent=null, string hdl_path = "");
      if (blk_parent == null) begin
        `uvm_error("UVM/REG/CFG/NOBLK", {"configure() called without a parent block for instance \"", get_name(), "\" of register type \"", get_type_name(), "\"."})
        return;
      end
   
      m_parent = blk_parent;
      m_parent.add_reg(this);
      m_regfile_parent = regfile_parent;
      if (hdl_path != "")
        add_hdl_path_slice(hdl_path, -1, -1);
   endfunction: configure
   
   virtual function void add_field(uvm_reg_field field);
      int offset;
      int idx;
      
      if (m_locked) begin
         `uvm_error("RegModel", "Cannot add field to locked register model");
         return;
      end
   
      if (field == null) `uvm_fatal("RegModel", "Attempting to register NULL field");
   
      offset = field.get_lsb_pos();
   
      idx = -1;
      foreach (m_fields[i]) begin
         if (offset < m_fields[i].get_lsb_pos()) begin
            int j = i;
            m_fields.insert(j, field);
            idx = i;
            break;
         end
      end
      if (idx < 0) begin
         m_fields.push_back(field);
         idx = m_fields.size()-1;
      end
   
      m_n_used_bits += field.get_n_bits();
      
      if (m_n_used_bits > m_n_bits) begin
         `uvm_error("RegModel", $sformatf("Fields use more bits (%0d) than available in register \"%s\" (%0d)", m_n_used_bits, get_name(), m_n_bits));
      end
   
      if (idx > 0) begin
         if (m_fields[idx-1].get_lsb_pos() +
             m_fields[idx-1].get_n_bits() > offset) begin
            `uvm_error("RegModel", $sformatf("Field %s overlaps field %s in register \"%s\"", m_fields[idx-1].get_name(), field.get_name(), get_name()));
         end
      end
      if (idx < m_fields.size()-1) begin
         if (offset + field.get_n_bits() >
             m_fields[idx+1].get_lsb_pos()) begin
            `uvm_error("RegModel", $sformatf("Field %s overlaps field %s in register \"%s\"", field.get_name(), m_fields[idx+1].get_name(), get_name()));
         end
      end
   endfunction: add_field
   
   virtual function void Xlock_modelX();
      if (m_locked)
        return;
      m_locked = 1;
   endfunction
   
   virtual function void set_frontdoor(uvm_reg_frontdoor ftdr, uvm_reg_map       map = null, string            fname = "", int               lineno = 0);
      uvm_reg_map_info map_info;
      ftdr.fname = m_fname;
      ftdr.lineno = m_lineno;
      map = get_local_map(map, "set_frontdoor()");
      if (map == null)
        return;
      map_info = map.get_reg_map_info(this);
      if (map_info == null)
         map.add_reg(this, -1, "RW", 1, ftdr);
      else begin
         map_info.frontdoor = ftdr;
      end
   endfunction: set_frontdoor
   
   virtual function uvm_reg_frontdoor get_frontdoor(uvm_reg_map map = null);
      uvm_reg_map_info map_info;
      map = get_local_map(map, "get_frontdoor()");
      if (map == null)
        return null;
      map_info = map.get_reg_map_info(this);
      return map_info.frontdoor;
   endfunction: get_frontdoor
   
   virtual function void set_backdoor(uvm_reg_backdoor bkdr, string           fname = "", int              lineno = 0);
      bkdr.fname = fname;
      bkdr.lineno = lineno;
      if (m_backdoor != null &&
          m_backdoor.has_update_threads()) begin
         `uvm_warning("RegModel", "Previous register backdoor still has update threads running. Backdoors with active mirroring should only be set before simulation starts.");
      end
      m_backdoor = bkdr;
   endfunction: set_backdoor
   
   virtual function uvm_reg_backdoor get_backdoor(bit inherited = 1);
   
      if (m_backdoor == null && inherited) begin
        uvm_reg_block blk = get_parent();
        uvm_reg_backdoor bkdr;
        while (blk != null) begin
          bkdr = blk.get_backdoor();
          if (bkdr != null) begin
            m_backdoor = bkdr;
            break;
          end
          blk = blk.get_parent();
        end
      end
      return m_backdoor;
   endfunction: get_backdoor
   
   virtual function void clear_hdl_path(string kind = "RTL");
     if (kind == "ALL") begin
       m_hdl_paths_pool = new("hdl_paths");
       return;
     end
   
     if (kind == "") begin
        if (m_regfile_parent != null)
           kind = m_regfile_parent.get_default_hdl_path();
        else
           kind = m_parent.get_default_hdl_path();
     end
   
     if (!m_hdl_paths_pool.exists(kind)) begin
       `uvm_warning("RegModel",{"Unknown HDL Abstraction '",kind,"'"})
       return;
     end
   
     m_hdl_paths_pool.delete(kind);
   endfunction
   
   virtual function void add_hdl_path(uvm_hdl_path_slice slices[], string kind = "RTL");
       uvm_queue #(uvm_hdl_path_concat) paths = m_hdl_paths_pool.get(kind);
       uvm_hdl_path_concat concat = new();
   
       concat.set(slices);
       paths.push_back(concat);
   endfunction
   
   virtual function void add_hdl_path_slice(string name, int offset, int size, bit first = 0, string kind = "RTL");
       uvm_queue #(uvm_hdl_path_concat) paths = m_hdl_paths_pool.get(kind);
       uvm_hdl_path_concat concat;
       
       if (first || paths.size() == 0) begin
          concat = new();
          paths.push_back(concat);
       end
       else
          concat = paths.get(paths.size()-1);
   
      concat.add_path(name, offset, size);
   endfunction
   
   virtual function bit  has_hdl_path(string kind = "");
     if (kind == "") begin
        if (m_regfile_parent != null)
           kind = m_regfile_parent.get_default_hdl_path();
        else
           kind = m_parent.get_default_hdl_path();
     end
   
     return m_hdl_paths_pool.exists(kind);
   endfunction
   
   virtual function void get_hdl_path_kinds (ref string kinds[$]);
     string kind;
     kinds.delete();
     if (!m_hdl_paths_pool.first(kind))
       return;
     do
       kinds.push_back(kind);
     while (m_hdl_paths_pool.next(kind));
   endfunction
   
   virtual function void get_hdl_path(ref uvm_hdl_path_concat paths[$], input string kind = "");
   
     uvm_queue #(uvm_hdl_path_concat) hdl_paths;
   
     if (kind == "") begin
        if (m_regfile_parent != null)
           kind = m_regfile_parent.get_default_hdl_path();
        else
           kind = m_parent.get_default_hdl_path();
     end
   
     if (!has_hdl_path(kind)) begin
       `uvm_error("RegModel", {"Register does not have hdl path defined for abstraction '",kind,"'"})
       return;
     end
   
     hdl_paths = m_hdl_paths_pool.get(kind);
   
     for (int i=0; i<hdl_paths.size();i++) begin
        paths.push_back(hdl_paths.get(i));
     end
   
   endfunction
   
   virtual function void get_full_hdl_path(ref uvm_hdl_path_concat paths[$], input string kind = "", input string separator = ".");
   
      if (kind == "") begin
         if (m_regfile_parent != null)
            kind = m_regfile_parent.get_default_hdl_path();
         else
            kind = m_parent.get_default_hdl_path();
      end
      
      if (!has_hdl_path(kind)) begin
         `uvm_error("RegModel", {"Register ",get_full_name()," does not have hdl path defined for abstraction '",kind,"'"})
         return;
      end
   
      begin
         uvm_queue #(uvm_hdl_path_concat) hdl_paths = m_hdl_paths_pool.get(kind);
         string parent_paths[$];
   
         if (m_regfile_parent != null)
            m_regfile_parent.get_full_hdl_path(parent_paths, kind, separator);
         else
            m_parent.get_full_hdl_path(parent_paths, kind, separator);
   
         for (int i=0; i<hdl_paths.size();i++) begin
            uvm_hdl_path_concat hdl_concat = hdl_paths.get(i);
   
            foreach (parent_paths[j])  begin
               uvm_hdl_path_concat t = new;
   
               foreach (hdl_concat.slices[k]) begin
                  if (hdl_concat.slices[k].path == "")
                     t.add_path(parent_paths[j]);
                  else
                     t.add_path({ parent_paths[j], separator, hdl_concat.slices[k].path }, hdl_concat.slices[k].offset, hdl_concat.slices[k].size);
               end
               paths.push_back(t);
            end
         end
      end
   endfunction

   virtual function void set_offset (uvm_reg_map    map, uvm_reg_addr_t offset, bit unmapped = 0);
   
      uvm_reg_map orig_map = map;
   
      if (m_maps.num() > 1 && map == null) begin
         `uvm_error("RegModel",{"set_offset requires a non-null map when register '", get_full_name(),"' belongs to more than one map."})
         return;
      end
   
      map = get_local_map(map,"set_offset()");
   
      if (map == null)
        return;
      
      map.m_set_reg_offset(this, offset, unmapped);
   endfunction
   
   virtual function void set_parent(uvm_reg_block blk_parent, uvm_reg_file regfile_parent);
     if (m_parent != null) begin
     end
     m_parent = blk_parent;
     m_regfile_parent = regfile_parent;
   endfunction
   
   virtual function uvm_reg_block get_parent();
     return get_block();
   endfunction
   
   virtual function uvm_reg_file get_regfile();
      return m_regfile_parent;
   endfunction
   
   virtual function string get_full_name();
   
      if (m_regfile_parent != null)
         return {m_regfile_parent.get_full_name(), ".", get_name()};
   
      if (m_parent != null)
         return {m_parent.get_full_name(), ".", get_name()};
      
      return get_name();
   endfunction: get_full_name
   
   virtual function void add_map(uvm_reg_map map);
     m_maps[map] = 1;
   endfunction
   
   virtual function void get_maps(ref uvm_reg_map maps[$]);
      foreach (m_maps[map])
        maps.push_back(map);
   endfunction
   
   virtual function int get_n_maps();
      return m_maps.num();
   endfunction
   
   virtual function bit is_in_map(uvm_reg_map map);
      if (m_maps.exists(map))
        return 1;
      foreach (m_maps[l]) begin
        uvm_reg_map local_map = l;
        uvm_reg_map parent_map = local_map.get_parent_map();
   
        while (parent_map != null) begin
          if (parent_map == map)
            return 1;
          parent_map = parent_map.get_parent_map();
        end
      end
      return 0;
   endfunction
   
   virtual function uvm_reg_map get_local_map(uvm_reg_map map, string caller="");
      if (map == null)
        return get_default_map();
      if (m_maps.exists(map))
        return map; 
      foreach (m_maps[l]) begin
        uvm_reg_map local_map=l;
        uvm_reg_map parent_map = local_map.get_parent_map();
   
        while (parent_map != null) begin
          if (parent_map == map)
            return local_map;
          parent_map = parent_map.get_parent_map();
        end
      end
      `uvm_warning("RegModel", {"Register '",get_full_name(),"' is not contained within map '",map.get_full_name(),"'", (caller == "" ? "": {" (called from ",caller,")"}) })
      return null;
   endfunction
   
   virtual function uvm_reg_map get_default_map(string caller="");
   
      if (m_maps.num() == 0) begin
         `uvm_warning("RegModel", {"Register '",get_full_name(),"' is not registered with any map", (caller == "" ? "": {" (called from ",caller,")"})})
         return null;
      end
   
      if (m_maps.num() == 1) begin
        uvm_reg_map map;
        void'(m_maps.first(map));
        return map;
      end
   
      foreach (m_maps[l]) begin
        uvm_reg_map map = l;
        uvm_reg_block blk = map.get_parent();
        uvm_reg_map default_map = blk.get_default_map();
        if (default_map != null) begin
          uvm_reg_map local_map = get_local_map(default_map,"get_default_map()");
          if (local_map != null)
            return local_map;
        end
      end
   
   
      begin
        uvm_reg_map map;
        void'(m_maps.first(map));
        return map;
      end
   
   endfunction
   
   virtual function string get_rights(uvm_reg_map map = null);
   
      uvm_reg_map_info info;
   
      map = get_local_map(map,"get_rights()");
   
      if (map == null)
        return "RW";
   
      info = map.get_reg_map_info(this);
      return info.rights;
   
   endfunction
   
   virtual function uvm_reg_block get_block();
      get_block = m_parent;
   endfunction
   
   virtual function uvm_reg_addr_t get_offset(uvm_reg_map map = null);
   
      uvm_reg_map_info map_info;
      uvm_reg_map orig_map = map;
   
      map = get_local_map(map,"get_offset()");
   
      if (map == null)
        return -1;
      
      map_info = map.get_reg_map_info(this);
      
      if (map_info.unmapped) begin
         `uvm_warning("RegModel", {"Register '",get_name(), "' is unmapped in map '", ((orig_map == null) ? map.get_full_name() : orig_map.get_full_name()),"'"})
         return -1;
      end
            
      return map_info.offset;
   
   endfunction
   
   virtual function int get_addresses(uvm_reg_map map=null, ref uvm_reg_addr_t addr[]);
   
      uvm_reg_map_info map_info;
      uvm_reg_map system_map;
      uvm_reg_map orig_map = map;
   
      map = get_local_map(map,"get_addresses()");
   
      if (map == null)
        return -1;
   
      map_info = map.get_reg_map_info(this);
   
      if (map_info.unmapped) begin
         `uvm_warning("RegModel", {"Register '",get_name(), "' is unmapped in map '", ((orig_map == null) ? map.get_full_name() : orig_map.get_full_name()),"'"})
         return -1;
      end
    
      addr = map_info.addr;
      system_map = map.get_root_map();
      return map.get_n_bytes();
   
   endfunction
   
   virtual function uvm_reg_addr_t get_address(uvm_reg_map map = null);
      uvm_reg_addr_t  addr[];
      void'(get_addresses(map,addr));
      return addr[0];
   endfunction
   
   virtual function int unsigned get_n_bits();
      return m_n_bits;
   endfunction
   
   virtual function int unsigned get_n_bytes();
      return ((m_n_bits-1) / 8) + 1;
   endfunction
   
   static function int unsigned get_max_size();
      return m_max_size;
   endfunction: get_max_size
   
   virtual function void get_fields(ref uvm_reg_field fields[$]);
      foreach(m_fields[i])
         fields.push_back(m_fields[i]);
   endfunction
   
   virtual function uvm_reg_field get_field_by_name(string name);
      foreach (m_fields[i])
         if (m_fields[i].get_name() == name)
            return m_fields[i];
      `uvm_warning("RegModel", {"Unable to locate field '",name, "' in register '",get_name(),"'"})
      return null;
   endfunction
   
   virtual function string Xget_fields_accessX(uvm_reg_map map);
      bit is_R;
      bit is_W;
      
      foreach(m_fields[i]) begin
         case (m_fields[i].get_access(map))
          "RO", "RC", "RS": is_R = 1;
          
          "WO", "WOC", "WOS", "WO1": is_W = 1;
          
          default:
             return "RW";
         endcase
         
         if (is_R && is_W) return "RW";
      end
   
      case ({is_R, is_W})
       2'b01: return "WO";
       2'b10: return "RO";
      endcase
      return "RW";
   endfunction
   
   static function void include_coverage(string scope, uvm_reg_cvr_t models, uvm_object accessor = null);
   uvm_reg_cvr_rsrc_db::set({"", scope}, "include_coverage", models, accessor);
   endfunction

   protected function uvm_reg_cvr_t build_coverage(uvm_reg_cvr_t models);
      build_coverage = UVM_NO_COVERAGE;
      void'(uvm_reg_cvr_rsrc_db::read_by_name({"", get_full_name()}, "include_coverage", build_coverage, this));
      return build_coverage & models;
   endfunction: build_coverage
   
   virtual function void add_coverage(uvm_reg_cvr_t models);
      m_has_cover |= models;
   endfunction: add_coverage
   
   virtual function bit has_coverage(uvm_reg_cvr_t models);
      return ((m_has_cover & models) == models);
   endfunction: has_coverage
   
   virtual function uvm_reg_cvr_t set_coverage(uvm_reg_cvr_t is_on);
      if (is_on == uvm_reg_cvr_t'(UVM_NO_COVERAGE)) begin
         m_cover_on = is_on;
         return m_cover_on;
      end
   
      m_cover_on = m_has_cover & is_on;
   
      return m_cover_on;
   endfunction: set_coverage
   
   virtual function bit get_coverage(uvm_reg_cvr_t is_on);
      if (has_coverage(is_on) == 0)
         return 0;
      return ((m_cover_on & is_on) == is_on);
   endfunction: get_coverage
   
   virtual function void set(uvm_reg_data_t  value, string          fname = "", int             lineno = 0);
      m_fname = fname;
      m_lineno = lineno;
   
      foreach (m_fields[i])
         m_fields[i].set((value >> m_fields[i].get_lsb_pos()) & ((1 << m_fields[i].get_n_bits()) - 1));
   endfunction: set
   
   virtual function bit predict (uvm_reg_data_t    value, uvm_reg_byte_en_t be = -1, uvm_predict_e     kind = UVM_PREDICT_DIRECT, uvm_path_e        path = UVM_FRONTDOOR, uvm_reg_map       map = null, string            fname = "", int               lineno = 0);
     uvm_reg_item rw = new;
     rw.value[0] = value;
     rw.path = path;
     rw.map = map;
     rw.fname = fname;
     rw.lineno = lineno;
     do_predict(rw, kind, be);
     predict = (rw.status == UVM_NOT_OK) ? 0 : 1;
   endfunction: predict
   
   virtual function void do_predict(uvm_reg_item      rw, uvm_predict_e     kind = UVM_PREDICT_DIRECT, uvm_reg_byte_en_t be = -1);
   
      uvm_reg_data_t reg_value = rw.value[0];
      m_fname = rw.fname;
      m_lineno = rw.lineno;
      
   if (rw.status ==UVM_IS_OK )
      rw.status = UVM_IS_OK;
   
      if (m_is_busy && kind == UVM_PREDICT_DIRECT) begin `uvm_warning("RegModel", {"Trying to predict value of register '", get_full_name(),"' while it is being accessed"})
         rw.status = UVM_NOT_OK;
         return;
      end
      
      foreach (m_fields[i]) begin
         rw.value[0] = (reg_value >> m_fields[i].get_lsb_pos()) & ((1 << m_fields[i].get_n_bits())-1);
         m_fields[i].do_predict(rw, kind, be>>(m_fields[i].get_lsb_pos()/8));
      end
   
      rw.value[0] = reg_value;
   
   endfunction: do_predict
   
   virtual function uvm_reg_data_t  get(string  fname = "", int     lineno = 0);
      m_fname = fname;
      m_lineno = lineno;
   
      get = 0;
      
      foreach (m_fields[i])
         get |= m_fields[i].get() << m_fields[i].get_lsb_pos();
   endfunction: get
   
   virtual function uvm_reg_data_t  get_mirrored_value(string  fname = "", int     lineno = 0);
      m_fname = fname;
      m_lineno = lineno;
   
      get_mirrored_value = 0;
      
      foreach (m_fields[i])
         get_mirrored_value |= m_fields[i].get_mirrored_value() << m_fields[i].get_lsb_pos();
   endfunction: get_mirrored_value
   
   virtual function void reset(string kind = "HARD");
      foreach (m_fields[i])
         m_fields[i].reset(kind);
      void'(m_atomic.try_get(1));
      m_atomic.put(1);
      m_process = null;
      Xset_busyX(0);
   endfunction: reset
   
   virtual function uvm_reg_data_t get_reset(string kind = "HARD");
      get_reset = 0;
      
      foreach (m_fields[i])
         get_reset |= m_fields[i].get_reset(kind) << m_fields[i].get_lsb_pos();
   endfunction: get_reset
   
   virtual function bit has_reset(string kind = "HARD", bit    delete = 0);
   
      has_reset = 0;
      foreach (m_fields[i]) begin
         has_reset |= m_fields[i].has_reset(kind, delete);
         if (!delete && has_reset)
           return 1;
      end
   endfunction: has_reset
   
   virtual function void set_reset(uvm_reg_data_t value, string         kind = "HARD");
      foreach (m_fields[i]) begin
         m_fields[i].set_reset(value >> m_fields[i].get_lsb_pos(), kind);
      end
   endfunction: set_reset

   virtual function bit needs_update();
      needs_update = 0;
      foreach (m_fields[i]) begin
         if (m_fields[i].needs_update()) begin
            return 1;
         end
      end
   endfunction: needs_update
   
   virtual task update(output uvm_status_e      status, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  uvm_sequence_base parent = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      uvm_reg_data_t upd;
   
      status = UVM_IS_OK;
   
      if (!needs_update()) return;
   
      upd = 0;
      foreach (m_fields[i])
         upd |= m_fields[i].XupdateX() << m_fields[i].get_lsb_pos();
   
      write(status, upd, path, map, parent, prior, extension, fname, lineno);
   endtask: update
   
   
   virtual task write(output uvm_status_e      status, input  uvm_reg_data_t    value, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  uvm_sequence_base parent = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
   
      uvm_reg_item rw;
   
      XatomicX(1);
   
      set(value);
   
      rw = uvm_reg_item::type_id::create("write_item",,get_full_name());
      rw.element      = this;
      rw.element_kind = UVM_REG;
      rw.kind         = UVM_WRITE;
      rw.value[0]     = value;
      rw.path         = path;
      rw.map          = map;
      rw.parent       = parent;
      rw.prior        = prior;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      do_write(rw);
   
      status = rw.status;
   
      XatomicX(0);
   
   endtask
   
   virtual task do_write (uvm_reg_item rw);
   
      uvm_reg_cb_iter  cbs = new(this);
      uvm_reg_map_info map_info;
      uvm_reg_data_t   value; 
   
      m_fname  = rw.fname;
      m_lineno = rw.lineno;
   
      if (!Xcheck_accessX(rw,map_info,"write()"))
        return;
   
      XatomicX(1);
   
      m_write_in_progress = 1'b1;
   
      rw.value[0] &= ((1 << m_n_bits)-1);
      value = rw.value[0];
   
      rw.status = UVM_IS_OK;
   
      begin : pre_write_callbacks
         uvm_reg_data_t  msk;
         int lsb;
   
         foreach (m_fields[i]) begin
            uvm_reg_field_cb_iter cbs = new(m_fields[i]);
            uvm_reg_field f = m_fields[i];
            lsb = f.get_lsb_pos();
            msk = ((1<<f.get_n_bits())-1) << lsb;
            rw.value[0] = (value & msk) >> lsb;
            f.pre_write(rw);
            for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next()) begin
               rw.element = f;
               rw.element_kind = UVM_FIELD;
               cb.pre_write(rw);
            end
   
            value = (value & ~msk) | (rw.value[0] << lsb);
         end
      end
      rw.element = this;
      rw.element_kind = UVM_REG;
      rw.value[0] = value;
   
      pre_write(rw);
      for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
         cb.pre_write(rw);
   
      if (rw.status != UVM_IS_OK) begin
        m_write_in_progress = 1'b0;
   
        XatomicX(0);
            
        return;
      end
            
      case (rw.path)
         
         UVM_BACKDOOR: begin
            uvm_reg_data_t final_val;
            uvm_reg_backdoor bkdr = get_backdoor();
   
            value = rw.value[0];
   
            rw.kind = UVM_READ;
            if (bkdr != null)
              bkdr.read(rw);
            else
              backdoor_read(rw);
   
            if (rw.status == UVM_NOT_OK) begin
              m_write_in_progress = 1'b0;
              return;
            end
   
            begin
               foreach (m_fields[i]) begin
                  uvm_reg_data_t field_val;
                  int lsb = m_fields[i].get_lsb_pos();
                  int sz  = m_fields[i].get_n_bits();
                  field_val = m_fields[i].XpredictX((rw.value[0] >> lsb) & ((1<<sz)-1), (value >> lsb) & ((1<<sz)-1), rw.local_map);
                  final_val |= field_val << lsb;
               end
            end
            rw.kind = UVM_WRITE;
            rw.value[0] = final_val;
   
            if (bkdr != null)
              bkdr.write(rw);
            else
              backdoor_write(rw);
   
            do_predict(rw, UVM_PREDICT_WRITE);
         end
   
         UVM_FRONTDOOR: begin
   
            uvm_reg_map system_map = rw.local_map.get_root_map();
   
            m_is_busy = 1;
   
            if (map_info.frontdoor != null) begin
               uvm_reg_frontdoor fd = map_info.frontdoor;
               fd.rw_info = rw;
               if (fd.sequencer == null)
                 fd.sequencer = system_map.get_sequencer();
               fd.start(fd.sequencer, rw.parent);
            end
   
            else begin : built_in_frontdoor
   
               rw.local_map.do_write(rw);
   
            end
   
            m_is_busy = 0;
   
            if (system_map.get_auto_predict()) begin
               uvm_status_e status;
               if (rw.status != UVM_NOT_OK) begin
                  sample(value, -1, 0, rw.map);
                  m_parent.XsampleX(map_info.offset, 0, rw.map);
               end
   
               status = rw.status; 
               do_predict(rw, UVM_PREDICT_WRITE);
               rw.status = status;
            end
         end
         
      endcase
   
      value = rw.value[0];
   
      for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
         cb.post_write(rw);
      post_write(rw);
   
      foreach (m_fields[i]) begin
         uvm_reg_field_cb_iter cbs = new(m_fields[i]);
         uvm_reg_field f = m_fields[i];
         
         rw.element = f;
         rw.element_kind = UVM_FIELD;
         rw.value[0] = (value >> f.get_lsb_pos()) & ((1<<f.get_n_bits())-1);
         
         for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
            cb.post_write(rw);
         f.post_write(rw);
      end
      
      rw.value[0] = value;
      rw.element = this;
      rw.element_kind = UVM_REG;
   
      if (uvm_report_enabled(UVM_HIGH, UVM_INFO, "RegModel")) begin
        string path_s,value_s;
        if (rw.path == UVM_FRONTDOOR)
          path_s = (map_info.frontdoor != null) ? "user frontdoor" : {"map ",rw.map.get_full_name()};
        else
          path_s = (get_backdoor() != null) ? "user backdoor" : "DPI backdoor";
   
        value_s = $sformatf("=0x%0h",rw.value[0]);
   
         uvm_report_info("RegModel", {"Wrote register via ",path_s,": ", get_full_name(),value_s}, UVM_HIGH);
      end
   
      m_write_in_progress = 1'b0;
   
      XatomicX(0);
   
   endtask: do_write
   
   virtual task read(output uvm_status_e      status, output uvm_reg_data_t    value, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  uvm_sequence_base parent = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      XatomicX(1);
      XreadX(status, value, path, map, parent, prior, extension, fname, lineno);
      XatomicX(0);
   endtask: read
   
   virtual task XreadX(output uvm_status_e      status, output uvm_reg_data_t    value, input  uvm_path_e        path, input  uvm_reg_map       map, input  uvm_sequence_base parent = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      
      uvm_reg_item rw;
      rw = uvm_reg_item::type_id::create("read_item",,get_full_name());
      rw.element      = this;
      rw.element_kind = UVM_REG;
      rw.kind         = UVM_READ;
      rw.value[0]     = 0;
      rw.path         = path;
      rw.map          = map;
      rw.parent       = parent;
      rw.prior        = prior;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      do_read(rw);
   
      status = rw.status;
      value = rw.value[0];
   
   endtask: XreadX
   
   virtual task do_read(uvm_reg_item rw);
   
      uvm_reg_cb_iter  cbs = new(this);
      uvm_reg_map_info map_info;
      uvm_reg_data_t   value;
      uvm_reg_data_t   exp;
   
      m_fname   = rw.fname;
      m_lineno  = rw.lineno;
      
      if (!Xcheck_accessX(rw,map_info,"read()"))
        return;
   
      m_read_in_progress = 1'b1;
   
      rw.status = UVM_IS_OK;
   
      foreach (m_fields[i]) begin
         uvm_reg_field_cb_iter cbs = new(m_fields[i]);
         uvm_reg_field f = m_fields[i];
         rw.element = f;
         rw.element_kind = UVM_FIELD;
         m_fields[i].pre_read(rw);
         for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
            cb.pre_read(rw);
      end
   
      rw.element = this;
      rw.element_kind = UVM_REG;
   
      pre_read(rw);
      for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
         cb.pre_read(rw);
   
      if (rw.status != UVM_IS_OK) begin
        m_read_in_progress = 1'b0;
   
        return;
      end
            
      case (rw.path)
         
         UVM_BACKDOOR: begin
            uvm_reg_backdoor bkdr = get_backdoor();
   
            uvm_reg_map map = uvm_reg_map::backdoor();
            if (map.get_check_on_read()) exp = get();
      
            if (bkdr != null)
              bkdr.read(rw);
            else
              backdoor_read(rw);
   
            value = rw.value[0];
   
            if (rw.status != UVM_NOT_OK) begin
   
               uvm_reg_data_t wo_mask;
   
               foreach (m_fields[i]) begin
                  string acc = m_fields[i].get_access(uvm_reg_map::backdoor());
                  if (acc == "RC" || acc == "WRC" || acc == "WSRC" || acc == "W1SRC" || acc == "W0SRC") begin
                     value &= ~(((1<<m_fields[i].get_n_bits())-1) << m_fields[i].get_lsb_pos());
                  end
                  else if (acc == "RS" || acc == "WRS" || acc == "WCRS" || acc == "W1CRS" || acc == "W0CRS") begin
                     value |= (((1<<m_fields[i].get_n_bits())-1) << m_fields[i].get_lsb_pos());
                  end
                  else if (acc == "WO" || acc == "WOC" || acc == "WOS" || acc == "WO1") begin
                     wo_mask |= ((1<<m_fields[i].get_n_bits())-1) << m_fields[i].get_lsb_pos();
                  end
               end
   
               if (value != rw.value[0]) begin
                 uvm_reg_data_t saved;
                 saved = rw.value[0];
                 rw.value[0] = value;
                 if (bkdr != null)
                    bkdr.write(rw);
                 else
                    backdoor_write(rw);
                 rw.value[0] = saved;
               end
   
               rw.value[0] &= ~wo_mask;
   
               if (map.get_check_on_read() &&
                  rw.status != UVM_NOT_OK) begin
                  void'(do_check(exp, rw.value[0], map));
               end
          
               do_predict(rw, UVM_PREDICT_READ);
            end
         end
   
   
         UVM_FRONTDOOR: begin
   
            uvm_reg_map system_map = rw.local_map.get_root_map();
   
            m_is_busy = 1;
   
            if (rw.local_map.get_check_on_read()) exp = get();
      
            if (map_info.frontdoor != null) begin
               uvm_reg_frontdoor fd = map_info.frontdoor;
               fd.rw_info = rw;
               if (fd.sequencer == null)
                 fd.sequencer = system_map.get_sequencer();
               fd.start(fd.sequencer, rw.parent);
            end
   
            else begin
               rw.local_map.do_read(rw);
            end
   
            m_is_busy = 0;
   
            if (system_map.get_auto_predict()) begin
               uvm_status_e status;
               if (rw.local_map.get_check_on_read() &&
                   rw.status != UVM_NOT_OK) begin
                  void'(do_check(exp, rw.value[0], system_map));
               end
   
               if (rw.status != UVM_NOT_OK) begin
                  sample(rw.value[0], -1, 1, rw.map);
                  m_parent.XsampleX(map_info.offset, 1, rw.map);
               end
   
               status = rw.status; 
               do_predict(rw, UVM_PREDICT_READ);
               rw.status = status;
            end
         end
         
      endcase
   
      value = rw.value[0];  
   
      for (uvm_reg_cbs cb = cbs.first(); cb != null; cb = cbs.next())
         cb.post_read(rw);
      post_read(rw);
   
      foreach (m_fields[i]) begin
         uvm_reg_field_cb_iter cbs = new(m_fields[i]);
         uvm_reg_field f = m_fields[i];
   
         rw.element = f;
         rw.element_kind = UVM_FIELD;
         rw.value[0] = (value >> f.get_lsb_pos()) & ((1<<f.get_n_bits())-1);
   
         for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
            cb.post_read(rw);
         f.post_read(rw);
      end
   
      rw.value[0] = value; 
      rw.element = this;
      rw.element_kind = UVM_REG;
   
      if (uvm_report_enabled(UVM_HIGH, UVM_INFO, "RegModel")) begin
        string path_s,value_s;
        if (rw.path == UVM_FRONTDOOR)
          path_s = (map_info.frontdoor != null) ? "user frontdoor" : {"map ",rw.map.get_full_name()};
        else
          path_s = (get_backdoor() != null) ? "user backdoor" : "DPI backdoor";
   
        value_s = $sformatf("=%0h",rw.value[0]);
   
         uvm_report_info("RegModel", {"Read  register via ",path_s,": ", get_full_name(),value_s}, UVM_HIGH);
      end
   
      m_read_in_progress = 1'b0;
   
   endtask: do_read
   
   virtual function bit Xcheck_accessX (input uvm_reg_item rw, output uvm_reg_map_info map_info, input string caller);
   
   
      if (rw.path == UVM_DEFAULT_PATH)
        rw.path = m_parent.get_default_path();
   
      if (rw.path == UVM_BACKDOOR) begin
         if (get_backdoor() == null && !has_hdl_path()) begin
            `uvm_warning("RegModel", {"No backdoor access available for register '",get_full_name(), "' . Using frontdoor instead."}) rw.path = UVM_FRONTDOOR;
         end
         else
           rw.map = uvm_reg_map::backdoor();
      end
   
   
      if (rw.path != UVM_BACKDOOR) begin
   
        rw.local_map = get_local_map(rw.map,caller);
   
        if (rw.local_map == null) begin
           `uvm_error(get_type_name(), {"No transactor available to physically access register on map '", rw.map.get_full_name(),"'"}) rw.status = UVM_NOT_OK;
           return 0;
        end
   
        map_info = rw.local_map.get_reg_map_info(this);
   
        if (map_info.frontdoor == null && map_info.unmapped) begin
             `uvm_error("RegModel", {"Register '",get_full_name(), "' unmapped in map '", (rw.map==null)? rw.local_map.get_full_name():rw.map.get_full_name(), "' and does not have a user-defined frontdoor"}) rw.status = UVM_NOT_OK;
             return 0;
        end
   
        if (rw.map == null)
          rw.map = rw.local_map;
      end
      return 1;
   endfunction
   
   virtual function bit is_busy();
      return m_is_busy;
   endfunction
   
   virtual function void Xset_busyX(bit busy);
      m_is_busy = busy;
   endfunction
   
   virtual function bit Xis_locked_by_fieldX();
     return m_is_locked_by_field;
   endfunction
   
   virtual task  backdoor_write(uvm_reg_item rw);
     uvm_hdl_path_concat paths[$];
     bit ok=1;
     get_full_hdl_path(paths,rw.bd_kind);
     foreach (paths[i]) begin
        uvm_hdl_path_concat hdl_concat = paths[i];
        foreach (hdl_concat.slices[j]) begin
           `uvm_info("RegMem", {"backdoor_write to ", hdl_concat.slices[j].path},UVM_DEBUG)
   
           if (hdl_concat.slices[j].offset < 0) begin
              ok &= uvm_hdl_deposit(hdl_concat.slices[j].path,rw.value[0]);
              continue;
           end
           begin
              uvm_reg_data_t slice;
              slice = rw.value[0] >> hdl_concat.slices[j].offset;
              slice &= (1 << hdl_concat.slices[j].size)-1;
              ok &= uvm_hdl_deposit(hdl_concat.slices[j].path, slice);
           end
        end
     end
     rw.status = (ok ? UVM_IS_OK : UVM_NOT_OK);
   endtask
   
   virtual task  backdoor_read (uvm_reg_item rw);
     rw.status = backdoor_read_func(rw);
   endtask
   
   virtual function uvm_status_e backdoor_read_func(uvm_reg_item rw);
     uvm_hdl_path_concat paths[$];
     uvm_reg_data_t val;
     bit ok=1;
     get_full_hdl_path(paths,rw.bd_kind);
     foreach (paths[i]) begin
        uvm_hdl_path_concat hdl_concat = paths[i];
        val = 0;
        foreach (hdl_concat.slices[j]) begin
           `uvm_info("RegMem", {"backdoor_read from %s ", hdl_concat.slices[j].path},UVM_DEBUG)
   
           if (hdl_concat.slices[j].offset < 0) begin
              ok &= uvm_hdl_read(hdl_concat.slices[j].path,val);
              continue;
           end
           begin
              uvm_reg_data_t slice;
              int k = hdl_concat.slices[j].offset;
              
              ok &= uvm_hdl_read(hdl_concat.slices[j].path, slice);
         
              repeat (hdl_concat.slices[j].size) begin
                 val[k++] = slice[0];
                 slice >>= 1;
              end
           end
        end
   
        val &= (1 << m_n_bits)-1;
   
        if (i == 0)
           rw.value[0] = val;
   
        if (val != rw.value[0]) begin
           `uvm_error("RegModel", $sformatf("Backdoor read of register %s with multiple HDL copies: values are not the same: %0h at path '%s', and %0h at path '%s'. Returning first value.", get_full_name(), rw.value[0], uvm_hdl_concat2string(paths[0]), val, uvm_hdl_concat2string(paths[i]))); 
           return UVM_NOT_OK;
         end
         `uvm_info("RegMem", $sformatf("returned backdoor value 0x%0x",rw.value[0]),UVM_DEBUG);
         
     end
   
     rw.status = (ok) ? UVM_IS_OK : UVM_NOT_OK;
     return rw.status;
   endfunction
   
   virtual task poke(output uvm_status_e      status, input  uvm_reg_data_t    value, input  string            kind = "", input  uvm_sequence_base parent = null, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
   
      uvm_reg_backdoor bkdr = get_backdoor();
      uvm_reg_item rw;
   
      m_fname = fname;
      m_lineno = lineno;
   
   
      if (bkdr == null && !has_hdl_path(kind)) begin
         `uvm_error("RegModel", {"No backdoor access available to poke register '",get_full_name(),"'"})
         status = UVM_NOT_OK;
         return;
      end
   
      if (!m_is_locked_by_field)
        XatomicX(1);
   
      rw = uvm_reg_item::type_id::create("reg_poke_item",,get_full_name());
      rw.element      = this;
      rw.path         = UVM_BACKDOOR;
      rw.element_kind = UVM_REG;
      rw.kind         = UVM_WRITE;
      rw.bd_kind      = kind;
      rw.value[0]     = value & ((1 << m_n_bits)-1);
      rw.parent       = parent;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      if (bkdr != null)
        bkdr.write(rw);
      else
        backdoor_write(rw);
   
      status = rw.status;
   
      `uvm_info("RegModel", $sformatf("Poked register \"%s\": 'h%h", get_full_name(), value),UVM_HIGH);
   
      do_predict(rw, UVM_PREDICT_WRITE);
   
      if (!m_is_locked_by_field)
        XatomicX(0);
   endtask: poke
   
   virtual task peek(output uvm_status_e      status,
                      output uvm_reg_data_t    value,
                      input  string            kind = "",
                      input  uvm_sequence_base parent = null,
                      input  uvm_object        extension = null,
                      input  string            fname = "",
                      input  int               lineno = 0);
   
      uvm_reg_backdoor bkdr = get_backdoor();
      uvm_reg_item rw;
   
      m_fname = fname;
      m_lineno = lineno;
   
      if (bkdr == null && !has_hdl_path(kind)) begin
         `uvm_error("RegModel", $sformatf("No backdoor access available to peek register \"%s\"", get_full_name()));
         status = UVM_NOT_OK;
         return;
      end
   
      if(!m_is_locked_by_field)
         XatomicX(1);
   
      rw = uvm_reg_item::type_id::create("mem_peek_item",,get_full_name());
      rw.element      = this;
      rw.path         = UVM_BACKDOOR;
      rw.element_kind = UVM_REG;
      rw.kind         = UVM_READ;
      rw.bd_kind      = kind;
      rw.parent       = parent;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      if (bkdr != null)
        bkdr.read(rw);
      else
        backdoor_read(rw);
   
      status = rw.status;
      value = rw.value[0];
   
      `uvm_info("RegModel", $sformatf("Peeked register \"%s\": 'h%h", get_full_name(), value),UVM_HIGH);
   
      do_predict(rw, UVM_PREDICT_READ);
   
      if (!m_is_locked_by_field)
         XatomicX(0);
   endtask: peek
   
   virtual function bit do_check(input uvm_reg_data_t expected,
                                  input uvm_reg_data_t actual,
                                  uvm_reg_map          map);
   
      uvm_reg_data_t  dc = 0;
   
      foreach(m_fields[i]) begin
         string acc = m_fields[i].get_access(map);
         acc = acc.substr(0, 1);
         if (m_fields[i].get_compare() == UVM_NO_CHECK || acc == "WO") begin
            dc |= ((1 << m_fields[i].get_n_bits())-1) << m_fields[i].get_lsb_pos();
         end
      end
   
      if ((actual|dc) === (expected|dc)) return 1;
      
      `uvm_error("RegModel", $sformatf("Register \"%s\" value read from DUT (0x%h) does not match mirrored value (0x%h)", get_full_name(), actual, (expected ^ ('x & dc))));
                                        
      foreach(m_fields[i]) begin
         string acc = m_fields[i].get_access(map);
         acc = acc.substr(0, 1);
         if (!(m_fields[i].get_compare() == UVM_NO_CHECK || acc == "WO")) begin
            uvm_reg_data_t mask  = ((1 << m_fields[i].get_n_bits())-1);
            uvm_reg_data_t val   = actual   >> m_fields[i].get_lsb_pos() & mask;
            uvm_reg_data_t exp   = expected >> m_fields[i].get_lsb_pos() & mask;
   
            if (val !== exp) begin
               `uvm_info("RegModel", $sformatf("Field %s (%s[%0d:%0d]) mismatch read=%0d'h%0h mirrored=%0d'h%0h ", m_fields[i].get_name(), get_full_name(), m_fields[i].get_lsb_pos() + m_fields[i].get_n_bits() - 1, m_fields[i].get_lsb_pos(), m_fields[i].get_n_bits(), val, m_fields[i].get_n_bits(), exp), UVM_NONE)
            end
         end
      end
   
      return 0;
   endfunction
   
   virtual task mirror(output uvm_status_e       status, input  uvm_check_e        check = UVM_NO_CHECK, input  uvm_path_e         path = UVM_DEFAULT_PATH, input  uvm_reg_map        map = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_reg_data_t  v;
      uvm_reg_data_t  exp;
      uvm_reg_backdoor bkdr = get_backdoor();
   
      XatomicX(1);
      m_fname = fname;
      m_lineno = lineno;
   
   
      if (path == UVM_DEFAULT_PATH)
        path = m_parent.get_default_path();
   
      if (path == UVM_BACKDOOR && (bkdr != null || has_hdl_path()))
        map = uvm_reg_map::backdoor();
      else
        map = get_local_map(map, "read()");
   
      if (map == null)
        return;
      
      if (check == UVM_CHECK)
        exp = get_mirrored_value();
   
      XreadX(status, v, path, map, parent, prior, extension, fname, lineno);
   
      if (status == UVM_NOT_OK) begin
         XatomicX(0);
         return;
      end
   
      if (check == UVM_CHECK) void'(do_check(exp, v, map));
   
      XatomicX(0);
   endtask: mirror
   
   task XatomicX(bit on);
      process m_reg_process;
      m_reg_process=process::self();
   
      if (on) begin
        if (m_reg_process == m_process)
          return;
        m_atomic.get(1);
        m_process = m_reg_process; 
      end
      else begin
         void'(m_atomic.try_get(1));
         m_atomic.put(1);
         m_process = null;
      end
   endtask: XatomicX
   
   virtual function string convert2string();
      string res_str;
      string t_str;
      bit with_debug_info;
   
      string prefix;
   
      $sformat(convert2string, "Register %s -- %0d bytes, mirror value:'h%h", get_full_name(), get_n_bytes(),get());
   
      if (m_maps.num()==0)
        convert2string = {convert2string, "  (unmapped)\n"};
      else
        convert2string = {convert2string, "\n"};
      foreach (m_maps[map]) begin
        uvm_reg_map parent_map = map;
        int unsigned offset;
        while (parent_map != null) begin
          uvm_reg_map this_map = parent_map;
          parent_map = this_map.get_parent_map();
          offset = parent_map == null ? this_map.get_base_addr(UVM_NO_HIER) : parent_map.get_submap_offset(this_map);
          prefix = {prefix, "  "};
          begin
               uvm_endianness_e e = this_map.get_endian();
               $sformat(convert2string, "%sMapped in '%s' -- %d bytes, %s, offset 'h%0h\n", prefix, this_map.get_full_name(), this_map.get_n_bytes(), e.name(), offset);
          end
        end
      end
      prefix = "  ";
      foreach(m_fields[i]) begin
         $sformat(convert2string, "%s\n%s", convert2string, m_fields[i].convert2string());
      end
   
      if (m_read_in_progress == 1'b1) begin
         if (m_fname != "" && m_lineno != 0)
            $sformat(res_str, "%s:%0d ",m_fname, m_lineno);
         convert2string = {convert2string, "\n", res_str, "currently executing read method"}; 
      end
      if ( m_write_in_progress == 1'b1) begin
         if (m_fname != "" && m_lineno != 0)
            $sformat(res_str, "%s:%0d ",m_fname, m_lineno);
         convert2string = {convert2string, "\n", res_str, "currently executing write method"}; 
      end
   
   endfunction: convert2string
   
   virtual function void do_print (uvm_printer printer);
     uvm_reg_field f[$];
     super.do_print(printer);
     get_fields(f);
     foreach(f[i]) printer.print_generic(f[i].get_name(),f[i].get_type_name(),-2,f[i].convert2string());
   endfunction
   
   virtual function uvm_object clone();
     `uvm_fatal("RegModel","RegModel registers cannot be cloned")
     return null;
   endfunction
   
   virtual function void do_copy(uvm_object rhs);
     `uvm_fatal("RegModel","RegModel registers cannot be copied")
   endfunction
   
   virtual function bit do_compare (uvm_object  rhs, uvm_comparer comparer);
     `uvm_warning("RegModel","RegModel registers cannot be compared")
     return 0;
   endfunction
   
   virtual function void do_pack (uvm_packer packer);
     `uvm_warning("RegModel","RegModel registers cannot be packed")
   endfunction
   
   virtual function void do_unpack (uvm_packer packer);
     `uvm_warning("RegModel","RegModel registers cannot be unpacked")
   endfunction

endclass: uvm_reg

typedef class uvm_reg_indirect_ftdr_seq;

class uvm_reg_indirect_data extends uvm_reg;

   protected uvm_reg m_idx;
   protected uvm_reg m_tbl[];

   function new(string name = "uvm_reg_indirect", int unsigned n_bits, int has_cover);
      super.new(name,n_bits,has_cover);
   endfunction: new

   virtual function void build();
   endfunction: build

   function void configure (uvm_reg idx, uvm_reg reg_a[], uvm_reg_block blk_parent, uvm_reg_file regfile_parent = null);
      super.configure(blk_parent, regfile_parent, "");
      m_idx = idx;
      m_tbl = reg_a;

      uvm_resource_db#(bit)::set({"REG::", get_full_name()}, "NO_REG_TESTS", 1);

      foreach (m_maps[map]) begin
         add_frontdoors(map);
      end
   endfunction
   
    virtual function void add_map(uvm_reg_map map);
      super.add_map(map);
      add_frontdoors(map);
   endfunction
   
   local function void add_frontdoors(uvm_reg_map map);
      foreach (m_tbl[i]) begin
         uvm_reg_indirect_ftdr_seq fd;
         if (m_tbl[i] == null) begin
            `uvm_error(get_full_name(), $sformatf("Indirect register #%0d is NULL", i));
            continue;
         end
         fd = new(m_idx, i, this);
         if (m_tbl[i].is_in_map(map))
            m_tbl[i].set_frontdoor(fd, map);
         else
            map.add_reg(m_tbl[i], -1, "RW", 1, fd);
      end
   endfunction
   
   virtual function void do_predict (uvm_reg_item      rw, uvm_predict_e     kind = UVM_PREDICT_DIRECT, uvm_reg_byte_en_t be = -1);
      if (m_idx.get() >= m_tbl.size()) begin
         `uvm_error(get_full_name(), $sformatf("Address register %s has a value (%0d) greater than the maximum indirect register array size (%0d)", m_idx.get_full_name(), m_idx.get(), m_tbl.size()));
         rw.status = UVM_NOT_OK;
         return;
      end

      begin
         int unsigned idx = m_idx.get();
         m_tbl[idx].do_predict(rw, kind, be);
      end
   endfunction

   virtual function uvm_reg_map get_local_map(uvm_reg_map map, string caller="");
      return  m_idx.get_local_map(map,caller);
   endfunction

   virtual function void add_field  (uvm_reg_field field);
      `uvm_error(get_full_name(), "Cannot add field to an indirect data access register");
   endfunction

   virtual function void set (uvm_reg_data_t  value, string          fname = "", int             lineno = 0);
      `uvm_error(get_full_name(), "Cannot set() an indirect data access register");
   endfunction
   
   virtual function uvm_reg_data_t  get(string  fname = "", int     lineno = 0);
      `uvm_error(get_full_name(), "Cannot get() an indirect data access register");
      return 0;
   endfunction
   
   virtual function uvm_reg get_indirect_reg(string  fname = "", int     lineno = 0);
      int unsigned idx = m_idx.get_mirrored_value();
      return(m_tbl[idx]);
   endfunction

   virtual function bit needs_update();
      return 0;
   endfunction

   virtual task write(output uvm_status_e      status, input  uvm_reg_data_t    value, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  uvm_sequence_base parent = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);

      if (path == UVM_DEFAULT_PATH) begin
         uvm_reg_block blk = get_parent();
         path = blk.get_default_path();
      end
      
      if (path == UVM_BACKDOOR) begin
         `uvm_warning(get_full_name(), "Cannot backdoor-write an indirect data access register. Switching to frontdoor.");
         path = UVM_FRONTDOOR;
      end

      begin
         uvm_reg_item rw;

         XatomicX(1);

         rw = uvm_reg_item::type_id::create("write_item",,get_full_name());
         rw.element      = this;
         rw.element_kind = UVM_REG;
         rw.kind         = UVM_WRITE;
         rw.value[0]     = value;
         rw.path         = path;
         rw.map          = map;
         rw.parent       = parent;
         rw.prior        = prior;
         rw.extension    = extension;
         rw.fname        = fname;
         rw.lineno       = lineno;
         
         do_write(rw);

         status = rw.status;

         XatomicX(0);
      end
   endtask

   virtual task read(output uvm_status_e      status, output uvm_reg_data_t    value, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  uvm_sequence_base parent = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0); 
      if (path == UVM_DEFAULT_PATH) begin
         uvm_reg_block blk = get_parent();
         path = blk.get_default_path();
      end
      
      if (path == UVM_BACKDOOR) begin
         `uvm_warning(get_full_name(), "Cannot backdoor-read an indirect data access register. Switching to frontdoor.");
         path = UVM_FRONTDOOR;
      end
      
      super.read(status, value, path, map, parent, prior, extension, fname, lineno);
   endtask

   virtual task poke(output uvm_status_e      status, input  uvm_reg_data_t    value, input  string            kind = "", input  uvm_sequence_base parent = null, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      `uvm_error(get_full_name(), "Cannot poke() an indirect data access register");
      status = UVM_NOT_OK;
   endtask

   virtual task peek(output uvm_status_e      status, output uvm_reg_data_t    value, input  string            kind = "", input  uvm_sequence_base parent = null, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      `uvm_error(get_full_name(), "Cannot peek() an indirect data access register");
      status = UVM_NOT_OK;
   endtask

   virtual task update(output uvm_status_e      status, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  uvm_sequence_base parent = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      status = UVM_IS_OK;
   endtask
   
   virtual task mirror(output uvm_status_e      status, input uvm_check_e        check  = UVM_NO_CHECK, input uvm_path_e         path = UVM_DEFAULT_PATH, input uvm_reg_map        map = null, input uvm_sequence_base  parent = null, input int                prior = -1, input  uvm_object        extension = null, input string             fname = "", input int                lineno = 0);
      status = UVM_IS_OK;
   endtask
   
endclass : uvm_reg_indirect_data


class uvm_reg_indirect_ftdr_seq extends uvm_reg_frontdoor;
   local uvm_reg m_addr_reg;
   local uvm_reg m_data_reg;
   local int     m_idx;
   
   function new(uvm_reg addr_reg, int idx, uvm_reg data_reg);
      super.new("uvm_reg_indirect_ftdr_seq");
      m_addr_reg = addr_reg;
      m_idx      = idx;
      m_data_reg = data_reg;
   endfunction: new

   virtual task body();

      uvm_reg_item rw;
      
      $cast(rw,rw_info.clone());
      rw.element = m_addr_reg;
      rw.kind    = UVM_WRITE;
      rw.value[0]= m_idx;

      m_addr_reg.XatomicX(1);
      m_data_reg.XatomicX(1);
      
      m_addr_reg.do_write(rw);

      if (rw.status == UVM_NOT_OK)
        return;

      $cast(rw,rw_info.clone());
      rw.element = m_data_reg;

      if (rw_info.kind == UVM_WRITE)
        m_data_reg.do_write(rw);
      else begin
        m_data_reg.do_read(rw);
        rw_info.value[0] = rw.value[0];
      end

      m_addr_reg.XatomicX(0);
      m_data_reg.XatomicX(0);
      
      rw_info.status = rw.status;
   endtask

endclass

class uvm_reg_fifo extends uvm_reg;

    local uvm_reg_field value;
    local int m_set_cnt;
    local int unsigned m_size;

    rand uvm_reg_data_t fifo[$];

    constraint valid_fifo_size {
      fifo.size() <= m_size;
    }

    function new(string name = "reg_fifo", int unsigned size, int unsigned n_bits, int has_cover);
       super.new(name,n_bits,has_cover);
       m_size = size;
    endfunction

    virtual function void build();
        value = uvm_reg_field::type_id::create("value");
        value.configure(this, get_n_bits(), 0, "RW", 0, 32'h0, 1, 0, 1);
    endfunction

    function void set_compare(uvm_check_e check=UVM_CHECK);
       value.set_compare(check);
    endfunction

    function int unsigned size();
      return fifo.size();
    endfunction

    function int unsigned capacity();
      return m_size;
    endfunction

    virtual function void set(uvm_reg_data_t  value, string          fname = "", int             lineno = 0);
      value &= ((1 << get_n_bits())-1);
      if (fifo.size() == m_size) begin
        return;
      end
      super.set(value,fname,lineno);
      m_set_cnt++;
      fifo.push_back(this.value.value);
    endfunction
    
    virtual task update(output uvm_status_e      status, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  uvm_sequence_base parent = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
       uvm_reg_data_t upd;
       if (!m_set_cnt || fifo.size() == 0)
          return;
       m_update_in_progress = 1;
       for (int i=fifo.size()-m_set_cnt; m_set_cnt > 0; i++, m_set_cnt--) begin
         if (i >= 0) begin
            write(status,fifo[i],path,map,parent,prior,extension,fname,lineno);
         end
       end
       m_update_in_progress = 0;
    endtask

    virtual function uvm_reg_data_t get(string fname="", int lineno=0);
       return fifo[0];
    endfunction

    virtual function void do_predict(uvm_reg_item      rw, uvm_predict_e     kind = UVM_PREDICT_DIRECT, uvm_reg_byte_en_t be = -1);

      super.do_predict(rw,kind,be);

      if (rw.status == UVM_NOT_OK)
        return;

      case (kind)

        UVM_PREDICT_WRITE,
        UVM_PREDICT_DIRECT:
        begin
           if (fifo.size() != m_size && !m_update_in_progress)
             fifo.push_back(this.value.value);
        end

        UVM_PREDICT_READ:
        begin
           uvm_reg_data_t value = rw.value[0] & ((1 << get_n_bits())-1);
           uvm_reg_data_t mirror_val;
           if (fifo.size() == 0) begin
             return;
           end
           mirror_val = fifo.pop_front();
           if (this.value.get_compare() == UVM_CHECK && mirror_val != value) begin
              `uvm_warning("MIRROR_MISMATCH", $sformatf("Observed DUT read value 'h%0h != mirror value 'h%0h",value,mirror_val))
           end
        end

      endcase

    endfunction

    virtual task pre_write(uvm_reg_item rw);
      if (m_set_cnt && !m_update_in_progress) begin
        `uvm_error("Needs Update","Must call update() after set() and before write()")
        rw.status = UVM_NOT_OK;
        return;
      end
      if (fifo.size() >= m_size && !m_update_in_progress) begin
        `uvm_error("FIFO Full","Write to full FIFO ignored")
        rw.status = UVM_NOT_OK;
        return;
      end
    endtask

    virtual task pre_read(uvm_reg_item rw);
      if (fifo.size() == 0) begin
        rw.status = UVM_NOT_OK;
        return;
      end
    endtask

    function void post_randomize();
      m_set_cnt = 0;
    endfunction

endclass

virtual class uvm_reg_file extends uvm_object;

   local uvm_reg_block     parent;
   local uvm_reg_file   m_rf;
   local string            default_hdl_path = "RTL";
   local uvm_object_string_pool #(uvm_queue #(string)) hdl_paths_pool;
   
   function new(string name="");
      super.new(name);
      hdl_paths_pool = new("hdl_paths");
   endfunction: new
   
   function void configure(uvm_reg_block blk_parent, uvm_reg_file regfile_parent, string hdl_path = "");
      if (blk_parent == null) begin
        `uvm_error("UVM/RFILE/CFG/NOBLK", {"configure() called without a parent block for instance \"", get_name(), "\" of register file type \"", get_type_name(), "\"."})
        return;
      end
   
      this.parent = blk_parent;
      this.m_rf = regfile_parent;
      this.add_hdl_path(hdl_path);
   endfunction: configure
   
   virtual function uvm_reg_block get_block();
      get_block = this.parent;
   endfunction: get_block
   
   virtual function uvm_reg_file get_regfile();
      return m_rf;
   endfunction
   
   function void clear_hdl_path(string kind = "RTL");
     if (kind == "ALL") begin
       hdl_paths_pool = new("hdl_paths");
       return;
     end
   
     if (kind == "") begin
        if (m_rf != null)
           kind = m_rf.get_default_hdl_path();
        else
           kind = parent.get_default_hdl_path();
     end
   
     if (!hdl_paths_pool.exists(kind)) begin
       `uvm_warning("RegModel",{"Unknown HDL Abstraction '",kind,"'"})
       return;
     end
   
     hdl_paths_pool.delete(kind);
   endfunction
   
   function void add_hdl_path(string path, string kind = "RTL");
   
     uvm_queue #(string) paths;
   
     paths = hdl_paths_pool.get(kind);
   
     paths.push_back(path);
   
   endfunction
   
   function bit  has_hdl_path(string kind = "");
     if (kind == "") begin
        if (m_rf != null)
           kind = m_rf.get_default_hdl_path();
        else
           kind = parent.get_default_hdl_path();
     end
     
     return hdl_paths_pool.exists(kind);
   endfunction
   
   function void get_hdl_path(ref string paths[$], input string kind = "");
   
     uvm_queue #(string) hdl_paths;
   
     if (kind == "") begin
        if (m_rf != null)
           kind = m_rf.get_default_hdl_path();
        else
           kind = parent.get_default_hdl_path();
     end
   
     if (!has_hdl_path(kind)) begin
       `uvm_error("RegModel",{"Register does not have hdl path defined for abstraction '",kind,"'"})
       return;
     end
   
     hdl_paths = hdl_paths_pool.get(kind);
   
     for (int i=0; i<hdl_paths.size();i++)
       paths.push_back(hdl_paths.get(i));
   
   endfunction
   
   function void get_full_hdl_path(ref string paths[$], input string kind = "", input string separator = ".");
      if (kind == "")
         kind = get_default_hdl_path();
   
      if (!has_hdl_path(kind)) begin
         `uvm_error("RegModel",{"Register file does not have hdl path defined for abstraction '",kind,"'"})
         return;
      end
      
      paths.delete();
   
      begin
         uvm_queue #(string) hdl_paths = hdl_paths_pool.get(kind);
         string parent_paths[$];
   
         if (m_rf != null)
            m_rf.get_full_hdl_path(parent_paths, kind, separator);
         else if (parent != null)
            parent.get_full_hdl_path(parent_paths, kind, separator);
   
         for (int i=0; i<hdl_paths.size();i++) begin
            string hdl_path = hdl_paths.get(i);
   
            if (parent_paths.size() == 0) begin
               if (hdl_path != "")
                  paths.push_back(hdl_path);
   
               continue;
            end
            
            foreach (parent_paths[j])  begin
               if (hdl_path == "")
                  paths.push_back(parent_paths[j]);
               else
                  paths.push_back({ parent_paths[j], separator, hdl_path });
            end
         end
      end
   
   endfunction
   
   function string get_default_hdl_path();
     if (default_hdl_path == "") begin
        if (m_rf != null)
           return m_rf.get_default_hdl_path();
        else
           return parent.get_default_hdl_path();
     end
     return default_hdl_path;
   endfunction
   
   function void set_default_hdl_path(string kind);
   
     if (kind == "") begin
       if (m_rf != null)
          kind = m_rf.get_default_hdl_path();
       else if (parent == null)
          kind = parent.get_default_hdl_path();
       else begin
         `uvm_error("RegModel",{"Register file has no parent. ", "Must specify a valid HDL abstraction (kind)"})
         return;
       end
     end
   
     default_hdl_path = kind;
   
   endfunction
   
   virtual function uvm_reg_block get_parent();
     return get_block();
   endfunction
   
   virtual function string get_full_name();
      uvm_reg_block blk;
   
      get_full_name = this.get_name();
   
      if (m_rf != null)
         return {m_rf.get_full_name(), ".", get_full_name};
   
      if (this.parent == null)
         return get_full_name;
      get_full_name = {this.parent.get_full_name(), ".", get_full_name};
   endfunction: get_full_name
   
   virtual function string convert2string();
     `uvm_fatal("RegModel","RegModel register files cannot be converted to strings")
      return "";
   endfunction: convert2string
   
   virtual function void do_print (uvm_printer printer);
     super.do_print(printer);
   endfunction
   
   virtual function uvm_object clone();
     `uvm_fatal("RegModel","RegModel register files cannot be cloned")
     return null;
   endfunction
   
   virtual function void do_copy(uvm_object rhs);
     `uvm_fatal("RegModel","RegModel register files cannot be copied")
   endfunction
   
   virtual function bit do_compare (uvm_object  rhs, uvm_comparer comparer);
     `uvm_warning("RegModel","RegModel register files cannot be compared")
     return 0;
   endfunction
   
   virtual function void do_pack (uvm_packer packer);
     `uvm_warning("RegModel","RegModel register files cannot be packed")
   endfunction
   
   virtual function void do_unpack (uvm_packer packer);
     `uvm_warning("RegModel","RegModel register files cannot be unpacked")
   endfunction


endclass: uvm_reg_file

`ifndef UVM_MEM_MAM__SV
`define UVM_MEM_MAM__SV

typedef class uvm_mem_mam_cfg;
typedef class uvm_mem_region;
typedef class uvm_mem_mam_policy;
typedef class uvm_mem;

class uvm_mem_mam;

   typedef enum {GREEDY, THRIFTY} alloc_mode_e;
   typedef enum {BROAD, NEARBY}   locality_e;

   uvm_mem_mam_policy default_alloc;

   local uvm_mem memory;
   local uvm_mem_mam_cfg cfg;
   local uvm_mem_region in_use[$];
   local int for_each_idx = -1;
   local string fname;
   local int lineno;

   function new(string      name, uvm_mem_mam_cfg cfg, uvm_mem mem = null);
      this.cfg           = cfg;
      this.memory        = mem;
      this.default_alloc = new;
   endfunction: new
   
   function uvm_mem_mam_cfg reconfigure(uvm_mem_mam_cfg cfg = null);
      uvm_root top;
      uvm_coreservice_t cs;
      if (cfg == null)
        return this.cfg;
   
      cs = uvm_coreservice_t::get();
      top = cs.get_root();
   
      if (cfg.n_bytes !== this.cfg.n_bytes) begin
         top.uvm_report_error("uvm_mem_mam", $sformatf("Cannot reconfigure Memory Allocation Manager with a different number of bytes (%0d !== %0d)", cfg.n_bytes, this.cfg.n_bytes), UVM_LOW);
         return this.cfg;
      end
   
      foreach (this.in_use[i]) begin
         if (this.in_use[i].get_start_offset() < cfg.start_offset ||
             this.in_use[i].get_end_offset() > cfg.end_offset) begin
            top.uvm_report_error("uvm_mem_mam", $sformatf("Cannot reconfigure Memory Allocation Manager with a currently allocated region outside of the managed address range ([%0d:%0d] outside of [%0d:%0d])", this.in_use[i].get_start_offset(), this.in_use[i].get_end_offset(), cfg.start_offset, cfg.end_offset), UVM_LOW);
            return this.cfg;
         end
      end
   
      reconfigure = this.cfg;
      this.cfg = cfg;
   endfunction: reconfigure
   
   
   function uvm_mem_region reserve_region(bit [63:0]   start_offset, int unsigned n_bytes, string       fname = "", int          lineno = 0);
      bit [63:0] end_offset;
      this.fname = fname;
      this.lineno = lineno;
      if (n_bytes == 0) begin
         `uvm_error("RegModel", "Cannot reserve 0 bytes");
         return null;
      end
   
      if (start_offset < this.cfg.start_offset) begin
         `uvm_error("RegModel", $sformatf("Cannot reserve before start of memory space: 'h%h < 'h%h", start_offset, this.cfg.start_offset));
         return null;
      end
   
      end_offset = start_offset + ((n_bytes-1) / this.cfg.n_bytes);
      n_bytes = (end_offset - start_offset + 1) * this.cfg.n_bytes;
   
      if (end_offset > this.cfg.end_offset) begin
         `uvm_error("RegModel", $sformatf("Cannot reserve past end of memory space: 'h%h > 'h%h", end_offset, this.cfg.end_offset));
         return null;
      end
       
       `uvm_info("RegModel",$sformatf("Attempting to reserve ['h%h:'h%h]...", start_offset, end_offset),UVM_MEDIUM)
   
   
      foreach (this.in_use[i]) begin
         if (start_offset <= this.in_use[i].get_end_offset() &&
             end_offset >= this.in_use[i].get_start_offset()) begin
            `uvm_error("RegModel", $sformatf("Cannot reserve ['h%h:'h%h] because it overlaps with %s", start_offset, end_offset, this.in_use[i].convert2string()));
            return null;
         end
   
         if (start_offset > this.in_use[i].get_start_offset()) begin
            reserve_region = new(start_offset, end_offset, end_offset - start_offset + 1, n_bytes, this);
            this.in_use.insert(i, reserve_region);
            return reserve_region;
         end
      end
   
      reserve_region = new(start_offset, end_offset, end_offset - start_offset + 1, n_bytes, this);
      this.in_use.push_back(reserve_region);
   endfunction: reserve_region
   
   
   function uvm_mem_region request_region(int unsigned      n_bytes, uvm_mem_mam_policy    alloc = null, string            fname = "", int               lineno = 0);
      this.fname = fname;
      this.lineno = lineno;
      if (alloc == null) alloc = this.default_alloc;
   
      alloc.len        = (n_bytes-1) / this.cfg.n_bytes + 1;
      alloc.min_offset = this.cfg.start_offset;
      alloc.max_offset = this.cfg.end_offset;
      alloc.in_use     = this.in_use;
   
      if (!alloc.randomize()) begin
         `uvm_error("RegModel", "Unable to randomize policy");
         return null;
      end
   
      return reserve_region(alloc.start_offset, n_bytes);
   endfunction: request_region
   
   
   function void release_region(uvm_mem_region region);
   
      if (region == null) return;
   
      foreach (this.in_use[i]) begin
         if (this.in_use[i] == region) begin
            this.in_use.delete(i);
            return;
         end
      end
      `uvm_error("RegModel", {"Attempting to release unallocated region\n", region.convert2string()});
   endfunction: release_region
   
   
   function void release_all_regions();
     in_use.delete();
   endfunction: release_all_regions
   
   
   function string convert2string();
      convert2string = "Allocated memory regions:\n";
      foreach (this.in_use[i]) begin
         $sformat(convert2string, "%s   %s\n", convert2string, this.in_use[i].convert2string());
      end
   endfunction: convert2string
   
   
   function uvm_mem_region for_each(bit reset = 0);
      if (reset) this.for_each_idx = -1;
   
      this.for_each_idx++;
   
      if (this.for_each_idx >= this.in_use.size()) begin
         return null;
      end
   
      return this.in_use[this.for_each_idx];
   endfunction: for_each
   
   
   function uvm_mem get_memory();
      return this.memory;
   endfunction: get_memory

endclass: uvm_mem_mam



class uvm_mem_region;

   bit [63:0] Xstart_offsetX;  
   bit [63:0] Xend_offsetX;    

   local int unsigned len;
   local int unsigned n_bytes;
   local uvm_mem_mam  parent;
   local string       fname;
   local int          lineno;

   uvm_vreg XvregX;

   function new(bit [63:0] start_offset, bit [63:0] end_offset, int unsigned len, int unsigned n_bytes, uvm_mem_mam      parent);
      this.Xstart_offsetX = start_offset;
      this.Xend_offsetX   = end_offset;
      this.len            = len;
      this.n_bytes        = n_bytes;
      this.parent         = parent;
      this.XvregX         = null;
   endfunction: new
   
   
   function bit [63:0] get_start_offset();
      return this.Xstart_offsetX;
   endfunction: get_start_offset
   
   
   function bit [63:0] get_end_offset();
      return this.Xend_offsetX;
   endfunction: get_end_offset
   
   
   function int unsigned get_len();
      return this.len;
   endfunction: get_len
   
   
   function int unsigned get_n_bytes();
      return this.n_bytes;
   endfunction: get_n_bytes
   
   
   function string convert2string();
      $sformat(convert2string, "['h%h:'h%h]", this.Xstart_offsetX, this.Xend_offsetX);
   endfunction: convert2string
   
   
   function void release_region();
      this.parent.release_region(this);
   endfunction
   
   
   function uvm_mem get_memory();
      return this.parent.get_memory();
   endfunction: get_memory
   
   
   function uvm_vreg get_virtual_registers();
      return this.XvregX;
   endfunction: get_virtual_registers
   
   
   task write(output uvm_status_e       status, input  uvm_reg_addr_t     offset, input  uvm_reg_data_t     value, input  uvm_path_e         path = UVM_DEFAULT_PATH, input  uvm_reg_map        map    = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
   
      uvm_mem mem = this.parent.get_memory();
      this.fname = fname;
      this.lineno = lineno;
   
      if (mem == null) begin
         `uvm_error("RegModel", "Cannot use write() on a region that was allocated by a Memory Allocation Manager that was not associated with a uvm_mem instance");
         status = UVM_NOT_OK;
         return;
      end
   
      if (offset > this.len) begin
         `uvm_error("RegModel", $sformatf("Attempting to write to an offset outside of the allocated region (%0d > %0d)", offset, this.len));
         status = UVM_NOT_OK;
         return;
      end
   
      mem.write(status, offset + this.get_start_offset(), value,
               path, map, parent, prior, extension);
   endtask: write
   
   
   task read(output uvm_status_e       status, input  uvm_reg_addr_t     offset, output uvm_reg_data_t     value, input  uvm_path_e         path = UVM_DEFAULT_PATH, input  uvm_reg_map        map    = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_mem mem = this.parent.get_memory();
      this.fname = fname;
      this.lineno = lineno;
   
      if (mem == null) begin
         `uvm_error("RegModel", "Cannot use read() on a region that was allocated by a Memory Allocation Manager that was not associated with a uvm_mem instance");
         status = UVM_NOT_OK;
         return;
      end
   
      if (offset > this.len) begin
         `uvm_error("RegModel", $sformatf("Attempting to read from an offset outside of the allocated region (%0d > %0d)", offset, this.len));
         status = UVM_NOT_OK;
         return;
      end
   
      mem.read(status, offset + this.get_start_offset(), value,
               path, map, parent, prior, extension);
   endtask: read
   
   
   task burst_write(output uvm_status_e       status, input  uvm_reg_addr_t     offset, input  uvm_reg_data_t     value[], input  uvm_path_e         path = UVM_DEFAULT_PATH, input  uvm_reg_map        map    = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_mem mem = this.parent.get_memory();
      this.fname = fname;
      this.lineno = lineno;
   
      if (mem == null) begin
         `uvm_error("RegModel", "Cannot use burst_write() on a region that was allocated by a Memory Allocation Manager that was not associated with a uvm_mem instance");
         status = UVM_NOT_OK;
         return;
      end
   
      if (offset + value.size() > this.len) begin
         `uvm_error("RegModel", $sformatf("Attempting to burst-write to an offset outside of the allocated region (burst to [%0d:%0d] > mem_size %0d)", offset,offset+value.size(),this.len))
         status = UVM_NOT_OK;
         return;
      end
   
      mem.burst_write(status, offset + get_start_offset(), value,
                      path, map, parent, prior, extension);
   
   endtask: burst_write
   
   
   task burst_read(output uvm_status_e       status, input  uvm_reg_addr_t     offset, output uvm_reg_data_t     value[], input  uvm_path_e         path = UVM_DEFAULT_PATH, input  uvm_reg_map        map    = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_mem mem = this.parent.get_memory();
      this.fname = fname;
      this.lineno = lineno;
   
      if (mem == null) begin
         `uvm_error("RegModel", "Cannot use burst_read() on a region that was allocated by a Memory Allocation Manager that was not associated with a uvm_mem instance");
         status = UVM_NOT_OK;
         return;
      end
   
      if (offset + value.size() > this.len) begin
         `uvm_error("RegModel", $sformatf("Attempting to burst-read to an offset outside of the allocated region (burst to [%0d:%0d] > mem_size %0d)", offset,offset+value.size(),this.len))
         status = UVM_NOT_OK;
         return;
      end
   
      mem.burst_read(status, offset + get_start_offset(), value,
                     path, map, parent, prior, extension);
   
   endtask: burst_read
   
   
   task poke(output uvm_status_e       status, input  uvm_reg_addr_t     offset, input  uvm_reg_data_t     value, input  uvm_sequence_base  parent = null, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_mem mem = this.parent.get_memory();
      this.fname = fname;
      this.lineno = lineno;
   
      if (mem == null) begin
         `uvm_error("RegModel", "Cannot use poke() on a region that was allocated by a Memory Allocation Manager that was not associated with a uvm_mem instance");
         status = UVM_NOT_OK;
         return;
      end
   
      if (offset > this.len) begin
         `uvm_error("RegModel", $sformatf("Attempting to poke to an offset outside of the allocated region (%0d > %0d)", offset, this.len));
         status = UVM_NOT_OK;
         return;
      end
   
      mem.poke(status, offset + this.get_start_offset(), value, "", parent, extension);
   endtask: poke
   
   
   task peek(output uvm_status_e       status, input  uvm_reg_addr_t     offset, output uvm_reg_data_t     value, input  uvm_sequence_base  parent = null, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_mem mem = this.parent.get_memory();
      this.fname = fname;
      this.lineno = lineno;
   
      if (mem == null) begin
         `uvm_error("RegModel", "Cannot use peek() on a region that was allocated by a Memory Allocation Manager that was not associated with a uvm_mem instance");
         status = UVM_NOT_OK;
         return;
      end
   
      if (offset > this.len) begin
         `uvm_error("RegModel", $sformatf("Attempting to peek from an offset outside of the allocated region (%0d > %0d)", offset, this.len));
         status = UVM_NOT_OK;
         return;
      end
   
      mem.peek(status, offset + this.get_start_offset(), value, "", parent, extension);
   endtask: peek


endclass


class uvm_mem_mam_policy;
   int unsigned len;

   rand bit [63:0] start_offset;

   bit [63:0] min_offset;

   bit [63:0] max_offset;

   uvm_mem_region in_use[$];

   constraint uvm_mem_mam_policy_valid {
      start_offset >= min_offset;
      start_offset <= max_offset - len + 1;
   }

   constraint uvm_mem_mam_policy_no_overlap {
      foreach (in_use[i]) {
         !(start_offset <= in_use[i].Xend_offsetX &&
           start_offset + len - 1 >= in_use[i].Xstart_offsetX);
      }
   }

endclass



class uvm_mem_mam_cfg;
   rand int unsigned n_bytes;

   rand bit [63:0] start_offset;

   rand bit [63:0] end_offset;

   rand uvm_mem_mam::alloc_mode_e mode;

   rand uvm_mem_mam::locality_e   locality;

   constraint uvm_mem_mam_cfg_valid {
      end_offset > start_offset;
      n_bytes < 64;
   }
endclass


`endif  

typedef class uvm_mem_region;
typedef class uvm_mem_mam;
typedef class uvm_vreg_cbs;
typedef uvm_callbacks#(uvm_vreg, uvm_vreg_cbs) uvm_vreg_cb;
typedef uvm_callback_iter#(uvm_vreg, uvm_vreg_cbs) uvm_vreg_cb_iter;

class uvm_vreg extends uvm_object;

   `uvm_register_cb(uvm_vreg, uvm_vreg_cbs)

   local bit locked;
   local uvm_reg_block parent;
   local int unsigned  n_bits;
   local int unsigned  n_used_bits;

   local uvm_vreg_field fields[$];   

   local uvm_mem          mem;     
   local uvm_reg_addr_t   offset;  
   local int unsigned     incr;    
   local longint unsigned size;    
   local bit              is_static;

   local uvm_mem_region   region;      
   local semaphore atomic;   
   local string fname;
   local int lineno;
   local bit read_in_progress;
   local bit write_in_progress;

   virtual task pre_write(longint unsigned     idx, ref uvm_reg_data_t   wdat, ref uvm_path_e  path, ref uvm_reg_map      map);
   endtask: pre_write

   virtual task post_write(longint unsigned       idx, uvm_reg_data_t         wdat, uvm_path_e        path, uvm_reg_map            map, ref uvm_status_e  status);
   endtask: post_write

   virtual task pre_read(longint unsigned     idx, ref uvm_path_e  path, ref uvm_reg_map      map);
   endtask: pre_read

   virtual task post_read(longint unsigned       idx, ref uvm_reg_data_t     rdat, input uvm_path_e  path, input uvm_reg_map      map, ref uvm_status_e  status);
   endtask: post_read

   function new(string       name, int unsigned n_bits);
      super.new(name);
   
      if (n_bits == 0) begin
         `uvm_error("RegModel", $sformatf("Virtual register \"%s\" cannot have 0 bits", this.get_full_name()));
         n_bits = 1;
      end
      if (n_bits > `UVM_REG_DATA_WIDTH) begin
         `uvm_error("RegModel", $sformatf("Virtual register \"%s\" cannot have more than %0d bits (%0d)", this.get_full_name(), `UVM_REG_DATA_WIDTH, n_bits));
         n_bits = `UVM_REG_DATA_WIDTH;
      end
      this.n_bits = n_bits;
   
      this.locked    = 0;
   endfunction: new
   
   function void configure(uvm_reg_block      parent, uvm_mem        mem = null, longint unsigned   size = 0, uvm_reg_addr_t     offset = 0, int unsigned       incr = 0);
      this.parent = parent;
   
      this.n_used_bits = 0;
   
      if (mem != null) begin
         void'(this.implement(size, mem, offset, incr));
         this.is_static = 1;
      end
      else begin
         this.mem = null;
         this.is_static = 0;
      end
      this.parent.add_vreg(this);
   
      this.atomic = new(1);
   endfunction: configure
   
   function void Xlock_modelX();
      if (this.locked) return;
   
      this.locked = 1;
   endfunction: Xlock_modelX
   
   function void add_field(uvm_vreg_field field);
      int offset;
      int idx;
      
      if (this.locked) begin
         `uvm_error("RegModel", "Cannot add virtual field to locked virtual register model");
         return;
      end
   
      if (field == null) `uvm_fatal("RegModel", "Attempting to register NULL virtual field");
   
      offset = field.get_lsb_pos_in_register();
   
      idx = -1;
      foreach (this.fields[i]) begin
         if (offset < this.fields[i].get_lsb_pos_in_register()) begin
            int j = i;
            this.fields.insert(j, field);
            idx = i;
            break;
         end
      end
      if (idx < 0) begin
         this.fields.push_back(field);
         idx = this.fields.size()-1;
      end
   
      this.n_used_bits += field.get_n_bits();
      
      if (this.n_used_bits > this.n_bits) begin
         `uvm_error("RegModel", $sformatf("Virtual fields use more bits (%0d) than available in virtual register \"%s\" (%0d)", this.n_used_bits, this.get_full_name(), this.n_bits));
      end
   
      if (idx > 0) begin
         if (this.fields[idx-1].get_lsb_pos_in_register() +
             this.fields[idx-1].get_n_bits() > offset) begin
            `uvm_error("RegModel", $sformatf("Field %s overlaps field %s in virtual register \"%s\"", this.fields[idx-1].get_name(), field.get_name(), this.get_full_name()));
         end
      end
      if (idx < this.fields.size()-1) begin
         if (offset + field.get_n_bits() >
             this.fields[idx+1].get_lsb_pos_in_register()) begin
            `uvm_error("RegModel", $sformatf("Field %s overlaps field %s in virtual register \"%s\"", field.get_name(), this.fields[idx+1].get_name(), this.get_full_name()));
         end
      end
   endfunction: add_field
   
   
   task XatomicX(bit on);
      if (on) this.atomic.get(1);
      else begin
         void'(this.atomic.try_get(1));
         this.atomic.put(1);
      end
   endtask: XatomicX
   
   
   function void reset(string kind = "HARD");
      void'(this.atomic.try_get(1));
      this.atomic.put(1);
   endfunction: reset
   
   
   virtual function string get_full_name();
      uvm_reg_block blk;
   
      get_full_name = this.get_name();
   
      blk = this.get_block();
      if (blk == null) return get_full_name;
      if (blk.get_parent() == null) return get_full_name;
   
      get_full_name = {this.parent.get_full_name(), ".", get_full_name};
   endfunction: get_full_name
   
   virtual function void set_parent(uvm_reg_block parent);
      this.parent = parent;
   endfunction: set_parent
   
   virtual function uvm_reg_block get_parent();
      get_parent = this.parent;
   endfunction: get_parent
   
   virtual function uvm_reg_block get_block();
      get_block = this.parent;
   endfunction: get_block
   
   
   virtual function bit implement(longint unsigned n, uvm_mem      mem = null, uvm_reg_addr_t   offset = 0, int unsigned     incr = 0);
   
      uvm_mem_region region;
   
      if(n < 1)
      begin
        `uvm_error("RegModel", $sformatf("Attempting to implement virtual register \"%s\" with a subscript less than one doesn't make sense",this.get_full_name()));
         return 0;
      end
   
      if (mem == null) begin
         `uvm_error("RegModel", $sformatf("Attempting to implement virtual register \"%s\" using a NULL uvm_mem reference", this.get_full_name()));
         return 0;
      end
   
      if (this.is_static) begin
         `uvm_error("RegModel", $sformatf("Virtual register \"%s\" is static and cannot be dynamically implemented", this.get_full_name()));
         return 0;
      end
   
      if (mem.get_block() != this.parent) begin
         `uvm_error("RegModel", $sformatf("Attempting to implement virtual register \"%s\" on memory \"%s\" in a different block", this.get_full_name(), mem.get_full_name()));
         return 0;
      end
   
      begin
         int min_incr = (this.get_n_bytes()-1) / mem.get_n_bytes() + 1;
         if (incr == 0) incr = min_incr;
         if (min_incr > incr) begin
            `uvm_error("RegModel", $sformatf("Virtual register \"%s\" increment is too small (%0d): Each virtual register requires at least %0d locations in memory \"%s\".", this.get_full_name(), incr, min_incr, mem.get_full_name()));
            return 0;
         end
      end
   
      if (offset + (n * incr) > mem.get_size()) begin
         `uvm_error("RegModel", $sformatf("Given Offset for Virtual register \"%s[%0d]\" is too big for memory %s@'h%0h", this.get_full_name(), n, mem.get_full_name(), offset));
         return 0;
      end
   
      region = mem.mam.reserve_region(offset,n*incr*mem.get_n_bytes());
   
      if (region == null) begin
         `uvm_error("RegModel", $sformatf("Could not allocate a memory region for virtual register \"%s\"", this.get_full_name()));
         return 0;
      end
   
      if (this.mem != null) begin
         `uvm_info("RegModel", $sformatf("Virtual register \"%s\" is being moved re-implemented from %s@'h%0h to %s@'h%0h", this.get_full_name(), this.mem.get_full_name(), this.offset, mem.get_full_name(), offset),UVM_MEDIUM);
         this.release_region();
      end
   
      this.region = region;
      this.mem    = mem;
      this.size   = n;
      this.offset = offset;
      this.incr   = incr;
      this.mem.Xadd_vregX(this);
   
      return 1;
   endfunction: implement
   
   
   virtual function uvm_mem_region allocate(longint unsigned   n, uvm_mem_mam        mam, uvm_mem_mam_policy alloc=null);
   
      uvm_mem mem;
   
      if(n < 1)
      begin
        `uvm_error("RegModel", $sformatf("Attempting to implement virtual register \"%s\" with a subscript less than one doesn't make sense",this.get_full_name()));
         return null;
      end
   
      if (mam == null) begin
         `uvm_error("RegModel", $sformatf("Attempting to implement virtual register \"%s\" using a NULL uvm_mem_mam reference", this.get_full_name()));
         return null;
      end
   
      if (this.is_static) begin
         `uvm_error("RegModel", $sformatf("Virtual register \"%s\" is static and cannot be dynamically allocated", this.get_full_name()));
         return null;
      end
   
      mem = mam.get_memory();
      if (mem.get_block() != this.parent) begin
         `uvm_error("RegModel", $sformatf("Attempting to allocate virtual register \"%s\" on memory \"%s\" in a different block", this.get_full_name(), mem.get_full_name()));
         return null;
      end
   
      begin
         int min_incr = (this.get_n_bytes()-1) / mem.get_n_bytes() + 1;
         if (incr == 0) incr = min_incr;
         if (min_incr < incr) begin
            `uvm_error("RegModel", $sformatf("Virtual register \"%s\" increment is too small (%0d): Each virtual register requires at least %0d locations in memory \"%s\".", this.get_full_name(), incr, min_incr, mem.get_full_name()));
            return null;
         end
      end
   
      allocate = mam.request_region(n*incr*mem.get_n_bytes(), alloc);
      if (allocate == null) begin
         `uvm_error("RegModel", $sformatf("Could not allocate a memory region for virtual register \"%s\"", this.get_full_name()));
         return null;
      end
   
      if (this.mem != null) begin
        `uvm_info("RegModel", $sformatf("Virtual register \"%s\" is being moved from %s@'h%0h to %s@'h%0h", this.get_full_name(), this.mem.get_full_name(), this.offset, mem.get_full_name(), allocate.get_start_offset()),UVM_MEDIUM);
   
         this.release_region();
      end
   
      this.region = allocate;
   
      this.mem    = mam.get_memory();
      this.offset = allocate.get_start_offset();
      this.size   = n;
      this.incr   = incr;
   
      this.mem.Xadd_vregX(this);
   endfunction: allocate
   
   
   virtual function uvm_mem_region get_region();
      return this.region;
   endfunction: get_region
   
   
   virtual function void release_region();
      if (this.is_static) begin
         `uvm_error("RegModel", $sformatf("Virtual register \"%s\" is static and cannot be dynamically released", this.get_full_name()));
         return;
      end
   
      if (this.mem != null)
         this.mem.Xdelete_vregX(this);
   
      if (this.region != null) begin
         this.region.release_region();
      end
   
      this.region = null;
      this.mem    = null;
      this.size   = 0;
      this.offset = 0;
   
      this.reset();
   endfunction: release_region
   
   
   virtual function uvm_mem get_memory();
      return this.mem;
   endfunction: get_memory
   
   
   virtual function uvm_reg_addr_t  get_offset_in_memory(longint unsigned idx);
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call get_offset_in_memory() on unimplemented virtual register \"%s\"", this.get_full_name()));
         return 0;
      end
   
      return this.offset + idx * this.incr;
   endfunction
   
   
   virtual function uvm_reg_addr_t  get_address(longint unsigned idx, uvm_reg_map map = null);
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot get address of of unimplemented virtual register \"%s\".", this.get_full_name()));
         return 0;
      end
   
      return this.mem.get_address(this.get_offset_in_memory(idx), map);
   endfunction: get_address
   
   
   virtual function int unsigned get_size();
      if (this.size == 0) begin
         `uvm_error("RegModel", $sformatf("Cannot call get_size() on unimplemented virtual register \"%s\"", this.get_full_name()));
         return 0;
      end
   
      return this.size;
   endfunction: get_size
   
   
   virtual function int unsigned get_n_bytes();
      return ((this.n_bits-1) / 8) + 1;
   endfunction: get_n_bytes
   
   
   virtual function int unsigned get_n_memlocs();
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call get_n_memlocs() on unimplemented virtual register \"%s\"", this.get_full_name()));
         return 0;
      end
   
      return (this.get_n_bytes()-1) / this.mem.get_n_bytes() + 1;
   endfunction: get_n_memlocs
   
   
   virtual function int unsigned get_incr();
      if (this.incr == 0) begin
         `uvm_error("RegModel", $sformatf("Cannot call get_incr() on unimplemented virtual register \"%s\"", this.get_full_name()));
         return 0;
      end
   
      return this.incr;
   endfunction: get_incr
   
   
   virtual function int get_n_maps();
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call get_n_maps() on unimplemented virtual register \"%s\"", this.get_full_name()));
         return 0;
      end
   
      return this.mem.get_n_maps();
   endfunction: get_n_maps
   
   
   virtual function void get_maps(ref uvm_reg_map maps[$]);
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call get_maps() on unimplemented virtual register \"%s\"", this.get_full_name()));
         return;
      end
   
      this.mem.get_maps(maps);
   endfunction: get_maps
   
   
   function bit is_in_map(uvm_reg_map map);
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call is_in_map() on unimplemented virtual register \"%s\"", this.get_full_name()));
         return 0;
      end
   
      return this.mem.is_in_map(map);
   endfunction
   
   
   virtual function string get_access(uvm_reg_map map = null);
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call get_rights() on unimplemented virtual register \"%s\"", this.get_full_name()));
         return "RW";
      end
   
      return this.mem.get_access(map);
   endfunction: get_access
   
   
   virtual function string get_rights(uvm_reg_map map = null);
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot call get_rights() on unimplemented virtual register \"%s\"", this.get_full_name()));
         return "RW";
      end
   
      return this.mem.get_rights(map);
   endfunction: get_rights
   
   
   virtual function void get_fields(ref uvm_vreg_field fields[$]);
      foreach(this.fields[i])
         fields.push_back(this.fields[i]);
   endfunction: get_fields
   
   
   virtual function uvm_vreg_field get_field_by_name(string name);
      foreach (this.fields[i]) begin
         if (this.fields[i].get_name() == name) begin
            return this.fields[i];
         end
      end
      `uvm_warning("RegModel", $sformatf("Unable to locate field \"%s\" in virtual register \"%s\".", name, this.get_full_name()));
      get_field_by_name = null;
   endfunction: get_field_by_name
   
   
   virtual task write(input  longint unsigned   idx, output uvm_status_e  status, input  uvm_reg_data_t     value, input  uvm_path_e    path = UVM_DEFAULT_PATH, input  uvm_reg_map     map = null, input  uvm_sequence_base  parent = null, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_vreg_cb_iter cbs = new(this);
   
      uvm_reg_addr_t  addr;
      uvm_reg_data_t  tmp;
      uvm_reg_data_t  msk;
      int lsb;
   
      this.write_in_progress = 1'b1;
      this.fname = fname;
      this.lineno = lineno;
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot write to unimplemented virtual register \"%s\".", this.get_full_name()));
         status = UVM_NOT_OK;
         return;
      end
   
      if (path == UVM_DEFAULT_PATH)
        path = this.parent.get_default_path();
   
      foreach (fields[i]) begin
         uvm_vreg_field_cb_iter cbs = new(fields[i]);
         uvm_vreg_field f = fields[i];
         
         lsb = f.get_lsb_pos_in_register();
         msk = ((1<<f.get_n_bits())-1) << lsb;
         tmp = (value & msk) >> lsb;
   
         f.pre_write(idx, tmp, path, map);
         for (uvm_vreg_field_cbs cb = cbs.first(); cb != null;
              cb = cbs.next()) begin
            cb.fname = this.fname;
            cb.lineno = this.lineno;
            cb.pre_write(f, idx, tmp, path, map);
         end
   
         value = (value & ~msk) | (tmp << lsb);
      end
      this.pre_write(idx, value, path, map);
      for (uvm_vreg_cbs cb = cbs.first(); cb != null;
           cb = cbs.next()) begin
         cb.fname = this.fname;
         cb.lineno = this.lineno;
         cb.pre_write(this, idx, value, path, map);
      end
   
      addr = this.offset + (idx * this.incr);
   
      lsb = 0;
      status = UVM_IS_OK;
      for (int i = 0; i < this.get_n_memlocs(); i++) begin
         uvm_status_e s;
   
         msk = ((1<<(this.mem.get_n_bytes()*8))-1) << lsb;
         tmp = (value & msk) >> lsb;
         this.mem.write(s, addr + i, tmp, path, map , parent, , extension, fname, lineno);
         if (s != UVM_IS_OK && s != UVM_HAS_X) status = s;
         lsb += this.mem.get_n_bytes() * 8;
      end
   
      for (uvm_vreg_cbs cb = cbs.first(); cb != null;
           cb = cbs.next()) begin
         cb.fname = this.fname;
         cb.lineno = this.lineno;
         cb.post_write(this, idx, value, path, map, status);
      end
      this.post_write(idx, value, path, map, status);
      foreach (fields[i]) begin
         uvm_vreg_field_cb_iter cbs = new(fields[i]);
         uvm_vreg_field f = fields[i];
         
         lsb = f.get_lsb_pos_in_register();
         msk = ((1<<f.get_n_bits())-1) << lsb;
         tmp = (value & msk) >> lsb;
   
         for (uvm_vreg_field_cbs cb = cbs.first(); cb != null;
              cb = cbs.next()) begin
            cb.fname = this.fname;
            cb.lineno = this.lineno;
            cb.post_write(f, idx, tmp, path, map, status);
         end
         f.post_write(idx, tmp, path, map, status);
   
         value = (value & ~msk) | (tmp << lsb);
      end
   
      `uvm_info("RegModel", $sformatf("Wrote virtual register \"%s\"[%0d] via %s with: 'h%h", this.get_full_name(), idx, (path == UVM_FRONTDOOR) ? "frontdoor" : "backdoor", value),UVM_MEDIUM);
      
      this.write_in_progress = 1'b0;
      this.fname = "";
      this.lineno = 0;
   
   endtask: write
   
   
   virtual task read(input  longint unsigned   idx, output uvm_status_e  status, output uvm_reg_data_t     value, input  uvm_path_e    path = UVM_DEFAULT_PATH, input  uvm_reg_map     map = null, input  uvm_sequence_base  parent = null, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_vreg_cb_iter cbs = new(this);
   
      uvm_reg_addr_t  addr;
      uvm_reg_data_t  tmp;
      uvm_reg_data_t  msk;
      int lsb;
      this.read_in_progress = 1'b1;
      this.fname = fname;
      this.lineno = lineno;
   
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot read from unimplemented virtual register \"%s\".", this.get_full_name()));
         status = UVM_NOT_OK;
         return;
      end
   
      if (path == UVM_DEFAULT_PATH)
        path = this.parent.get_default_path();
   
      foreach (fields[i]) begin
         uvm_vreg_field_cb_iter cbs = new(fields[i]);
         uvm_vreg_field f = fields[i];
   
         f.pre_read(idx, path, map);
         for (uvm_vreg_field_cbs cb = cbs.first(); cb != null;
              cb = cbs.next()) begin
            cb.fname = this.fname;
            cb.lineno = this.lineno;
            cb.pre_read(f, idx, path, map);
         end
      end
      this.pre_read(idx, path, map);
      for (uvm_vreg_cbs cb = cbs.first(); cb != null;
           cb = cbs.next()) begin
         cb.fname = this.fname;
         cb.lineno = this.lineno;
         cb.pre_read(this, idx, path, map);
      end
   
      addr = this.offset + (idx * this.incr);
   
      lsb = 0;
      value = 0;
      status = UVM_IS_OK;
      for (int i = 0; i < this.get_n_memlocs(); i++) begin
         uvm_status_e s;
   
         this.mem.read(s, addr + i, tmp, path, map, parent, , extension, fname, lineno);
         if (s != UVM_IS_OK && s != UVM_HAS_X) status = s;
   
         value |= tmp << lsb;
         lsb += this.mem.get_n_bytes() * 8;
      end
   
      for (uvm_vreg_cbs cb = cbs.first(); cb != null;
           cb = cbs.next()) begin
         cb.fname = this.fname;
         cb.lineno = this.lineno;
         cb.post_read(this, idx, value, path, map, status);
      end
      this.post_read(idx, value, path, map, status);
      foreach (fields[i]) begin
         uvm_vreg_field_cb_iter cbs = new(fields[i]);
         uvm_vreg_field f = fields[i];
   
         lsb = f.get_lsb_pos_in_register();
   
         msk = ((1<<f.get_n_bits())-1) << lsb;
         tmp = (value & msk) >> lsb;
   
         for (uvm_vreg_field_cbs cb = cbs.first(); cb != null;
              cb = cbs.next()) begin
            cb.fname = this.fname;
            cb.lineno = this.lineno;
            cb.post_read(f, idx, tmp, path, map, status);
         end
         f.post_read(idx, tmp, path, map, status);
   
         value = (value & ~msk) | (tmp << lsb);
      end
   
      `uvm_info("RegModel", $sformatf("Read virtual register \"%s\"[%0d] via %s: 'h%h", this.get_full_name(), idx, (path == UVM_FRONTDOOR) ? "frontdoor" : "backdoor", value),UVM_MEDIUM); 
      this.read_in_progress = 1'b0;
      this.fname = "";
      this.lineno = 0;
   endtask: read
   
   
   virtual task poke(input longint unsigned   idx, output uvm_status_e status, input  uvm_reg_data_t    value, input  uvm_sequence_base parent = null, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      uvm_reg_addr_t  addr;
      uvm_reg_data_t  tmp;
      uvm_reg_data_t  msk;
      int lsb;
      this.fname = fname;
      this.lineno = lineno;
   
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot poke in unimplemented virtual register \"%s\".", this.get_full_name()));
         status = UVM_NOT_OK;
         return;
      end
   
      addr = this.offset + (idx * this.incr);
   
      lsb = 0;
      status = UVM_IS_OK;
      for (int i = 0; i < this.get_n_memlocs(); i++) begin
         uvm_status_e s;
   
         msk = ((1<<(this.mem.get_n_bytes() * 8))-1) << lsb;
         tmp = (value & msk) >> lsb;
   
         this.mem.poke(status, addr + i, tmp, "", parent, extension, fname, lineno);
         if (s != UVM_IS_OK && s != UVM_HAS_X) status = s;
   
         lsb += this.mem.get_n_bytes() * 8;
      end
   
      `uvm_info("RegModel", $sformatf("Poked virtual register \"%s\"[%0d] with: 'h%h", this.get_full_name(), idx, value),UVM_MEDIUM);
      this.fname = "";
      this.lineno = 0;
   
   endtask: poke
   
   
   virtual task peek(input longint unsigned   idx, output uvm_status_e status, output uvm_reg_data_t    value, input  uvm_sequence_base parent = null, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      uvm_reg_addr_t  addr;
      uvm_reg_data_t  tmp;
      uvm_reg_data_t  msk;
      int lsb;
      this.fname = fname;
      this.lineno = lineno;
   
      if (this.mem == null) begin
         `uvm_error("RegModel", $sformatf("Cannot peek in from unimplemented virtual register \"%s\".", this.get_full_name()));
         status = UVM_NOT_OK;
         return;
      end
   
      addr = this.offset + (idx * this.incr);
   
      lsb = 0;
      value = 0;
      status = UVM_IS_OK;
      for (int i = 0; i < this.get_n_memlocs(); i++) begin
         uvm_status_e s;
   
         this.mem.peek(status, addr + i, tmp, "", parent, extension, fname, lineno);
         if (s != UVM_IS_OK && s != UVM_HAS_X) status = s;
   
         value |= tmp << lsb;
         lsb += this.mem.get_n_bytes() * 8;
      end
   
      `uvm_info("RegModel", $sformatf("Peeked virtual register \"%s\"[%0d]: 'h%h", this.get_full_name(), idx, value),UVM_MEDIUM);
      
      this.fname = "";
      this.lineno = 0;
   
   endtask: peek
   
   
   virtual function void do_print (uvm_printer printer);
     super.do_print(printer);
     printer.print_generic("initiator", parent.get_type_name(), -1, convert2string());
   endfunction
   
   virtual function string convert2string();
      string res_str;
      string t_str;
      bit with_debug_info;
      $sformat(convert2string, "Virtual register %s -- ", this.get_full_name());
   
      if (this.size == 0)
        $sformat(convert2string, "%sunimplemented", convert2string);
      else begin
         uvm_reg_map maps[$];
         mem.get_maps(maps);
   
         $sformat(convert2string, "%s[%0d] in %0s['h%0h+'h%0h]\n", convert2string, this.size, this.mem.get_full_name(), this.offset, this.incr); 
         foreach (maps[i]) begin
           uvm_reg_addr_t  addr0 = this.get_address(0, maps[i]);
   
           $sformat(convert2string, "  Address in map '%s' -- @'h%0h+%0h", maps[i].get_full_name(), addr0, this.get_address(1, maps[i]) - addr0);
         end
      end
      foreach(this.fields[i]) begin
         $sformat(convert2string, "%s\n%s", convert2string, this.fields[i].convert2string());
      end
   
   endfunction: convert2string
   
   virtual function uvm_object clone();
     return null;
   endfunction
   
   virtual function void do_copy   (uvm_object rhs);
   endfunction
   
   virtual function bit do_compare (uvm_object  rhs, uvm_comparer comparer);
     return 0;
   endfunction
   
   virtual function void do_pack (uvm_packer packer);
   endfunction
   
   virtual function void do_unpack (uvm_packer packer);
   endfunction

endclass: uvm_vreg

class uvm_vreg_cbs extends uvm_callback;

   string fname;
   int    lineno;

   function new(string name = "uvm_reg_cbs");
      super.new(name);
   endfunction
   
   virtual task pre_write(uvm_vreg         rg, longint unsigned     idx, ref uvm_reg_data_t   wdat, ref uvm_path_e  path, ref uvm_reg_map   map);
   endtask: pre_write

   virtual task post_write(uvm_vreg           rg, longint unsigned       idx, uvm_reg_data_t         wdat, uvm_path_e        path, uvm_reg_map         map, ref uvm_status_e  status);
   endtask: post_write

   virtual task pre_read(uvm_vreg         rg, longint unsigned     idx, ref uvm_path_e  path, ref uvm_reg_map   map);
   endtask: pre_read

   virtual task post_read(uvm_vreg           rg, longint unsigned       idx, ref uvm_reg_data_t     rdat, input uvm_path_e  path, input uvm_reg_map   map, ref uvm_status_e  status);
   endtask: post_read

endclass: uvm_vreg_cbs


class uvm_mem extends uvm_object;

   typedef enum {UNKNOWNS, ZEROES, ONES, ADDRESS, VALUE, INCR, DECR} init_e;

   local bit               m_locked;
   local bit               m_read_in_progress;
   local bit               m_write_in_progress;
   local string            m_access;
   local longint unsigned  m_size;
   local uvm_reg_block     m_parent;
   local bit               m_maps[uvm_reg_map];
   local int unsigned      m_n_bits;
   local uvm_reg_backdoor  m_backdoor;
   local bit               m_is_powered_down;
   local int               m_has_cover;
   local int               m_cover_on;
   local string            m_fname;
   local int               m_lineno;
   local bit               m_vregs[uvm_vreg];
   local uvm_object_string_pool #(uvm_queue #(uvm_hdl_path_concat)) m_hdl_paths_pool;
   local static int unsigned  m_max_size;
   uvm_mem_mam mam;

   `uvm_register_cb(uvm_mem, uvm_reg_cbs)

   virtual task pre_write(uvm_reg_item rw); endtask
   virtual task post_write(uvm_reg_item rw); endtask
   virtual task pre_read(uvm_reg_item rw); endtask
   virtual task post_read(uvm_reg_item rw); endtask

   protected virtual function void  sample(uvm_reg_addr_t offset, bit            is_read, uvm_reg_map    map);
   endfunction

   function void XsampleX(uvm_reg_addr_t addr, bit            is_read, uvm_reg_map    map);
      sample(addr, is_read, map);
   endfunction

   function new (string           name, longint unsigned size, int unsigned     n_bits, string           access = "RW", int              has_coverage = UVM_NO_COVERAGE);
   
      super.new(name);
      m_locked = 0;
      if (n_bits == 0) begin
         `uvm_error("RegModel", {"Memory '",get_full_name(),"' cannot have 0 bits"})
         n_bits = 1;
      end
      m_size      = size;
      m_n_bits    = n_bits;
      m_backdoor  = null;
      m_access    = access.toupper();
      m_has_cover = has_coverage;
      m_hdl_paths_pool = new("hdl_paths");
   
      if (n_bits > m_max_size)
         m_max_size = n_bits;
   
   endfunction: new
   
   
   function void configure(uvm_reg_block  parent, string         hdl_path="");
   
      if (parent == null)
        `uvm_fatal("REG/NULL_PARENT","configure: parent argument is null") 
   
      m_parent = parent;
   
      if (m_access != "RW" && m_access != "RO") begin
         `uvm_error("RegModel", {"Memory '",get_full_name(),"' can only be RW or RO"})
         m_access = "RW";
      end
   
      begin
         uvm_mem_mam_cfg cfg = new;
   
         cfg.n_bytes      = ((m_n_bits-1) / 8) + 1;
         cfg.start_offset = 0;
         cfg.end_offset   = m_size-1;
   
         cfg.mode     = uvm_mem_mam::GREEDY;
         cfg.locality = uvm_mem_mam::BROAD;
   
         mam = new(get_full_name(), cfg, this);
      end
   
      m_parent.add_mem(this);
   
      if (hdl_path != "") add_hdl_path_slice(hdl_path, -1, -1);
   endfunction: configure
   
   
   
   virtual function void set_offset (uvm_reg_map    map, uvm_reg_addr_t offset, bit unmapped = 0);
   
      uvm_reg_map orig_map = map;
   
      if (m_maps.num() > 1 && map == null) begin
         `uvm_error("RegModel",{"set_offset requires a non-null map when memory '", get_full_name(),"' belongs to more than one map."})
         return;
      end
   
      map = get_local_map(map,"set_offset()");
   
      if (map == null)
        return;
      
      map.m_set_mem_offset(this, offset, unmapped);
   endfunction
   
   
   
   virtual function void add_map(uvm_reg_map map);
     m_maps[map] = 1;
   endfunction
   
   
   
   function void Xlock_modelX();
      m_locked = 1;
   endfunction: Xlock_modelX
   
   
   
   virtual function string get_full_name();
      if (m_parent == null)
         return get_name();
      
      return {m_parent.get_full_name(), ".", get_name()};
   
   endfunction: get_full_name
   
   
   
   virtual function uvm_reg_block get_block();
      return m_parent;
   endfunction: get_block
   
   
   
   virtual function int get_n_maps();
      return m_maps.num();
   endfunction: get_n_maps
   
   
   
   virtual function void get_maps(ref uvm_reg_map maps[$]);
      foreach (m_maps[map])
        maps.push_back(map);
   endfunction
   
   
   
   virtual function bit is_in_map(uvm_reg_map map);
      if (m_maps.exists(map))
        return 1;
      foreach (m_maps[l]) begin
       uvm_reg_map local_map=l;
        uvm_reg_map parent_map = local_map.get_parent_map();
   
        while (parent_map != null) begin
          if (parent_map == map)
            return 1;
          parent_map = parent_map.get_parent_map();
        end
      end
      return 0;
   endfunction
   
   
   
   virtual function uvm_reg_map get_local_map(uvm_reg_map map, string caller="");
      if (map == null)
        return get_default_map();
      if (m_maps.exists(map))
        return map; 
      foreach (m_maps[l]) begin
        uvm_reg_map local_map = l;
        uvm_reg_map parent_map = local_map.get_parent_map();
   
        while (parent_map != null) begin
          if (parent_map == map)
            return local_map;
          parent_map = parent_map.get_parent_map();
        end
      end
      `uvm_warning("RegModel", 
          {"Memory '",get_full_name(),"' is not contained within map '",map.get_full_name(),"'", (caller == "" ? "": {" (called from ",caller,")"})})
      return null;
   endfunction
   
   
   
   virtual function uvm_reg_map get_default_map(string caller="");
   
      if (m_maps.num() == 0) begin
         `uvm_warning("RegModel", {"Memory '",get_full_name(),"' is not registered with any map", (caller == "" ? "": {" (called from ",caller,")"})})
         return null;
      end
   
      if (m_maps.num() == 1) begin
        void'(m_maps.first(get_default_map));
      end
   
      foreach (m_maps[l]) begin
        uvm_reg_map map = l;
        uvm_reg_block blk = map.get_parent();
        uvm_reg_map default_map = blk.get_default_map();
        if (default_map != null) begin
          uvm_reg_map local_map = get_local_map(default_map);
          if (local_map != null)
            return local_map;
        end
      end
   
   
      void'(m_maps.first(get_default_map));
   
   endfunction
   
   
   
   virtual function string get_access(uvm_reg_map map = null);
      get_access = m_access;
      if (get_n_maps() == 1) return get_access;
   
      map = get_local_map(map, "get_access()");
      if (map == null) return get_access;
   
      case (get_rights(map))
        "RW":
          return get_access;
   
        "RO":
          case (get_access)
            "RW", "RO": get_access = "RO";
   
            "WO":    `uvm_error("RegModel", {"WO memory '",get_full_name(), "' restricted to RO in map '",map.get_full_name(),"'"})
   
            default: `uvm_error("RegModel", {"Memory '",get_full_name(), "' has invalid access mode, '",get_access,"'"})
          endcase
   
        "WO":
          case (get_access)
            "RW", "WO": get_access = "WO";
   
            "RO":    `uvm_error("RegModel", {"RO memory '",get_full_name(), "' restricted to WO in map '",map.get_full_name(),"'"})
   
            default: `uvm_error("RegModel", {"Memory '",get_full_name(), "' has invalid access mode, '",get_access,"'"})
          endcase
   
        default: `uvm_error("RegModel", {"Shared memory '",get_full_name(), "' is not shared in map '",map.get_full_name(),"'"})
      endcase
   endfunction: get_access
   
   
   virtual function string get_rights(uvm_reg_map map = null);
   
      uvm_reg_map_info info;
   
      if (m_maps.num() <= 1) begin
         return "RW";
      end
   
      map = get_local_map(map,"get_rights()");
   
      if (map == null)
        return "RW";
   
      info = map.get_mem_map_info(this);
      return info.rights;
   
   endfunction: get_rights
   
   
   
   virtual function uvm_reg_addr_t get_offset(uvm_reg_addr_t offset = 0, uvm_reg_map map = null);
   
      uvm_reg_map_info map_info;
      uvm_reg_map orig_map = map;
   
      map = get_local_map(map,"get_offset()");
   
      if (map == null)
        return -1;
      
      map_info = map.get_mem_map_info(this);
      
      if (map_info.unmapped) begin
         `uvm_warning("RegModel", {"Memory '",get_name(), "' is unmapped in map '", ((orig_map == null) ? map.get_full_name() : orig_map.get_full_name()),"'"})
         return -1;
      end
            
      return map_info.offset;
   
   endfunction: get_offset
   
   
   
   
   virtual function void get_virtual_registers(ref uvm_vreg regs[$]);
     foreach (m_vregs[vreg])
        regs.push_back(vreg);
   endfunction
   
   
   
   virtual function void get_virtual_fields(ref uvm_vreg_field fields[$]);
   
     foreach (m_vregs[l])
     begin
       uvm_vreg vreg = l;
       vreg.get_fields(fields);
     end
   endfunction: get_virtual_fields
   
   
   
   virtual function uvm_vreg_field get_vfield_by_name(string name);
     uvm_vreg_field vfields[$];
   
     get_virtual_fields(vfields);
   
     foreach (vfields[i])
       if (vfields[i].get_name() == name)
         return vfields[i];
   
     `uvm_warning("RegModel", {"Unable to find virtual field '",name, "' in memory '",get_full_name(),"'"})
      return null;
   endfunction: get_vfield_by_name
   
   
   
   virtual function uvm_vreg get_vreg_by_name(string name);
   
     foreach (m_vregs[l])
     begin
       uvm_vreg vreg = l;
       if (vreg.get_name() == name)
         return vreg;
     end
   
     `uvm_warning("RegModel", {"Unable to find virtual register '",name, "' in memory '",get_full_name(),"'"})
     return null;
   
   endfunction: get_vreg_by_name
   
   
   
   virtual function uvm_vreg get_vreg_by_offset(uvm_reg_addr_t offset, uvm_reg_map map = null);
      `uvm_error("RegModel", "get_vreg_by_offset() not yet implemented")
      return null;
   endfunction: get_vreg_by_offset
   
   
   
   
   virtual function int get_addresses(uvm_reg_addr_t offset = 0, uvm_reg_map map=null, ref uvm_reg_addr_t addr[]);
   
      uvm_reg_map_info map_info;
      uvm_reg_map system_map;
      uvm_reg_map orig_map = map;
   
      map = get_local_map(map,"get_addresses()");
   
      if (map == null)
        return 0;
   
      map_info = map.get_mem_map_info(this);
   
      if (map_info.unmapped) begin
         `uvm_warning("RegModel", {"Memory '",get_name(), "' is unmapped in map '", ((orig_map == null) ? map.get_full_name() : orig_map.get_full_name()),"'"})
         return 0;
      end
   
      addr = map_info.addr;
   
      foreach (addr[i])
         addr[i] = addr[i] + map_info.mem_range.stride * offset;
   
      return map.get_n_bytes();
   
   endfunction
   
   
   
   virtual function uvm_reg_addr_t get_address(uvm_reg_addr_t offset = 0, uvm_reg_map map = null);
      uvm_reg_addr_t  addr[];
      void'(get_addresses(offset, map, addr));
      return addr[0];
   endfunction
   
   
   
   virtual function longint unsigned get_size();
      return m_size;
   endfunction: get_size
   
   
   
   virtual function int unsigned get_n_bits();
      return m_n_bits;
   endfunction: get_n_bits
   
   
   
   static function int unsigned get_max_size();
      return m_max_size;
   endfunction: get_max_size
   
   
   
   virtual function int unsigned get_n_bytes();
      return (m_n_bits - 1) / 8 + 1;
   endfunction: get_n_bytes
   
   virtual protected function uvm_reg_cvr_t build_coverage(uvm_reg_cvr_t models);
      build_coverage = UVM_NO_COVERAGE;
      void'(uvm_reg_cvr_rsrc_db::read_by_name({"uvm_reg::", get_full_name()}, "include_coverage", build_coverage, this));
      return build_coverage & models;
   endfunction: build_coverage
   
   
   
   virtual protected function void add_coverage(uvm_reg_cvr_t models);
      m_has_cover |= models;
   endfunction: add_coverage
   
   
   
   virtual function bit has_coverage(uvm_reg_cvr_t models);
      return ((m_has_cover & models) == models);
   endfunction: has_coverage
   
   
   
   virtual function uvm_reg_cvr_t set_coverage(uvm_reg_cvr_t is_on);
      if (is_on == uvm_reg_cvr_t'(UVM_NO_COVERAGE)) begin
         m_cover_on = is_on;
         return m_cover_on;
      end
   
      m_cover_on = m_has_cover & is_on;
   
      return m_cover_on;
   endfunction: set_coverage
   
   
   
   virtual function bit get_coverage(uvm_reg_cvr_t is_on);
      if (has_coverage(is_on) == 0) return 0;
      return ((m_cover_on & is_on) == is_on);
   endfunction: get_coverage
   
   
   
   virtual task write(output uvm_status_e      status, input  uvm_reg_addr_t    offset, input  uvm_reg_data_t    value, input  uvm_path_e        path = UVM_DEFAULT_PATH, input  uvm_reg_map       map = null, input  uvm_sequence_base parent = null, input  int               prior = -1, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
   
      uvm_reg_item rw = uvm_reg_item::type_id::create("mem_write",,get_full_name());
      rw.element      = this;
      rw.element_kind = UVM_MEM;
      rw.kind         = UVM_WRITE;
      rw.offset       = offset;
      rw.value[0]     = value;
      rw.path         = path;
      rw.map          = map;
      rw.parent       = parent;
      rw.prior        = prior;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      do_write(rw);
   
      status = rw.status;
   
   endtask: write
   
   
   
   virtual task read(output uvm_status_e       status, input  uvm_reg_addr_t     offset, output uvm_reg_data_t     value, input  uvm_path_e         path = UVM_DEFAULT_PATH, input  uvm_reg_map        map = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      
      uvm_reg_item rw;
      rw = uvm_reg_item::type_id::create("mem_read",,get_full_name());
      rw.element      = this;
      rw.element_kind = UVM_MEM;
      rw.kind         = UVM_READ;
      rw.value[0]     = 0;
      rw.offset       = offset;
      rw.path         = path;
      rw.map          = map;
      rw.parent       = parent;
      rw.prior        = prior;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      do_read(rw);
   
      status = rw.status;
      value = rw.value[0];
   
   endtask: read
   
   
   
   virtual task burst_write(output uvm_status_e       status, input  uvm_reg_addr_t     offset, input  uvm_reg_data_t     value[], input  uvm_path_e         path = UVM_DEFAULT_PATH, input  uvm_reg_map        map = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
   
      uvm_reg_item rw;
      rw = uvm_reg_item::type_id::create("mem_burst_write",,get_full_name());
      rw.element      = this;
      rw.element_kind = UVM_MEM;
      rw.kind         = UVM_BURST_WRITE;
      rw.offset       = offset;
      rw.value        = value;
      rw.path         = path;
      rw.map          = map;
      rw.parent       = parent;
      rw.prior        = prior;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      do_write(rw);
   
      status = rw.status;
   
   endtask: burst_write
   
   
   
   virtual task burst_read(output uvm_status_e       status, input  uvm_reg_addr_t     offset, ref    uvm_reg_data_t     value[], input  uvm_path_e         path = UVM_DEFAULT_PATH, input  uvm_reg_map        map = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
   
      uvm_reg_item rw;
      rw = uvm_reg_item::type_id::create("mem_burst_read",,get_full_name());
      rw.element      = this;
      rw.element_kind = UVM_MEM;
      rw.kind         = UVM_BURST_READ;
      rw.offset       = offset;
      rw.value        = value;
      rw.path         = path;
      rw.map          = map;
      rw.parent       = parent;
      rw.prior        = prior;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      do_read(rw);
   
      status = rw.status;
      value  = rw.value;
   
   endtask: burst_read
   
   
   
   virtual task do_write(uvm_reg_item rw);
   
      uvm_mem_cb_iter  cbs = new(this);
      uvm_reg_map_info map_info;
      
      m_fname  = rw.fname;
      m_lineno = rw.lineno;
   
      if (!Xcheck_accessX(rw, map_info, "burst_write()"))
        return;
   
      m_write_in_progress = 1'b1;
   
      rw.status = UVM_IS_OK;
      
      pre_write(rw);
      for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
         cb.pre_write(rw);
   
      if (rw.status != UVM_IS_OK) begin
         m_write_in_progress = 1'b0;
   
         return;
      end
   
      rw.status = UVM_NOT_OK;
   
      if (rw.path == UVM_FRONTDOOR) begin
   
         uvm_reg_map system_map = rw.local_map.get_root_map();
         
         if (map_info.frontdoor != null) begin
            uvm_reg_frontdoor fd = map_info.frontdoor;
            fd.rw_info = rw;
            if (fd.sequencer == null)
              fd.sequencer = system_map.get_sequencer();
            fd.start(fd.sequencer, rw.parent);
         end
         else begin
            rw.local_map.do_write(rw);
         end
   
         if (rw.status != UVM_NOT_OK)
            for (uvm_reg_addr_t idx = rw.offset;
                 idx <= rw.offset + rw.value.size();
                 idx++) begin
               XsampleX(map_info.mem_range.stride * idx, 0, rw.map);
               m_parent.XsampleX(map_info.offset +
                                (map_info.mem_range.stride * idx),
                                 0, rw.map);
            end
      end
         
      else begin
         if (get_access(rw.map) == "RW") begin
            uvm_reg_backdoor bkdr = get_backdoor();
            if (bkdr != null)
               bkdr.write(rw);
            else
               backdoor_write(rw);
         end
         else
            rw.status = UVM_IS_OK;
      end
   
      post_write(rw);
      for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
         cb.post_write(rw);
   
      if (uvm_report_enabled(UVM_HIGH, UVM_INFO, "RegModel")) begin
        string path_s,value_s,pre_s,range_s;
        if (rw.path == UVM_FRONTDOOR)
          path_s = (map_info.frontdoor != null) ? "user frontdoor" : {"map ",rw.map.get_full_name()};
        else
          path_s = (get_backdoor() != null) ? "user backdoor" : "DPI backdoor";
   
        if (rw.value.size() > 1) begin
          value_s = "='{";
          pre_s = "Burst ";
          foreach (rw.value[i])
            value_s = {value_s,$sformatf("%0h,",rw.value[i])};
          value_s[value_s.len()-1]="}";
          range_s = $sformatf("[%0d:%0d]",rw.offset,rw.offset+rw.value.size());
        end
        else begin
          value_s = $sformatf("=%0h",rw.value[0]);
          range_s = $sformatf("[%0d]",rw.offset);
        end
   
        uvm_report_info("RegModel", {pre_s,"Wrote memory via ",path_s,": ", get_full_name(),range_s,value_s}, UVM_HIGH);
      end
   
      m_write_in_progress = 1'b0;
   
   endtask: do_write
   
   
   
   virtual task do_read(uvm_reg_item rw);
   
      uvm_mem_cb_iter cbs = new(this);
      uvm_reg_map_info map_info;
      
      m_fname = rw.fname;
      m_lineno = rw.lineno;
   
      if (!Xcheck_accessX(rw, map_info, "burst_read()"))
        return;
   
      m_read_in_progress = 1'b1;
   
      rw.status = UVM_IS_OK;
      
      pre_read(rw);
      for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
         cb.pre_read(rw);
   
      if (rw.status != UVM_IS_OK) begin
         m_read_in_progress = 1'b0;
   
         return;
      end
   
      rw.status = UVM_NOT_OK;
   
      if (rw.path == UVM_FRONTDOOR) begin
         
         uvm_reg_map system_map = rw.local_map.get_root_map();
            
         if (map_info.frontdoor != null) begin
            uvm_reg_frontdoor fd = map_info.frontdoor;
            fd.rw_info = rw;
            if (fd.sequencer == null)
              fd.sequencer = system_map.get_sequencer();
            fd.start(fd.sequencer, rw.parent);
         end
         else begin
            rw.local_map.do_read(rw);
         end
   
         if (rw.status != UVM_NOT_OK)
            for (uvm_reg_addr_t idx = rw.offset;
                 idx <= rw.offset + rw.value.size();
                 idx++) begin
               XsampleX(map_info.mem_range.stride * idx, 1, rw.map);
               m_parent.XsampleX(map_info.offset + (map_info.mem_range.stride * idx), 1, rw.map);
            end
      end
   
      else begin
         uvm_reg_backdoor bkdr = get_backdoor();
         if (bkdr != null)
            bkdr.read(rw);
         else
            backdoor_read(rw);
      end
   
      post_read(rw);
      for (uvm_reg_cbs cb=cbs.first(); cb!=null; cb=cbs.next())
         cb.post_read(rw);
   
      if (uvm_report_enabled(UVM_HIGH, UVM_INFO, "RegModel")) begin
        string path_s,value_s,pre_s,range_s;
        if (rw.path == UVM_FRONTDOOR)
          path_s = (map_info.frontdoor != null) ? "user frontdoor" : {"map ",rw.map.get_full_name()};
        else
          path_s = (get_backdoor() != null) ? "user backdoor" : "DPI backdoor";
   
        if (rw.value.size() > 1) begin
          value_s = "='{";
          pre_s = "Burst ";
          foreach (rw.value[i])
            value_s = {value_s,$sformatf("%0h,",rw.value[i])};
          value_s[value_s.len()-1]="}";
          range_s = $sformatf("[%0d:%0d]",rw.offset,(rw.offset+rw.value.size()));
        end
        else begin
          value_s = $sformatf("=%0h",rw.value[0]);
          range_s = $sformatf("[%0d]",rw.offset);
        end
   
         uvm_report_info("RegModel", {pre_s,"Read memory via ",path_s,": ", get_full_name(),range_s,value_s}, UVM_HIGH);
      end
   
      m_read_in_progress = 1'b0;
   
   endtask: do_read
   
   
   
   virtual protected function bit Xcheck_accessX(input uvm_reg_item rw, output uvm_reg_map_info map_info, input string caller);
   
      if (rw.offset >= m_size) begin
         `uvm_error(get_type_name(), 
            $sformatf("Offset 'h%0h exceeds size of memory, 'h%0h", rw.offset, m_size))
         rw.status = UVM_NOT_OK;
         return 0;
      end
   
      if (rw.path == UVM_DEFAULT_PATH)
        rw.path = m_parent.get_default_path();
   
      if (rw.path == UVM_BACKDOOR) begin
         if (get_backdoor() == null && !has_hdl_path()) begin
            `uvm_warning("RegModel", {"No backdoor access available for memory '",get_full_name(), "' . Using frontdoor instead."})
            rw.path = UVM_FRONTDOOR;
         end
         else
           rw.map = uvm_reg_map::backdoor();
      end
   
      if (rw.path != UVM_BACKDOOR) begin
   
        rw.local_map = get_local_map(rw.map,caller);
   
        if (rw.local_map == null) begin
           `uvm_error(get_type_name(), {"No transactor available to physically access memory from map '", rw.map.get_full_name(),"'"})
           rw.status = UVM_NOT_OK;
           return 0;
        end
   
        map_info = rw.local_map.get_mem_map_info(this);
   
        if (map_info.frontdoor == null) begin
   
           if (map_info.unmapped) begin
              `uvm_error("RegModel", {"Memory '",get_full_name(), "' unmapped in map '", rw.map.get_full_name(), "' and does not have a user-defined frontdoor"})
              rw.status = UVM_NOT_OK;
              return 0;
           end
   
           if ((rw.value.size() > 1)) begin
              if (get_n_bits() > rw.local_map.get_n_bytes()*8) begin
                 `uvm_error("RegModel", $sformatf("Cannot burst a %0d-bit memory through a narrower data path (%0d bytes)", get_n_bits(), rw.local_map.get_n_bytes()*8));
                 rw.status = UVM_NOT_OK;
                 return 0;
              end
              if (rw.offset + rw.value.size() > m_size) begin
                 `uvm_error("RegModel", $sformatf("Burst of size 'd%0d starting at offset 'd%0d exceeds size of memory, 'd%0d", rw.value.size(), rw.offset, m_size))
                 return 0;
              end
           end
        end
   
        if (rw.map == null)
          rw.map = rw.local_map;
      end
   
      return 1;
   endfunction
   
   
   
   
   virtual task poke(output uvm_status_e      status, input  uvm_reg_addr_t    offset, input  uvm_reg_data_t    value, input  string            kind = "", input  uvm_sequence_base parent = null, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      uvm_reg_item rw;
      uvm_reg_backdoor bkdr = get_backdoor();
   
      m_fname = fname;
      m_lineno = lineno;
   
      if (bkdr == null && !has_hdl_path(kind)) begin
         `uvm_error("RegModel", {"No backdoor access available in memory '", get_full_name(),"'"})
         status = UVM_NOT_OK;
         return;
      end
   
      rw = uvm_reg_item::type_id::create("mem_poke_item",,get_full_name());
      rw.element      = this;
      rw.path         = UVM_BACKDOOR;
      rw.element_kind = UVM_MEM;
      rw.kind         = UVM_WRITE;
      rw.offset       = offset;
      rw.value[0]     = value & ((1 << m_n_bits)-1);
      rw.bd_kind      = kind;
      rw.parent       = parent;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      if (bkdr != null)
        bkdr.write(rw);
      else
        backdoor_write(rw);
   
      status = rw.status;
   
      `uvm_info("RegModel", $sformatf("Poked memory '%s[%0d]' with value 'h%h", get_full_name(), offset, value),UVM_HIGH);
   
   endtask: poke
   
   
   
   virtual task peek(output uvm_status_e      status, input  uvm_reg_addr_t    offset, output uvm_reg_data_t    value, input  string            kind = "", input  uvm_sequence_base parent = null, input  uvm_object        extension = null, input  string            fname = "", input  int               lineno = 0);
      uvm_reg_backdoor bkdr = get_backdoor();
      uvm_reg_item rw;
   
      m_fname = fname;
      m_lineno = lineno;
   
      if (bkdr == null && !has_hdl_path(kind)) begin
         `uvm_error("RegModel", {"No backdoor access available in memory '", get_full_name(),"'"})
         status = UVM_NOT_OK;
         return;
      end
   
      rw = uvm_reg_item::type_id::create("mem_peek_item",,get_full_name());
      rw.element      = this;
      rw.path         = UVM_BACKDOOR;
      rw.element_kind = UVM_MEM;
      rw.kind         = UVM_READ;
      rw.offset       = offset;
      rw.bd_kind      = kind;
      rw.parent       = parent;
      rw.extension    = extension;
      rw.fname        = fname;
      rw.lineno       = lineno;
   
      if (bkdr != null)
        bkdr.read(rw);
      else
        backdoor_read(rw);
   
      status = rw.status;
      value  = rw.value[0];
   
      `uvm_info("RegModel", $sformatf("Peeked memory '%s[%0d]' has value 'h%h", get_full_name(), offset, value),UVM_HIGH);
   endtask: peek
   
   
   
   
   virtual function void set_frontdoor(uvm_reg_frontdoor ftdr, uvm_reg_map       map = null, string            fname = "", int               lineno = 0);
      uvm_reg_map_info map_info;
      m_fname = fname;
      m_lineno = lineno;
   
      map = get_local_map(map, "set_frontdoor()");
   
      if (map == null) begin
         `uvm_error("RegModel", {"Memory '",get_full_name(), "' not found in map '", map.get_full_name(),"'"})
         return;
      end
   
      map_info = map.get_mem_map_info(this);
      map_info.frontdoor = ftdr;
   
   endfunction: set_frontdoor
   
   
   
   virtual function uvm_reg_frontdoor get_frontdoor(uvm_reg_map map = null);
      uvm_reg_map_info map_info;
   
      map = get_local_map(map, "set_frontdoor()");
   
      if (map == null) begin
         `uvm_error("RegModel", {"Memory '",get_full_name(), "' not found in map '", map.get_full_name(),"'"}) 
	 return null;
      end
   
      map_info = map.get_mem_map_info(this);
      return map_info.frontdoor;
   
   endfunction: get_frontdoor
   
   
   
   
   virtual function void set_backdoor(uvm_reg_backdoor bkdr, string fname = "", int lineno = 0);
      m_fname = fname;
      m_lineno = lineno;
      m_backdoor = bkdr;
   endfunction: set_backdoor
   
   
   
   virtual function uvm_reg_backdoor get_backdoor(bit inherited = 1);
      
      if (m_backdoor == null && inherited) begin
        uvm_reg_block blk = get_parent();
        uvm_reg_backdoor bkdr;
        while (blk != null) begin
          bkdr = blk.get_backdoor();
          if (bkdr != null) begin
            m_backdoor = bkdr;
            break;
          end
          blk = blk.get_parent();
        end
      end
   
      return m_backdoor;
   endfunction: get_backdoor
   
   
   
   virtual function uvm_status_e backdoor_read_func(uvm_reg_item rw);
   
     uvm_hdl_path_concat paths[$];
     uvm_hdl_data_t val;
     bit ok=1;
   
     get_full_hdl_path(paths,rw.bd_kind);
   
     foreach (rw.value[mem_idx]) begin
        string idx;
        idx.itoa(rw.offset + mem_idx);
        foreach (paths[i]) begin
           uvm_hdl_path_concat hdl_concat = paths[i];
           val = 0;
           foreach (hdl_concat.slices[j]) begin
              string hdl_path = {hdl_concat.slices[j].path, "[", idx, "]"};
   
              `uvm_info("RegModel", {"backdoor_read from ",hdl_path},UVM_DEBUG)
    
              if (hdl_concat.slices[j].offset < 0) begin
                 ok &= uvm_hdl_read(hdl_path, val);
                 continue;
              end
              begin
                 uvm_reg_data_t slice;
                 int k = hdl_concat.slices[j].offset;
                 ok &= uvm_hdl_read(hdl_path, slice);
                 repeat (hdl_concat.slices[j].size) begin
                    val[k++] = slice[0];
                    slice >>= 1;
                 end
              end
           end
   
           val &= (1 << m_n_bits)-1;
   
           if (i == 0)
              rw.value[mem_idx] = val;
   
           if (val != rw.value[mem_idx]) begin
              `uvm_error("RegModel", $sformatf("Backdoor read of register %s with multiple HDL copies: values are not the same: %0h at path '%s', and %0h at path '%s'. Returning first value.", get_full_name(), rw.value[mem_idx], uvm_hdl_concat2string(paths[0]), val, uvm_hdl_concat2string(paths[i]))); 
              return UVM_NOT_OK;
            end
         end
     end
   
     rw.status = (ok) ? UVM_IS_OK : UVM_NOT_OK;
   
     return rw.status;
   endfunction
   
   
   
   virtual protected task backdoor_read(uvm_reg_item rw);
     rw.status = backdoor_read_func(rw);
   endtask
   
   
   
   virtual task backdoor_write(uvm_reg_item rw);
   
     uvm_hdl_path_concat paths[$];
     bit ok=1;
   
      
     get_full_hdl_path(paths,rw.bd_kind);
      
     foreach (rw.value[mem_idx]) begin
        string idx;
        idx.itoa(rw.offset + mem_idx);
        foreach (paths[i]) begin
          uvm_hdl_path_concat hdl_concat = paths[i];
          foreach (hdl_concat.slices[j]) begin
             `uvm_info("RegModel", $sformatf("backdoor_write to %s ",hdl_concat.slices[j].path),UVM_DEBUG);
    
             if (hdl_concat.slices[j].offset < 0) begin
                ok &= uvm_hdl_deposit({hdl_concat.slices[j].path,"[", idx, "]"},rw.value[mem_idx]);
                continue;
             end
             begin
               uvm_reg_data_t slice;
               slice = rw.value[mem_idx] >> hdl_concat.slices[j].offset;
               slice &= (1 << hdl_concat.slices[j].size)-1;
               ok &= uvm_hdl_deposit({hdl_concat.slices[j].path, "[", idx, "]"}, slice);
             end
          end
        end
     end
     rw.status = (ok ? UVM_IS_OK : UVM_NOT_OK);
   endtask
   
   
   
   
   
   virtual function void clear_hdl_path(string kind = "RTL");
     if (kind == "ALL") begin
       m_hdl_paths_pool = new("hdl_paths");
       return;
     end
   
     if (kind == "")
       kind = m_parent.get_default_hdl_path();
   
     if (!m_hdl_paths_pool.exists(kind)) begin
       `uvm_warning("RegModel",{"Unknown HDL Abstraction '",kind,"'"})
       return;
     end
   
     m_hdl_paths_pool.delete(kind);
   endfunction
   
   
   
   virtual function void add_hdl_path(uvm_hdl_path_slice slices[], string kind = "RTL");
       uvm_queue #(uvm_hdl_path_concat) paths = m_hdl_paths_pool.get(kind);
       uvm_hdl_path_concat concat = new();
   
       concat.set(slices);
       paths.push_back(concat);  
   endfunction
   
   
   
   virtual function void add_hdl_path_slice(string name, int offset, int size, bit first = 0, string kind = "RTL");
       uvm_queue #(uvm_hdl_path_concat) paths=m_hdl_paths_pool.get(kind);
       uvm_hdl_path_concat concat;
   
       if (first || paths.size() == 0) begin
          concat = new();
          paths.push_back(concat);
       end
       else
          concat = paths.get(paths.size()-1);
        
       concat.add_path(name, offset, size);
   endfunction
   
   
   
   virtual function bit  has_hdl_path(string kind = "");
     if (kind == "")
       kind = m_parent.get_default_hdl_path();
     
     return m_hdl_paths_pool.exists(kind);
   endfunction
   
   
   
   virtual function void get_hdl_path(ref uvm_hdl_path_concat paths[$], input string kind = "");
   
     uvm_queue #(uvm_hdl_path_concat) hdl_paths;
   
     if (kind == "")
        kind = m_parent.get_default_hdl_path();
   
     if (!has_hdl_path(kind)) begin
       `uvm_error("RegModel", {"Memory does not have hdl path defined for abstraction '",kind,"'"})
       return;
     end
   
     hdl_paths = m_hdl_paths_pool.get(kind);
   
     for (int i=0; i<hdl_paths.size();i++) begin
        uvm_hdl_path_concat t = hdl_paths.get(i);
        paths.push_back(t);
     end
   
   endfunction
   
   
   
   virtual function void get_hdl_path_kinds (ref string kinds[$]);
     string kind;
     kinds.delete();
     if (!m_hdl_paths_pool.first(kind))
       return;
     do
       kinds.push_back(kind);
     while (m_hdl_paths_pool.next(kind));
   endfunction
   
   
   virtual function void get_full_hdl_path(ref uvm_hdl_path_concat paths[$], input string kind = "", input string separator = ".");
   
      if (kind == "")
         kind = m_parent.get_default_hdl_path();
      
      if (!has_hdl_path(kind)) begin
         `uvm_error("RegModel", {"Memory does not have hdl path defined for abstraction '",kind,"'"})
         return;
      end
   
      begin
         uvm_queue #(uvm_hdl_path_concat) hdl_paths = m_hdl_paths_pool.get(kind);
         string parent_paths[$];
   
         m_parent.get_full_hdl_path(parent_paths, kind, separator);
   
         for (int i=0; i<hdl_paths.size();i++) begin
            uvm_hdl_path_concat hdl_concat = hdl_paths.get(i);
   
            foreach (parent_paths[j])  begin
               uvm_hdl_path_concat t = new;
   
               foreach (hdl_concat.slices[k]) begin
                  if (hdl_concat.slices[k].path == "")
                     t.add_path(parent_paths[j]);
                  else
                     t.add_path({ parent_paths[j], separator, hdl_concat.slices[k].path },
                                hdl_concat.slices[k].offset,
                                hdl_concat.slices[k].size);
               end
               paths.push_back(t);
            end
         end
      end
   endfunction
   
   
   
   virtual function void set_parent(uvm_reg_block parent);
     m_parent = parent;
   endfunction
   
   
   
   virtual function uvm_reg_block get_parent();
      return get_block();
   endfunction
   
   
   
   virtual function string convert2string();
   
      string res_str;
      string prefix;
   
      $sformat(convert2string, "%sMemory %s -- %0dx%0d bits", prefix, get_full_name(), get_size(), get_n_bits());
   
      if (m_maps.num()==0)
        convert2string = {convert2string, "  (unmapped)\n"};
      else
        convert2string = {convert2string, "\n"};
      foreach (m_maps[map]) begin
        uvm_reg_map parent_map = map;
        int unsigned offset;
        while (parent_map != null) begin
          uvm_reg_map this_map = parent_map;
          uvm_endianness_e endian_name;
          parent_map = this_map.get_parent_map();
          endian_name=this_map.get_endian();
          
          offset = parent_map == null ? this_map.get_base_addr(UVM_NO_HIER) : parent_map.get_submap_offset(this_map);
          prefix = {prefix, "  "};
          $sformat(convert2string, "%sMapped in '%s' -- buswidth %0d bytes, %s, offset 'h%0h, size 'h%0h, %s\n", prefix, this_map.get_full_name(), this_map.get_n_bytes(), endian_name.name(), offset,get_size(),get_access(this_map));
        end
      end
      prefix = "  ";
      if (m_read_in_progress == 1'b1) begin
         if (m_fname != "" && m_lineno != 0)
            $sformat(res_str, "%s:%0d ",m_fname, m_lineno);
         convert2string = {convert2string, "  ", res_str, "currently executing read method"}; 
      end
      if ( m_write_in_progress == 1'b1) begin
         if (m_fname != "" && m_lineno != 0)
            $sformat(res_str, "%s:%0d ",m_fname, m_lineno);
         convert2string = {convert2string, "  ", res_str, "currently executing write method"}; 
      end
   endfunction
   
   
   
   virtual function void do_print (uvm_printer printer);
     super.do_print(printer);
     printer.print_field_int("n_bits",get_n_bits(),32, UVM_UNSIGNED);
     printer.print_field_int("size",get_size(),32, UVM_UNSIGNED);
   endfunction
   
   
   
   virtual function uvm_object clone();
     `uvm_fatal("RegModel","RegModel memories cannot be cloned")
     return null;
   endfunction
   
   
   virtual function void do_copy(uvm_object rhs);
     `uvm_fatal("RegModel","RegModel memories cannot be copied")
   endfunction
   
   
   
   virtual function bit do_compare (uvm_object  rhs, uvm_comparer comparer);
     `uvm_warning("RegModel","RegModel memories cannot be compared")
     return 0;
   endfunction
   
   
   
   virtual function void do_pack (uvm_packer packer);
     `uvm_warning("RegModel","RegModel memories cannot be packed")
   endfunction
   
   
   
   virtual function void do_unpack (uvm_packer packer);
     `uvm_warning("RegModel","RegModel memories cannot be unpacked")
   endfunction
   
   
   
   virtual function void Xadd_vregX(uvm_vreg vreg);
     m_vregs[vreg] = 1;
   endfunction
   
   
   
   virtual function void Xdelete_vregX(uvm_vreg vreg);
      if (m_vregs.exists(vreg))
        m_vregs.delete(vreg);
   endfunction


endclass: uvm_mem

class uvm_reg_map_info;
   uvm_reg_addr_t         offset;
   string                 rights;
   bit                    unmapped;
   uvm_reg_addr_t         addr[];
   uvm_reg_frontdoor      frontdoor;
   uvm_reg_map_addr_range mem_range; 
   bit                    is_initialized;
endclass

virtual class uvm_reg_transaction_order_policy extends uvm_object;
    function new(string name = "policy");
        super.new(name);
    endfunction
    pure virtual function void order(ref uvm_reg_bus_op q[$]);
endclass

class uvm_reg_map extends uvm_object;

   `uvm_object_utils(uvm_reg_map)
   
   local uvm_reg_addr_t     m_base_addr;
   local int unsigned       m_n_bytes;
   local uvm_endianness_e   m_endian;
   local bit                m_byte_addressing;
   local uvm_object_wrapper m_sequence_wrapper;
   local uvm_reg_adapter    m_adapter;
   local uvm_sequencer_base m_sequencer;
   local bit                m_auto_predict;
   local bit                m_check_on_read;
   local uvm_reg_block      m_parent;
   local int unsigned       m_system_n_bytes;
   local uvm_reg_map        m_parent_map;
   local uvm_reg_addr_t     m_parent_maps[uvm_reg_map];   
   local uvm_reg_addr_t     m_submaps[uvm_reg_map];       
   local string             m_submap_rights[uvm_reg_map]; 
   local uvm_reg_map_info   m_regs_info[uvm_reg];
   local uvm_reg_map_info   m_mems_info[uvm_mem];
   local uvm_reg            m_regs_by_offset[uvm_reg_addr_t];
   local uvm_reg            m_regs_by_offset_wo[uvm_reg_addr_t]; 
   local uvm_mem            m_mems_by_offset[uvm_reg_map_addr_range];
   local uvm_reg_transaction_order_policy policy;
   static local uvm_reg_map   m_backdoor;

   static function uvm_reg_map backdoor();
      if (m_backdoor == null)
        m_backdoor = new("Backdoor");
      return m_backdoor;
   endfunction

   function new(string name = "uvm_reg_map");
      super.new((name == "") ? "default_map" : name);
      m_auto_predict = 0;
      m_check_on_read = 0;
   endfunction

   function void configure(uvm_reg_block    parent, uvm_reg_addr_t   base_addr, int unsigned     n_bytes, uvm_endianness_e endian, bit              byte_addressing=1);
     m_parent     = parent;
     m_n_bytes    = n_bytes;
     m_endian     = endian;
     m_base_addr  = base_addr;
     m_byte_addressing = byte_addressing;
   endfunction: configure

   virtual function void add_reg(uvm_reg rg, uvm_reg_addr_t offset, string rights = "RW", bit unmapped=0, uvm_reg_frontdoor frontdoor=null);
   
      if (m_regs_info.exists(rg)) begin
         `uvm_error("RegModel", {"Register '",rg.get_name(), "' has already been added to map '",get_name(),"'"})
         return;
      end
   
      if (rg.get_parent() != get_parent()) begin
         `uvm_error("RegModel", {"Register '",rg.get_full_name(),"' may not be added to address map '", get_full_name(),"' : they are not in the same block"})
         return;
      end
      
      rg.add_map(this);
   
      begin
      uvm_reg_map_info info = new;
      info.offset   = offset;
      info.rights   = rights;
      info.unmapped = unmapped;
      info.frontdoor = frontdoor;
      m_regs_info[rg] = info;
      end
   endfunction

   virtual function void add_mem(uvm_mem mem, uvm_reg_addr_t offset, string rights = "RW", bit unmapped=0, uvm_reg_frontdoor frontdoor=null);
      if (m_mems_info.exists(mem)) begin
         `uvm_error("RegModel", {"Memory '",mem.get_name(), "' has already been added to map '",get_name(),"'"})
         return;
      end
   
      if (mem.get_parent() != get_parent()) begin
         `uvm_error("RegModel", {"Memory '",mem.get_full_name(),"' may not be added to address map '", get_full_name(),"' : they are not in the same block"})
         return;
      end
      
      mem.add_map(this);
   
      begin
      uvm_reg_map_info info = new;
      info.offset   = offset;
      info.rights   = rights;
      info.unmapped = unmapped;
      info.frontdoor = frontdoor;
      m_mems_info[mem] = info;
      end
   endfunction: add_mem

   virtual function void add_submap (uvm_reg_map child_map, uvm_reg_addr_t offset);
      uvm_reg_map parent_map;
   
      if (child_map == null) begin
         `uvm_error("RegModel", {"Attempting to add NULL map to map '",get_full_name(),"'"})
         return;
      end
   
      parent_map = child_map.get_parent_map();
   
      if (parent_map != null) begin
         `uvm_error("RegModel", {"Map '", child_map.get_full_name(), "' is already a child of map '", parent_map.get_full_name(), "'. Cannot also be a child of map '", get_full_name(), "'"})
         return;
      end
   
      begin : parent_block_check
        uvm_reg_block child_blk = child_map.get_parent();
        if (child_blk == null) begin
           `uvm_error("RegModel", {"Cannot add submap '",child_map.get_full_name(), "' because it does not have a parent block"})
           return;
        end
        while((child_blk!=null) && (child_blk.get_parent() != get_parent()))
   	     	child_blk = child_blk.get_parent();
        
        if (child_blk==null) begin
           `uvm_error("RegModel", {"Submap '",child_map.get_full_name(),"' may not be added to this ", "address map, '", get_full_name(),"', as the submap's parent block, '", child_blk.get_full_name(),"', is neither this map's parent block nor a descendent of this map's parent block, '", m_parent.get_full_name(),"'"})
         return;
        end
      end
      
      begin : n_bytes_match_check
         if (m_n_bytes > child_map.get_n_bytes(UVM_NO_HIER)) begin
            `uvm_warning("RegModel", $sformatf("Adding %0d-byte submap '%s' to %0d-byte parent map '%s'", child_map.get_n_bytes(UVM_NO_HIER), child_map.get_full_name(), m_n_bytes, get_full_name()));
         end
      end
   
      child_map.add_parent_map(this,offset);
   
      set_submap_offset(child_map, offset);
   
   endfunction: add_submap


   function void set_auto_predict(bit on=1); m_auto_predict = on; endfunction


   function bit  get_auto_predict(); return m_auto_predict; endfunction


   function void set_check_on_read(bit on=1);
      m_check_on_read = on;
      foreach (m_submaps[submap]) begin
         submap.set_check_on_read(on);
      end
   endfunction


   function bit  get_check_on_read(); return m_check_on_read; endfunction

   virtual function void set_transaction_order_policy(uvm_reg_transaction_order_policy pol);
        policy = pol;
   endfunction
    
   virtual function uvm_reg_transaction_order_policy get_transaction_order_policy();
        return policy;
   endfunction    
   
   virtual function void m_set_reg_offset(uvm_reg rg, uvm_reg_addr_t offset, bit unmapped);
   
      if (!m_regs_info.exists(rg)) begin
         `uvm_error("RegModel", {"Cannot modify offset of register '",rg.get_full_name(), "' in address map '",get_full_name(), "' : register not mapped in that address map"})
         return;
      end
   
      begin
         uvm_reg_map_info info    = m_regs_info[rg];
         uvm_reg_block    blk     = get_parent();
         uvm_reg_map      top_map = get_root_map();
         uvm_reg_addr_t   addrs[];
   
         if (blk.is_locked()) begin
   
            if (!info.unmapped) begin
              foreach (info.addr[i]) begin
   
                 if (!top_map.m_regs_by_offset_wo.exists(info.addr[i])) begin
                    top_map.m_regs_by_offset.delete(info.addr[i]);
                 end
                 else begin
                    if (top_map.m_regs_by_offset[info.addr[i]] == rg) begin
                       top_map.m_regs_by_offset[info.addr[i]] = 
                         top_map.m_regs_by_offset_wo[info.addr[i]];
                       uvm_reg_read_only_cbs::remove(rg);
                       uvm_reg_write_only_cbs::remove(top_map.m_regs_by_offset[info.addr[i]]);
                    end
                    else begin
                       uvm_reg_write_only_cbs::remove(rg);
                       uvm_reg_read_only_cbs::remove(top_map.m_regs_by_offset[info.addr[i]]);
                    end
                    top_map.m_regs_by_offset_wo.delete(info.addr[i]);
                 end
              end
            end
   
            if (!unmapped) begin
               string rg_acc = rg.Xget_fields_accessX(this);
               
               void'(get_physical_addresses(offset,0,rg.get_n_bytes(),addrs));
   
               foreach (addrs[i]) begin
                  uvm_reg_addr_t addr = addrs[i];
                  if (top_map.m_regs_by_offset.exists(addr)) begin
   
                     uvm_reg rg2 = top_map.m_regs_by_offset[addr];
                     string rg2_acc = rg2.Xget_fields_accessX(this);
   
                     if (rg_acc == "RO" && rg2_acc == "WO") begin
                        top_map.m_regs_by_offset[addr]    = rg;
                        uvm_reg_read_only_cbs::add(rg);
                        top_map.m_regs_by_offset_wo[addr] = rg2;
                        uvm_reg_write_only_cbs::add(rg2);
                     end
                     else if (rg_acc == "WO" && rg2_acc == "RO") begin
                        top_map.m_regs_by_offset_wo[addr] = rg;
                        uvm_reg_write_only_cbs::add(rg);
                        uvm_reg_read_only_cbs::add(rg2);
                     end
                     else begin
                        string a;
                        a = $sformatf("%0h",addr);
                        `uvm_warning("RegModel", {"In map '",get_full_name(),"' register '", rg.get_full_name(), "' maps to same address as register '", top_map.m_regs_by_offset[addr].get_full_name(),"': 'h",a})
		     end
                  end
                  else
                     top_map.m_regs_by_offset[addr] = rg;
   
                  foreach (top_map.m_mems_by_offset[range]) begin
                     if (addrs[i] >= range.min && addrs[i] <= range.max) begin
                       string a;
                       a = $sformatf("%0h",addrs[i]);
                       `uvm_warning("RegModel", {"In map '",get_full_name(),"' register '", rg.get_full_name(), "' overlaps with address range of memory '", top_map.m_mems_by_offset[range].get_full_name(),"': 'h",a})
                     end
                  end
               end
               info.addr = addrs; 
            end
         end
   
         if (unmapped) begin
           info.offset   = -1;
           info.unmapped = 1;
         end
         else begin
           info.offset   = offset;
           info.unmapped = 0;
         end
         
      end
   endfunction
   
   virtual function void m_set_mem_offset(uvm_mem mem, uvm_reg_addr_t offset, bit unmapped);
   
      if (!m_mems_info.exists(mem)) begin
         `uvm_error("RegModel", {"Cannot modify offset of memory '",mem.get_full_name(), "' in address map '",get_full_name(), "' : memory not mapped in that address map"})
         return;
      end
   
      begin
         uvm_reg_map_info info    = m_mems_info[mem];
         uvm_reg_block    blk     = get_parent();
         uvm_reg_map      top_map = get_root_map();
         uvm_reg_addr_t   addrs[];
   
         if (blk.is_locked()) begin
   
            if (!info.unmapped) begin
              foreach (top_map.m_mems_by_offset[range]) begin
                 if (top_map.m_mems_by_offset[range] == mem)
                    top_map.m_mems_by_offset.delete(range);
              end
            end
   
            if (!unmapped) begin
               uvm_reg_addr_t addrs[],addrs_max[];
               uvm_reg_addr_t min, max, min2, max2;
               int unsigned stride;
   
               void'(get_physical_addresses(offset,0,mem.get_n_bytes(),addrs));
               min = (addrs[0] < addrs[addrs.size()-1]) ? addrs[0] : addrs[addrs.size()-1];
               min2 = addrs[0];
   
               void'(get_physical_addresses(offset,(mem.get_size()-1),
                                            mem.get_n_bytes(),addrs_max));
               max = (addrs_max[0] > addrs_max[addrs_max.size()-1]) ?
                  addrs_max[0] : addrs_max[addrs_max.size()-1];
               max2 = addrs_max[0];
               stride = (max2 - max)/(mem.get_size()-1);
   
               foreach (top_map.m_regs_by_offset[reg_addr]) begin
                  if (reg_addr >= min && reg_addr <= max) begin
                     string a,b;
                     a = $sformatf("[%0h:%0h]",min,max);
                     b = $sformatf("%0h",reg_addr);
                     `uvm_warning("RegModel", {"In map '",get_full_name(),"' memory '", mem.get_full_name(), "' with range ",a, " overlaps with address of existing register '", top_map.m_regs_by_offset[reg_addr].get_full_name(),"': 'h",b})
                  end
               end
   
               foreach (top_map.m_mems_by_offset[range]) begin
                  if (min <= range.max && max >= range.max ||
                      min <= range.min && max >= range.min ||
                      min >= range.min && max <= range.max) begin
                    string a,b;
                    a = $sformatf("[%0h:%0h]",min,max);
                    b = $sformatf("[%0h:%0h]",range.min,range.max);
                    `uvm_warning("RegModel", {"In map '",get_full_name(),"' memory '", mem.get_full_name(), "' with range ",a, " overlaps existing memory with range '", top_map.m_mems_by_offset[range].get_full_name(),"': ",b})
                    end
               end
   
               begin
                 uvm_reg_map_addr_range range = '{ min, max, stride };
                 top_map.m_mems_by_offset[range] = mem;
                 info.addr  = addrs;
                 info.mem_range = range;
               end
   
            end
         end
   
         if (unmapped) begin
           info.offset   = -1;
           info.unmapped = 1;
         end
         else begin
           info.offset   = offset;
           info.unmapped = 0;
         end
         
      end
   endfunction
   
   virtual function void reset(string kind = "SOFT");
      uvm_reg regs[$];
   
      get_registers(regs);
   
      foreach (regs[i]) begin
         regs[i].reset(kind);
      end
   endfunction
   
   virtual function void add_parent_map(uvm_reg_map parent_map, uvm_reg_addr_t offset);
   
      if (parent_map == null) begin
         `uvm_error("RegModel", {"Attempting to add NULL parent map to map '",get_full_name(),"'"})
         return;
      end
   
      if (m_parent_map != null) begin
         `uvm_error("RegModel",
             $sformatf("Map \"%s\" already a submap of map \"%s\" at offset 'h%h", get_full_name(), m_parent_map.get_full_name(), m_parent_map.get_submap_offset(this)));
         return;
      end
   
      m_parent_map = parent_map;
      m_parent_maps[parent_map] = offset; 
      parent_map.m_submaps[this] = offset;
   
   endfunction: add_parent_map
   
   virtual function void set_sequencer(uvm_sequencer_base sequencer, uvm_reg_adapter adapter=null);
   
      if (sequencer == null) begin
         `uvm_error("REG_NULL_SQR", "Null reference specified for bus sequencer");
         return;
      end
   
      if (adapter == null) begin
         `uvm_info("REG_NO_ADAPT", {"Adapter not specified for map '",get_full_name(), "'. Accesses via this map will send abstract 'uvm_reg_item' items to sequencer '", sequencer.get_full_name(),"'"},UVM_MEDIUM)
      end
   
      m_sequencer = sequencer;
      m_adapter = adapter;
   endfunction
     
   virtual function uvm_reg_block get_parent();
     return m_parent;
   endfunction
   
   virtual function uvm_reg_map get_parent_map();
     return m_parent_map;
   endfunction
   
   virtual function uvm_reg_map get_root_map();
      return (m_parent_map == null) ? this : m_parent_map.get_root_map();
   endfunction: get_root_map
   
   virtual function uvm_reg_addr_t  get_base_addr(uvm_hier_e hier=UVM_HIER);
     uvm_reg_map child = this;
     if (hier == UVM_NO_HIER || m_parent_map == null)
       return m_base_addr;
     get_base_addr = m_parent_map.get_submap_offset(this);
     get_base_addr += m_parent_map.get_base_addr(UVM_HIER);
   endfunction
   
   virtual function int unsigned get_n_bytes(uvm_hier_e hier=UVM_HIER);
     if (hier == UVM_NO_HIER)
       return m_n_bytes;
     return m_system_n_bytes;
   endfunction
   
   virtual function int unsigned get_addr_unit_bytes();
      return (m_byte_addressing) ? 1 : m_n_bytes;
   endfunction
   
   virtual function uvm_endianness_e get_endian(uvm_hier_e hier=UVM_HIER);
     if (hier == UVM_NO_HIER || m_parent_map == null)
       return m_endian;
     return m_parent_map.get_endian(hier);
   endfunction
   
   virtual function uvm_sequencer_base get_sequencer(uvm_hier_e hier=UVM_HIER);
     if (hier == UVM_NO_HIER || m_parent_map == null)
       return m_sequencer;
     return m_parent_map.get_sequencer(hier);
   endfunction
   
   virtual function uvm_reg_adapter get_adapter(uvm_hier_e hier=UVM_HIER);
     if (hier == UVM_NO_HIER || m_parent_map == null)
       return m_adapter;
     return m_parent_map.get_adapter(hier);
   endfunction
   
   virtual function void get_submaps(ref uvm_reg_map maps[$], input uvm_hier_e hier=UVM_HIER);
   
      foreach (m_submaps[submap])
        maps.push_back(submap);
   
      
      if (hier == UVM_HIER)
        foreach (m_submaps[submap_]) begin
          uvm_reg_map submap=submap_;
          submap.get_submaps(maps);
        end
   endfunction
   
   virtual function void get_registers(ref uvm_reg regs[$], input uvm_hier_e hier=UVM_HIER);
   
     foreach (m_regs_info[rg])
       regs.push_back(rg);
   
     if (hier == UVM_HIER)
       foreach (m_submaps[submap_]) begin
         uvm_reg_map submap=submap_;
         submap.get_registers(regs);
       end
   
   endfunction
   
   virtual function void get_fields(ref uvm_reg_field fields[$], input uvm_hier_e hier=UVM_HIER);
   
      foreach (m_regs_info[rg_]) begin
        uvm_reg rg = rg_;
        rg.get_fields(fields);
      end
      
      if (hier == UVM_HIER)
        foreach (this.m_submaps[submap_]) begin
          uvm_reg_map submap=submap_;
          submap.get_fields(fields);
        end
   
   endfunction
   
   virtual function void get_memories(ref uvm_mem mems[$], input uvm_hier_e hier=UVM_HIER);
   
      foreach (m_mems_info[mem])
        mems.push_back(mem);
       
      if (hier == UVM_HIER)
        foreach (m_submaps[submap_]) begin
          uvm_reg_map submap=submap_;
          submap.get_memories(mems);
        end
   
   endfunction
   
   virtual function void get_virtual_registers(ref uvm_vreg regs[$], input uvm_hier_e hier=UVM_HIER);
   
     uvm_mem mems[$];
     get_memories(mems,hier);
   
     foreach (mems[i])
       mems[i].get_virtual_registers(regs);
   
   endfunction
   
   virtual function void get_virtual_fields(ref uvm_vreg_field fields[$], input uvm_hier_e hier=UVM_HIER);
   
      uvm_vreg regs[$];
      get_virtual_registers(regs,hier);
   
      foreach (regs[i])
          regs[i].get_fields(fields);
   
   endfunction
   
   virtual function string get_full_name();
   
      get_full_name = get_name();
   
      if (m_parent == null)
        return get_full_name;
   
      return {m_parent.get_full_name(), ".", get_full_name};
   
   endfunction: get_full_name
   
   virtual function uvm_reg_map_info get_mem_map_info(uvm_mem mem, bit error=1);
     if (!m_mems_info.exists(mem)) begin
       if (error)
         `uvm_error("REG_NO_MAP",{"Memory '",mem.get_name(),"' not in map '",get_name(),"'"})
       return null;
     end
     return m_mems_info[mem];
   endfunction
   
   virtual function uvm_reg_map_info get_reg_map_info(uvm_reg rg, bit error=1);
     uvm_reg_map_info result;
     if (!m_regs_info.exists(rg)) begin
       if (error)
         `uvm_error("REG_NO_MAP",{"Register '",rg.get_name(),"' not in map '",get_name(),"'"})
       return null;
     end
     result = m_regs_info[rg];
     if(!result.is_initialized)
       `uvm_warning("RegModel",{"map '",get_name(),"' does not seem to be initialized correctly, check that the top register model is locked()"})
       
     return result;
   endfunction
   
   virtual function void set_base_addr(uvm_reg_addr_t offset);
      if (m_parent_map != null) begin
         m_parent_map.set_submap_offset(this, offset);
      end
      else begin
         m_base_addr = offset;
         if (m_parent.is_locked()) begin
            uvm_reg_map top_map = get_root_map();
            top_map.Xinit_address_mapX();
         end
      end
   endfunction
   
   virtual function int unsigned get_size();
   
     int unsigned max_addr;
     int unsigned addr;
   
     foreach (m_regs_info[rg_]) begin
       uvm_reg rg = rg_;
       addr = m_regs_info[rg].offset + ((rg.get_n_bytes()-1)/m_n_bytes);
       if (addr > max_addr) max_addr = addr;
     end
   
     foreach (m_mems_info[mem_]) begin
       uvm_mem mem = mem_;
       addr = m_mems_info[mem].offset + (mem.get_size() * (((mem.get_n_bytes()-1)/m_n_bytes)+1)) -1;
       if (addr > max_addr) max_addr = addr;
     end
   
     foreach (m_submaps[submap_]) begin
       uvm_reg_map submap=submap_;
       addr = m_submaps[submap] + submap.get_size();
       if (addr > max_addr) max_addr = addr;
     end
   
     return max_addr + 1;
   
   endfunction
   
   virtual function void Xverify_map_configX();
      bit error;
      uvm_reg_map root_map = get_root_map();
   
      if (root_map.get_adapter() == null) begin
         `uvm_error("RegModel", {"Map '",root_map.get_full_name(), "' does not have an adapter registered"})
         error++;
      end
      if (root_map.get_sequencer() == null) begin
         `uvm_error("RegModel", {"Map '",root_map.get_full_name(), "' does not have a sequencer registered"})
         error++;
      end
      if (error) begin
         `uvm_fatal("RegModel", {"Must register an adapter and sequencer ", "for each top-level map in RegModel model"});
         return;
      end
   
   endfunction
   
   virtual function int get_physical_addresses(uvm_reg_addr_t     base_addr, uvm_reg_addr_t     mem_offset, int unsigned       n_bytes, ref uvm_reg_addr_t addr[]);
      int bus_width = get_n_bytes(UVM_NO_HIER);
      uvm_reg_map  up_map;
      uvm_reg_addr_t  local_addr[];
      int multiplier = m_byte_addressing ? bus_width : 1;
   
      addr = new [0];
      
      if (n_bytes <= 0) begin
         `uvm_fatal("RegModel", $sformatf("Cannot access %0d bytes. Must be greater than 0", n_bytes));
         return 0;
      end
   
      if (n_bytes <= bus_width) begin
         local_addr = new [1];
         local_addr[0] = base_addr + (mem_offset * multiplier);
      end else begin
         int n;
   
         n = ((n_bytes-1) / bus_width) + 1;
         local_addr = new [n];
         
         base_addr = base_addr + mem_offset * (n * multiplier);
   
         case (get_endian(UVM_NO_HIER))
            UVM_LITTLE_ENDIAN: begin
               foreach (local_addr[i]) begin
                  local_addr[i] = base_addr + (i * multiplier);
               end
            end
            UVM_BIG_ENDIAN: begin
               foreach (local_addr[i]) begin
                  n--;
                  local_addr[i] = base_addr + (n * multiplier);
               end
            end
            UVM_LITTLE_FIFO: begin
               foreach (local_addr[i]) begin
                  local_addr[i] = base_addr;
               end
            end
            UVM_BIG_FIFO: begin
               foreach (local_addr[i]) begin
                  local_addr[i] = base_addr;
               end
            end
            default: begin
               `uvm_error("RegModel", {"Map has no specified endianness. ", $sformatf("Cannot access %0d bytes register via its %0d byte \"%s\" interface", n_bytes, bus_width, get_full_name())})
            end
         endcase
      end
   
     up_map = get_parent_map();
   
      if (up_map == null) begin
         addr = new [local_addr.size()] (local_addr);
         foreach (addr[i]) begin
            addr[i] += m_base_addr;
         end
      end else begin
         uvm_reg_addr_t  sys_addr[];
         uvm_reg_addr_t  base_addr;
         int w, k;
   
         if (bus_width < up_map.get_n_bytes(UVM_NO_HIER))
           k = 1;
         else
           k = ((bus_width-1) / up_map.get_n_bytes(UVM_NO_HIER)) + 1;
   
         base_addr = up_map.get_submap_offset(this);
         foreach (local_addr[i]) begin
            int n = addr.size();
            
            w = up_map.get_physical_addresses(base_addr + local_addr[i] * k,
                                              0,
                                              bus_width,
                                              sys_addr);
   
            addr = new [n + sys_addr.size()] (addr);
            foreach (sys_addr[j]) begin
               addr[n+j] = sys_addr[j];
            end
         end
         if (w < bus_width)
            bus_width = w;
      end
   
      return bus_width;
   
   endfunction: get_physical_addresses
   
   virtual function void set_submap_offset(uvm_reg_map submap, uvm_reg_addr_t offset);
     if (submap == null) begin
       `uvm_error("REG/NULL","set_submap_offset: submap handle is null")
       return;
     end
     m_submaps[submap] = offset;
     if (m_parent.is_locked()) begin
       uvm_reg_map root_map = get_root_map();
       root_map.Xinit_address_mapX();
     end
   endfunction
   
   virtual function uvm_reg_addr_t get_submap_offset(uvm_reg_map submap);
     if (submap == null) begin
       `uvm_error("REG/NULL","set_submap_offset: submap handle is null")
       return -1;
     end
     if (!m_submaps.exists(submap)) begin
       `uvm_error("RegModel",{"Map '",submap.get_full_name(), "' is not a submap of '",get_full_name(),"'"})
       return -1;
     end
     return m_submaps[submap];
   endfunction
   
   virtual function uvm_reg get_reg_by_offset(uvm_reg_addr_t offset,
                                                   bit            read = 1);
      if (!m_parent.is_locked()) begin
         `uvm_error("RegModel", $sformatf("Cannot get register by offset: Block %s is not locked.", m_parent.get_full_name()));
         return null;
      end
   
      if (!read && m_regs_by_offset_wo.exists(offset))
        return m_regs_by_offset_wo[offset];
      
      if (m_regs_by_offset.exists(offset))
        return m_regs_by_offset[offset];
   
      return null;
   endfunction
   
   virtual function uvm_mem get_mem_by_offset(uvm_reg_addr_t offset);
      if (!m_parent.is_locked()) begin
         `uvm_error("RegModel", $sformatf("Cannot memory register by offset: Block %s is not locked.", m_parent.get_full_name()));
         return null;
      end
   
      foreach (m_mems_by_offset[range]) begin
         if (range.min <= offset && offset <= range.max) begin
            return m_mems_by_offset[range];
         end
      end
      
      return null;
   endfunction
   
   virtual function void Xinit_address_mapX();
   
      int unsigned bus_width;
   
      uvm_reg_map top_map = get_root_map();
   
      if (this == top_map) begin
        top_map.m_regs_by_offset.delete();
        top_map.m_regs_by_offset_wo.delete();
        top_map.m_mems_by_offset.delete();
      end
   
      foreach (m_submaps[l]) begin
        uvm_reg_map map=l;
        map.Xinit_address_mapX();
      end
   
      foreach (m_regs_info[rg_]) begin
        uvm_reg rg = rg_;
        m_regs_info[rg].is_initialized=1;
        if (!m_regs_info[rg].unmapped) begin
           string rg_acc = rg.Xget_fields_accessX(this);
          uvm_reg_addr_t addrs[];
           
          bus_width = get_physical_addresses(m_regs_info[rg].offset,0,rg.get_n_bytes(),addrs);
           
          foreach (addrs[i]) begin
            uvm_reg_addr_t addr = addrs[i];
   
            if (top_map.m_regs_by_offset.exists(addr)) begin
   
               uvm_reg rg2 = top_map.m_regs_by_offset[addr];
               string rg2_acc = rg2.Xget_fields_accessX(this);
               
               if (rg_acc == "RO" && rg2_acc == "WO") begin
                  top_map.m_regs_by_offset[addr]    = rg;
                  uvm_reg_read_only_cbs::add(rg);
                  top_map.m_regs_by_offset_wo[addr] = rg2;
                  uvm_reg_write_only_cbs::add(rg2);
               end
               else if (rg_acc == "WO" && rg2_acc == "RO") begin
                  top_map.m_regs_by_offset_wo[addr] = rg;
                  uvm_reg_write_only_cbs::add(rg);
                  uvm_reg_read_only_cbs::add(rg2);
               end
               else begin
                  string a;
                  a = $sformatf("%0h",addr);
                  `uvm_warning("RegModel", {"In map '",get_full_name(),"' register '", rg.get_full_name(), "' maps to same address as register '", top_map.m_regs_by_offset[addr].get_full_name(),"': 'h",a})
               end
            end
            else
               top_map.m_regs_by_offset[addr] = rg;
             
            foreach (top_map.m_mems_by_offset[range]) begin
              if (addr >= range.min && addr <= range.max) begin
                string a,b;
                a = $sformatf("%0h",addr);
                b = $sformatf("[%0h:%0h]",range.min,range.max);
                `uvm_warning("RegModel", {"In map '",get_full_name(),"' register '", rg.get_full_name(), "' with address ",a, "maps to same address as memory '", top_map.m_mems_by_offset[range].get_full_name(),"': ",b})
                end
            end
          end
          m_regs_info[rg].addr = addrs;
        end
      end
   
      foreach (m_mems_info[mem_]) begin
        uvm_mem mem = mem_;
        if (!m_mems_info[mem].unmapped) begin
   
          uvm_reg_addr_t addrs[],addrs_max[];
          uvm_reg_addr_t min, max, min2, max2;
          int unsigned stride;
   
          bus_width = get_physical_addresses(m_mems_info[mem].offset,0,mem.get_n_bytes(),addrs);
          min = (addrs[0] < addrs[addrs.size()-1]) ? addrs[0] : addrs[addrs.size()-1];
          min2 = addrs[0];
   
          void'(get_physical_addresses(m_mems_info[mem].offset,(mem.get_size()-1),mem.get_n_bytes(),addrs_max));
          max = (addrs_max[0] > addrs_max[addrs_max.size()-1]) ? addrs_max[0] : addrs_max[addrs_max.size()-1];
          max2 = addrs_max[0];
          stride = (max2 - min2)/(mem.get_size()-1);
   
          foreach (top_map.m_regs_by_offset[reg_addr]) begin
            if (reg_addr >= min && reg_addr <= max) begin
              string a;
              a = $sformatf("%0h",reg_addr);
              `uvm_warning("RegModel", {"In map '",get_full_name(),"' memory '", mem.get_full_name(), "' maps to same address as register '", top_map.m_regs_by_offset[reg_addr].get_full_name(),"': 'h",a})
            end
          end
   
          foreach (top_map.m_mems_by_offset[range]) begin
            if (min <= range.max && max >= range.max ||
                min <= range.min && max >= range.min ||
                min >= range.min && max <= range.max) begin
              string a;
              a = $sformatf("[%0h:%0h]",min,max);
              `uvm_warning("RegModel", {"In map '",get_full_name(),"' memory '", mem.get_full_name(), "' overlaps with address range of memory '", top_map.m_mems_by_offset[range].get_full_name(),"': 'h",a})
              end
          end
   
          begin
            uvm_reg_map_addr_range range = '{ min, max, stride };
            top_map.m_mems_by_offset[ range ] = mem;
            m_mems_info[mem].addr  = addrs;
            m_mems_info[mem].mem_range = range;
          end
        end
      end
   
      if (bus_width == 0) bus_width = m_n_bytes;
   
      m_system_n_bytes = bus_width;
   endfunction
   
   virtual function void Xget_bus_infoX(uvm_reg_item rw, output uvm_reg_map_info map_info, output int size, output int lsb, output int addr_skip);
   
     if (rw.element_kind == UVM_MEM) begin
       uvm_mem mem;
       if(rw.element == null || !$cast(mem,rw.element))
         `uvm_fatal("REG/CAST", {"uvm_reg_item 'element_kind' is UVM_MEM, ", "but 'element' does not point to a memory: ",rw.get_name()})
       map_info = get_mem_map_info(mem);
       size = mem.get_n_bits();
     end
     else if (rw.element_kind == UVM_REG) begin
       uvm_reg rg;
       if(rw.element == null || !$cast(rg,rw.element))
         `uvm_fatal("REG/CAST", {"uvm_reg_item 'element_kind' is UVM_REG, ", "but 'element' does not point to a register: ",rw.get_name()})
       map_info = get_reg_map_info(rg);
       size = rg.get_n_bits();
     end
     else if (rw.element_kind == UVM_FIELD) begin
       uvm_reg_field field;
       if(rw.element == null || !$cast(field,rw.element))
         `uvm_fatal("REG/CAST", {"uvm_reg_item 'element_kind' is UVM_FIELD, ", "but 'element' does not point to a field: ",rw.get_name()})
       map_info = get_reg_map_info(field.get_parent());
       size = field.get_n_bits();
       lsb = field.get_lsb_pos();
       addr_skip = lsb/(get_n_bytes()*8);
     end
   endfunction
   
   virtual task do_write(uvm_reg_item rw);
   
     uvm_sequence_base tmp_parent_seq;
     uvm_reg_map system_map = get_root_map();
     uvm_reg_adapter adapter = system_map.get_adapter();
     uvm_sequencer_base sequencer = system_map.get_sequencer();
   
     if (adapter != null && adapter.parent_sequence != null) begin
       uvm_object o;
       uvm_sequence_base seq;
       o = adapter.parent_sequence.clone();
       assert($cast(seq,o));
       seq.set_parent_sequence(rw.parent);
       rw.parent = seq;
       tmp_parent_seq = seq;
     end
   
     if (rw.parent == null) begin
        rw.parent = new("default_parent_seq");
        tmp_parent_seq = rw.parent;
     end
   
     if (adapter == null) begin
       rw.set_sequencer(sequencer);
       rw.parent.start_item(rw,rw.prior);
       rw.parent.finish_item(rw);
       rw.end_event.wait_on();
     end
     else begin
       do_bus_write(rw, sequencer, adapter);
     end
   
     if (tmp_parent_seq != null)
       sequencer.m_sequence_exiting(tmp_parent_seq);
   
   endtask
   
   virtual task do_read(uvm_reg_item rw);
   
     uvm_sequence_base tmp_parent_seq;
     uvm_reg_map system_map = get_root_map();
     uvm_reg_adapter adapter = system_map.get_adapter();
     uvm_sequencer_base sequencer = system_map.get_sequencer();
   
     if (adapter != null && adapter.parent_sequence != null) begin
       uvm_object o;
       uvm_sequence_base seq;
       o = adapter.parent_sequence.clone();
       assert($cast(seq,o));
       seq.set_parent_sequence(rw.parent);
       rw.parent = seq;
       tmp_parent_seq = seq;
     end
   
     if (rw.parent == null) begin
       rw.parent = new("default_parent_seq");
       tmp_parent_seq = rw.parent;
     end
   
     if (adapter == null) begin
       rw.set_sequencer(sequencer);
       rw.parent.start_item(rw,rw.prior);
       rw.parent.finish_item(rw);
       rw.end_event.wait_on();
     end
     else begin
       do_bus_read(rw, sequencer, adapter);
     end
   
     if (tmp_parent_seq != null)
       sequencer.m_sequence_exiting(tmp_parent_seq);
   
   endtask
   
   virtual task do_bus_write (uvm_reg_item rw, uvm_sequencer_base sequencer, uvm_reg_adapter adapter);
   
     uvm_reg_addr_t     addrs[$];
     uvm_reg_map        system_map = get_root_map();
     int unsigned       bus_width  = get_n_bytes();
     uvm_reg_byte_en_t  byte_en    = -1;
     uvm_reg_map_info   map_info;
     int                n_bits;
     int                lsb;
     int                skip;
     int unsigned       curr_byte;
     int                n_access_extra, n_access;
     int               n_bits_init;
     uvm_reg_bus_op    accesses[$];
   
     Xget_bus_infoX(rw, map_info, n_bits_init, lsb, skip);
     addrs=map_info.addr;
   
     if (rw.element_kind == UVM_MEM)
       foreach (addrs[i])
         addrs[i] = addrs[i] + map_info.mem_range.stride * rw.offset;
   
     foreach (rw.value[val_idx]) begin: foreach_value
   
        uvm_reg_data_t value = rw.value[val_idx];
   
       if (rw.element_kind == UVM_FIELD) begin
         int temp_be;
         int idx;
         n_access_extra = lsb%(bus_width*8);                
         n_access = n_access_extra + n_bits_init;
         temp_be = n_access_extra;
         value = value << n_access_extra;
         while(temp_be >= 8) begin
            byte_en[idx++] = 0;
            temp_be -= 8;
         end                        
         temp_be += n_bits_init;
         while(temp_be > 0) begin
            byte_en[idx++] = 1;
            temp_be -= 8;
         end
         byte_en &= (1<<idx)-1;
         for (int i=0; i<skip; i++)
           void'(addrs.pop_front());
         while (addrs.size() > (n_bits_init/(bus_width*8) + 1))
           void'(addrs.pop_back());
       end
       curr_byte=0;
       n_bits= n_bits_init;     
                 
       accesses.delete();         
       foreach(addrs[i]) begin: foreach_addr
         uvm_reg_bus_op rw_access;
         uvm_reg_data_t data;
   
         data = (value >> (curr_byte*8)) & ((1'b1 << (bus_width * 8))-1);
          
         `uvm_info(get_type_name(), $sformatf("Writing 'h%0h at 'h%0h via map \"%s\"...", data, addrs[i], rw.map.get_full_name()), UVM_FULL);
   
         if (rw.element_kind == UVM_FIELD) begin
           for (int z=0;z<bus_width;z++)
             rw_access.byte_en[z] = byte_en[curr_byte+z];
         end
                   
         rw_access.kind    = rw.kind;
         rw_access.addr    = addrs[i];
         rw_access.data    = data;
         rw_access.n_bits  = (n_bits > bus_width*8) ? bus_width*8 : n_bits;
         rw_access.byte_en = byte_en;
   
         accesses.push_back(rw_access); 
   
         curr_byte += bus_width;
         n_bits -= bus_width * 8;
   
       end: foreach_addr
       
       if(policy!=null)
           policy.order(accesses);
       
       foreach(accesses[i]) begin     
         uvm_reg_bus_op rw_access=accesses[i];  
         uvm_sequence_item bus_req;
           
         adapter.m_set_item(rw);
         bus_req = adapter.reg2bus(rw_access);
         adapter.m_set_item(null);
         
         if (bus_req == null)
           `uvm_fatal("RegMem",{"adapter [",adapter.get_name(),"] didnt return a bus transaction"});
         
         bus_req.set_sequencer(sequencer);
         rw.parent.start_item(bus_req,rw.prior);
   
         if (rw.parent != null && i == 0)
           rw.parent.mid_do(rw);
   
         rw.parent.finish_item(bus_req);
         bus_req.end_event.wait_on();
   
         if (adapter.provides_responses) begin
           uvm_sequence_item bus_rsp;
           uvm_access_e op;
           rw.parent.get_base_response(bus_rsp);
           adapter.bus2reg(bus_rsp,rw_access);
         end
         else begin
           adapter.bus2reg(bus_req,rw_access);
         end
   
         if (rw.parent != null && i == addrs.size()-1)
           rw.parent.post_do(rw);
   
         rw.status = rw_access.status;
   
         `uvm_info(get_type_name(), $sformatf("Wrote 'h%0h at 'h%0h via map \"%s\": %s...", rw_access.data, addrs[i], rw.map.get_full_name(), rw.status.name()), UVM_FULL)
   
         if (rw.status == UVM_NOT_OK)
            break;
           
       end
   
       foreach (addrs[i])
         addrs[i] = addrs[i] + map_info.mem_range.stride;
   
     end: foreach_value
   
   endtask: do_bus_write
   
   virtual task do_bus_read (uvm_reg_item rw, uvm_sequencer_base sequencer, uvm_reg_adapter adapter);
   
     uvm_reg_addr_t addrs[$];
     uvm_reg_map        system_map = get_root_map();
     int unsigned       bus_width  = get_n_bytes();
     uvm_reg_byte_en_t  byte_en    = -1;
     uvm_reg_map_info   map_info;
     int                size, n_bits;
     int                skip;
     int                lsb;
     int unsigned       curr_byte;
     int n_access_extra, n_access;
     uvm_reg_bus_op accesses[$];
   
     Xget_bus_infoX(rw, map_info, n_bits, lsb, skip);
     addrs=map_info.addr;
     size = n_bits;
   
     if (rw.element_kind == UVM_MEM)
       foreach (addrs[i])
         addrs[i] = addrs[i] + map_info.mem_range.stride * rw.offset;
   
     foreach (rw.value[val_idx]) begin: foreach_value
   
       if (rw.element_kind == UVM_FIELD) begin
         int temp_be;
         int idx;
         n_access_extra = lsb%(bus_width*8);                
         n_access = n_access_extra + n_bits;
         temp_be = n_access_extra;
         while(temp_be >= 8) begin
            byte_en[idx++] = 0;
            temp_be -= 8;
         end                        
         temp_be += n_bits;
         while(temp_be > 0) begin
            byte_en[idx++] = 1;
            temp_be -= 8;
         end
         byte_en &= (1<<idx)-1;
         for (int i=0; i<skip; i++)
           void'(addrs.pop_front());
         while (addrs.size() > (n_bits/(bus_width*8) + 1))
           void'(addrs.pop_back());
       end
       curr_byte=0;
       rw.value[val_idx] = 0;
                 
       accesses.delete();
       foreach (addrs[i]) begin
         uvm_reg_bus_op rw_access;
          
         `uvm_info(get_type_name(), $sformatf("Reading address 'h%0h via map \"%s\"...", addrs[i], get_full_name()), UVM_FULL);
                   
         if (rw.element_kind == UVM_FIELD)
           for (int z=0;z<bus_width;z++)
             rw_access.byte_en[z] = byte_en[curr_byte+z];
   
         rw_access.kind = rw.kind;
         rw_access.addr = addrs[i];
         rw_access.data = curr_byte;
         rw_access.byte_en = byte_en;
         rw_access.n_bits = (n_bits > bus_width*8) ? bus_width*8 : n_bits;
                             
          accesses.push_back(rw_access);
   
         curr_byte += bus_width;
         n_bits -= bus_width * 8;
       end
       
       if(policy!=null)
           policy.order(accesses);
           
       foreach(accesses[i]) begin     
         uvm_reg_bus_op rw_access=accesses[i];  
         uvm_sequence_item bus_req;
         uvm_reg_data_logic_t data;   
         int unsigned curr_byte_;   
               
         curr_byte_=rw_access.data;
         rw_access.data='0;
         adapter.m_set_item(rw);
         bus_req = adapter.reg2bus(rw_access);
         adapter.m_set_item(null);
         if (bus_req == null)
           `uvm_fatal("RegMem",{"adapter [",adapter.get_name(),"] didnt return a bus transaction"});
   
         bus_req.set_sequencer(sequencer);
         rw.parent.start_item(bus_req,rw.prior);
   
         if (rw.parent != null && i == 0) begin
           rw.parent.mid_do(rw);
         end
   
         rw.parent.finish_item(bus_req);
         bus_req.end_event.wait_on();
   
         if (adapter.provides_responses) begin
           uvm_sequence_item bus_rsp;
           uvm_access_e op;
           rw.parent.get_base_response(bus_rsp);
           adapter.bus2reg(bus_rsp,rw_access);
         end
         else begin
           adapter.bus2reg(bus_req,rw_access);
         end
   
         data = rw_access.data & ((1<<bus_width*8)-1); 
   
         rw.status = rw_access.status;
   
         if (rw.status == UVM_IS_OK && (^data) === 1'bx)
           rw.status = UVM_HAS_X;
            
         `uvm_info(get_type_name(), $sformatf("Read 'h%0h at 'h%0h via map \"%s\": %s...", data, addrs[i], get_full_name(), rw.status.name()), UVM_FULL);
   
         if (rw.status == UVM_NOT_OK)
            break;
   
         rw.value[val_idx] |= data << curr_byte_*8;
   
         if (rw.parent != null && i == addrs.size()-1)
           rw.parent.post_do(rw);
       end
       
   
       foreach (addrs[i])
         addrs[i] = addrs[i] + map_info.mem_range.stride;
   
       if (rw.element_kind == UVM_FIELD)
          rw.value[val_idx] = (rw.value[val_idx] >> (n_access_extra)) & ((1<<size)-1);
     end
   
   endtask: do_bus_read
   
   
   virtual function void do_print (uvm_printer printer);
      uvm_reg  regs[$];
      uvm_vreg vregs[$];
      uvm_mem  mems[$];
      uvm_endianness_e endian;
      uvm_reg_map maps[$];
      string prefix;
      uvm_sequencer_base sqr=get_sequencer();
     
      super.do_print(printer);
   
      endian = get_endian(UVM_NO_HIER);
      
      printer.print_generic("endian","",-2,endian.name()); 
      if(sqr!=null)
       printer.print_generic("effective sequencer",sqr.get_type_name(),-2,sqr.get_full_name());     
                
      get_registers(regs,UVM_NO_HIER);
      foreach (regs[j]) 
           printer.print_generic(regs[j].get_name(), regs[j].get_type_name(),-2,$sformatf("@%0d +'h%0x",regs[j].get_inst_id(),regs[j].get_address(this)));
      
      
      get_memories(mems);
      foreach (mems[j]) 
           printer.print_generic(mems[j].get_name(), mems[j].get_type_name(),-2,$sformatf("@%0d +'h%0x",mems[j].get_inst_id(),mems[j].get_address(0,this)));
      
      get_virtual_registers(vregs);
      foreach (vregs[j]) 
           printer.print_generic(vregs[j].get_name(), vregs[j].get_type_name(),-2,$sformatf("@%0d +'h%0x",vregs[j].get_inst_id(),vregs[j].get_address(0,this)));
       
      get_submaps(maps);
      foreach (maps[j]) 
           printer.print_object(maps[j].get_name(),maps[j]);
   endfunction
   
   virtual function string convert2string();
      uvm_reg  regs[$];
      uvm_vreg vregs[$];
      uvm_mem  mems[$];
      uvm_endianness_e endian;
      string prefix;
   
      $sformat(convert2string, "%sMap %s", prefix, get_full_name());
      endian = get_endian(UVM_NO_HIER);
      $sformat(convert2string, "%s -- %0d bytes (%s)", convert2string, get_n_bytes(UVM_NO_HIER), endian.name());
      get_registers(regs);
      foreach (regs[j]) begin
         $sformat(convert2string, "%s\n%s", convert2string, regs[j].convert2string());
      end
      get_memories(mems);
      foreach (mems[j]) begin
         $sformat(convert2string, "%s\n%s", convert2string, mems[j].convert2string());
      end
      get_virtual_registers(vregs);
      foreach (vregs[j]) begin
         $sformat(convert2string, "%s\n%s", convert2string, vregs[j].convert2string());
      end
   endfunction
   
   virtual function uvm_object clone();
     return null;
   endfunction

   virtual function void do_copy (uvm_object rhs);
   
   endfunction

endclass: uvm_reg_map


virtual class uvm_reg_block extends uvm_object;

   local uvm_reg_block  parent;
   local static bit     m_roots[uvm_reg_block];
   local int unsigned   blks[uvm_reg_block];
   local int unsigned   regs[uvm_reg];
   local int unsigned   vregs[uvm_vreg];
   local int unsigned   mems[uvm_mem];
   local bit            maps[uvm_reg_map];
   uvm_path_e      default_path = UVM_DEFAULT_PATH;
   local string         default_hdl_path = "RTL";
   local uvm_reg_backdoor backdoor;
   local uvm_object_string_pool #(uvm_queue #(string)) hdl_paths_pool;
   local string         root_hdl_paths[string];
   local bit            locked;
   local int            has_cover;
   local int            cover_on;
   local string         fname;
   local int            lineno;
   local static int id;
   uvm_reg_map default_map;

   protected virtual function void  sample(uvm_reg_addr_t offset, bit            is_read, uvm_reg_map    map);
   endfunction

   protected static function bit check_data_width(int unsigned width);
      if (width <= $bits(uvm_reg_data_t)) return 1;
   
      `uvm_fatal("RegModel", $sformatf("Register model requires that UVM_REG_DATA_WIDTH be defined as %0d or greater. Currently defined as %0d", width, `UVM_REG_DATA_WIDTH))
   
      return 0;
   endfunction
   
   function new(string name="", int has_coverage=UVM_NO_COVERAGE);
      super.new(name);
      hdl_paths_pool = new("hdl_paths");
      this.has_cover = has_coverage;
      m_roots[this] = 0;
   endfunction: new
   
   function void configure(uvm_reg_block parent=null, string hdl_path="");
     this.parent = parent; 
     if (parent != null)
       this.parent.add_block(this);
     add_hdl_path(hdl_path);
   
     uvm_resource_db#(uvm_reg_block)::set("uvm_reg::*", get_full_name(), this);
   endfunction
   
   
   function void add_block (uvm_reg_block blk);
      if (this.is_locked()) begin
         `uvm_error("RegModel", "Cannot add subblock to locked block model");
         return;
      end
      if (this.blks.exists(blk)) begin
         `uvm_error("RegModel", {"Subblock '",blk.get_name(), "' has already been registered with block '",get_name(),"'"})
          return;
      end
      blks[blk] = id++;
      if (m_roots.exists(blk)) m_roots.delete(blk);
   endfunction
   
   
   function void add_reg(uvm_reg rg);
      if (this.is_locked()) begin
         `uvm_error("RegModel", "Cannot add register to locked block model");
         return;
      end
   
      if (this.regs.exists(rg)) begin
         `uvm_error("RegModel", {"Register '",rg.get_name(),
            "' has already been registered with block '",get_name(),"'"})
          return;
      end
   
      regs[rg] = id++;
   endfunction: add_reg
   
   
   function void add_vreg(uvm_vreg vreg);
      if (this.is_locked()) begin
         `uvm_error("RegModel", "Cannot add virtual register to locked block model");
         return;
      end
   
      if (this.vregs.exists(vreg)) begin
         `uvm_error("RegModel", {"Virtual register '",vreg.get_name(), "' has already been registered with block '",get_name(),"'"})
          return;
      end
      vregs[vreg] = id++;
   endfunction: add_vreg
   
   
   function void add_mem(uvm_mem mem);
      if (this.is_locked()) begin
         `uvm_error("RegModel", "Cannot add memory to locked block model");
         return;
      end
   
      if (this.mems.exists(mem)) begin
         `uvm_error("RegModel", {"Memory '",mem.get_name(), "' has already been registered with block '",get_name(),"'"})
          return;
      end
      mems[mem] = id++;
   endfunction: add_mem
   
   
   virtual function void set_parent(uvm_reg_block parent);
     if (this != parent)
       this.parent = parent;
   endfunction
   
   
   function bit is_locked();
      return this.locked;
   endfunction: is_locked
   
   
   virtual function void lock_model();
   
      if (is_locked())
        return;
   
      locked = 1;
   
      foreach (regs[rg_]) begin
         uvm_reg rg = rg_;
         rg.Xlock_modelX();
      end
   
      foreach (mems[mem_]) begin
         uvm_mem mem = mem_;
         mem.Xlock_modelX();
      end
   
      foreach (blks[blk_]) begin
         uvm_reg_block blk=blk_;
         blk.lock_model();
      end
   
      if (this.parent == null) begin
         int max_size = uvm_reg::get_max_size();
   
         if (uvm_reg_field::get_max_size() > max_size)
            max_size = uvm_reg_field::get_max_size();
   
         if (uvm_mem::get_max_size() > max_size)
            max_size = uvm_mem::get_max_size();
   
         if (max_size > `UVM_REG_DATA_WIDTH) begin
            `uvm_fatal("RegModel", $sformatf("Register model requires that UVM_REG_DATA_WIDTH be defined as %0d or greater. Currently defined as %0d", max_size, `UVM_REG_DATA_WIDTH))
         end
   
         Xinit_address_mapsX();
   
   
         if (m_roots[this] != 1) begin
            int n;
   
            foreach (m_roots[_blk]) begin
               uvm_reg_block blk = _blk;
   
               if (blk.get_name() == get_name()) begin
                  m_roots[blk] = 1;
                  n++;
               end
            end
   
            if (n > 1) begin
               `uvm_error("UVM/REG/DUPLROOT", $sformatf("There are %0d root register models named \"%s\". The names of the root register models have to be unique", n, get_name()))
            end
         end
      end
   
   endfunction: lock_model
   
   
   virtual function string get_full_name();
      if (parent == null)
        return get_name();
   
      return {parent.get_full_name(), ".", get_name()};
   
   endfunction: get_full_name
   
   
   virtual function void get_fields(ref uvm_reg_field fields[$], input uvm_hier_e hier=UVM_HIER);
   
      foreach (regs[rg_]) begin
        uvm_reg rg = rg_;
        rg.get_fields(fields);
      end
      
      if (hier == UVM_HIER)
        foreach (blks[blk_])
        begin
          uvm_reg_block blk = blk_;
          blk.get_fields(fields);
        end
   
   endfunction: get_fields
   
   virtual function void get_virtual_fields(ref uvm_vreg_field fields[$], input uvm_hier_e hier=UVM_HIER);
   
      foreach (vregs[vreg_]) begin
        uvm_vreg vreg = vreg_;
        vreg.get_fields(fields);
      end
      
      if (hier == UVM_HIER)
        foreach (blks[blk_]) begin
          uvm_reg_block blk = blk_;
          blk.get_virtual_fields(fields);
        end
   endfunction: get_virtual_fields
   
   
   virtual function void get_registers(ref uvm_reg regs[$], input uvm_hier_e hier=UVM_HIER);
      foreach (this.regs[rg])
        regs.push_back(rg);
   
      if (hier == UVM_HIER)
        foreach (blks[blk_]) begin
          uvm_reg_block blk = blk_;
          blk.get_registers(regs);
        end
   endfunction: get_registers
   
   
   virtual function void get_virtual_registers(ref uvm_vreg regs[$], input uvm_hier_e hier=UVM_HIER);
   
      foreach (vregs[rg])
        regs.push_back(rg);
   
      if (hier == UVM_HIER)
        foreach (blks[blk_]) begin
          uvm_reg_block blk = blk_;
          blk.get_virtual_registers(regs);
        end
   endfunction: get_virtual_registers
   
   
   virtual function void get_memories(ref uvm_mem mems[$], input uvm_hier_e hier=UVM_HIER);
   
      foreach (this.mems[mem_]) begin
        uvm_mem mem = mem_;
        mems.push_back(mem);
      end
   
      if (hier == UVM_HIER)
        foreach (blks[blk_]) begin
          uvm_reg_block blk = blk_;
          blk.get_memories(mems);
        end
   
   endfunction: get_memories
   
   
   
   virtual function void get_blocks(ref uvm_reg_block blks[$], input uvm_hier_e hier=UVM_HIER);
   
      foreach (this.blks[blk_]) begin
        uvm_reg_block blk = blk_;
        blks.push_back(blk);
        if (hier == UVM_HIER)
          blk.get_blocks(blks);
      end
   
   endfunction: get_blocks
   
   
   static function void get_root_blocks(ref uvm_reg_block blks[$]);
   
      foreach (m_roots[blk]) begin
         blks.push_back(blk);
      end
   
   endfunction: get_root_blocks
   
   
   static function int find_blocks(input string        name, ref   uvm_reg_block blks[$], input uvm_reg_block root = null, input uvm_object    accessor = null);
   
      uvm_resource_pool rpl = uvm_resource_pool::get();
      uvm_resource_types::rsrc_q_t rs;
   
      blks.delete();
   
      if (root != null) name = {root.get_full_name(), ".", name};
   
      rs = rpl.lookup_regex(name, "uvm_reg::");
      for (int i = 0; i < rs.size(); i++) begin
         uvm_resource#(uvm_reg_block) blk;
         if (!$cast(blk, rs.get(i))) continue;
         blks.push_back(blk.read(accessor));
      end
      
      return blks.size();
   endfunction
   
   
   static function uvm_reg_block find_block(input string        name, input uvm_reg_block root = null, input uvm_object    accessor = null);
   
      uvm_reg_block blks[$];
      if (!find_blocks(name, blks, root, accessor))
         return null;
   
      if (blks.size() > 1) begin
         `uvm_warning("MRTH1BLK", {"More than one block matched the name \"", name, "\"."})
      end
      
   
      return blks[0];
   endfunction
   
   
   virtual function void get_maps(ref uvm_reg_map maps[$]);
   
      foreach (this.maps[map])
        maps.push_back(map);
   
   endfunction
   
   
   
   virtual function uvm_reg_block get_parent();
      get_parent = this.parent;
   endfunction: get_parent
   
   
   
   
   virtual function uvm_reg_block get_block_by_name(string name);
   
      if (get_name() == name)
        return this;
   
      foreach (blks[blk_]) begin
        uvm_reg_block blk = blk_;
   
        if (blk.get_name() == name)
          return blk;
      end
   
      foreach (blks[blk_]) begin
         uvm_reg_block blk = blk_;
         uvm_reg_block subblks[$];
         blk_.get_blocks(subblks, UVM_HIER);
   
         foreach (subblks[j])
            if (subblks[j].get_name() == name)
               return subblks[j];
      end
   
      `uvm_warning("RegModel", {"Unable to locate block '",name, "' in block '",get_full_name(),"'"})
      return null;
   
   endfunction: get_block_by_name
   
   
   
   virtual function uvm_reg get_reg_by_name(string name);
   
      foreach (regs[rg_]) begin
        uvm_reg rg = rg_;
        if (rg.get_name() == name)
          return rg;
      end
   
      foreach (blks[blk_]) begin
         uvm_reg_block blk = blk_;
         uvm_reg subregs[$];
         blk_.get_registers(subregs, UVM_HIER);
   
         foreach (subregs[j])
            if (subregs[j].get_name() == name)
               return subregs[j];
      end
   
      `uvm_warning("RegModel", {"Unable to locate register '",name, "' in block '",get_full_name(),"'"})
      return null;
   
   endfunction: get_reg_by_name
   
   
   
   virtual function uvm_vreg get_vreg_by_name(string name);
   
      foreach (vregs[rg_]) begin
        uvm_vreg rg = rg_;
        if (rg.get_name() == name)
          return rg;
      end
   
      foreach (blks[blk_]) begin
         uvm_reg_block blk = blk_;
         uvm_vreg subvregs[$];
         blk_.get_virtual_registers(subvregs, UVM_HIER);
   
         foreach (subvregs[j])
            if (subvregs[j].get_name() == name)
               return subvregs[j];
      end
   
      `uvm_warning("RegModel", {"Unable to locate virtual register '",name, "' in block '",get_full_name(),"'"})
      return null;
   
   endfunction: get_vreg_by_name
   
   
   
   virtual function uvm_mem get_mem_by_name(string name);
   
      foreach (mems[mem_]) begin
        uvm_mem mem = mem_;
        if (mem.get_name() == name)
          return mem;
      end
   
      foreach (blks[blk_]) begin
         uvm_reg_block blk = blk_;
         uvm_mem submems[$];
         blk_.get_memories(submems, UVM_HIER);
   
         foreach (submems[j])
            if (submems[j].get_name() == name)
               return submems[j];
      end
   
      `uvm_warning("RegModel", {"Unable to locate memory '",name, "' in block '",get_full_name(),"'"})
      return null;
   
   endfunction: get_mem_by_name
   
   
   
   virtual function uvm_reg_field get_field_by_name(string name);
   
      foreach (regs[rg_]) begin
         uvm_reg rg = rg_;
         uvm_reg_field fields[$];
   
         rg.get_fields(fields);
         foreach (fields[i])
           if (fields[i].get_name() == name)
             return fields[i];
      end
   
      foreach (blks[blk_]) begin
         uvm_reg_block blk = blk_;
         uvm_reg subregs[$];
         blk_.get_registers(subregs, UVM_HIER);
   
         foreach (subregs[j]) begin
            uvm_reg_field fields[$];
            subregs[j].get_fields(fields);
            foreach (fields[i])
               if (fields[i].get_name() == name)
                  return fields[i];
         end
      end
   
      `uvm_warning("RegModel", {"Unable to locate field '",name, "' in block '",get_full_name(),"'"})
   
      return null;
   
   endfunction: get_field_by_name
   
   
   
   function uvm_vreg_field get_vfield_by_name(string name);
   
      foreach (vregs[rg_]) begin
         uvm_vreg rg =rg_;
         uvm_vreg_field fields[$];
   
         rg.get_fields(fields);
         foreach (fields[i])
           if (fields[i].get_name() == name)
             return fields[i];
      end
   
      foreach (blks[blk_]) begin
         uvm_reg_block blk = blk_;
         uvm_vreg subvregs[$];
         blk_.get_virtual_registers(subvregs, UVM_HIER);
   
         foreach (subvregs[j]) begin
            uvm_vreg_field fields[$];
            subvregs[j].get_fields(fields);
            foreach (fields[i])
               if (fields[i].get_name() == name)
                  return fields[i];
         end
      end
   
      `uvm_warning("RegModel", {"Unable to locate virtual field '",name, "' in block '",get_full_name(),"'"})
   
      return null;
   
   endfunction: get_vfield_by_name
   
   
   
   
   
   virtual function uvm_reg_cvr_t set_coverage(uvm_reg_cvr_t is_on);
      this.cover_on = this.has_cover & is_on;
   
      foreach (regs[rg_]) begin
        uvm_reg rg = rg_;
        void'(rg.set_coverage(is_on));
      end
   
      foreach (mems[mem_]) begin
        uvm_mem mem = mem_;
        void'(mem.set_coverage(is_on));
      end
   
      foreach (blks[blk_]) begin
        uvm_reg_block blk = blk_;
        void'(blk.set_coverage(is_on));
      end
   
      return this.cover_on;
   endfunction: set_coverage
   
   
   
   virtual function void sample_values();
      foreach (regs[rg_]) begin
         uvm_reg rg = rg_;
         rg.sample_values();
      end
   
      foreach (blks[blk_]) begin
         uvm_reg_block blk = blk_;
         blk.sample_values();
      end
   endfunction
   
   
   
   function void XsampleX(uvm_reg_addr_t addr, bit            is_read, uvm_reg_map    map); sample(addr, is_read, map);
      if (parent != null) begin
      end
   endfunction
   
   
   protected function uvm_reg_cvr_t build_coverage(uvm_reg_cvr_t models);
      build_coverage = UVM_NO_COVERAGE;
      void'(uvm_reg_cvr_rsrc_db::read_by_name({"uvm_reg::", get_full_name()},
                                              "include_coverage",
                                              build_coverage, this));
      return build_coverage & models;
   endfunction: build_coverage
   
   
   
   virtual protected function void add_coverage(uvm_reg_cvr_t models);
      this.has_cover |= models;
   endfunction: add_coverage
   
   
   
   virtual function bit has_coverage(uvm_reg_cvr_t models);
      return ((this.has_cover & models) == models);
   endfunction: has_coverage
   
   
   
   virtual function bit get_coverage(uvm_reg_cvr_t is_on = UVM_CVR_ALL);
      if (this.has_coverage(is_on) == 0) return 0;
      return ((this.cover_on & is_on) == is_on);
   endfunction: get_coverage
   
   
   
   
   
   virtual function void reset(string kind = "HARD");
   
      foreach (regs[rg_]) begin
        uvm_reg rg = rg_;
        rg.reset(kind);
      end
   
      foreach (blks[blk_]) begin
        uvm_reg_block blk = blk_;
        blk.reset(kind);
      end
   endfunction
   
   
   
   virtual function bit needs_update();
      needs_update = 0;
   
      foreach (regs[rg_]) begin
        uvm_reg rg = rg_;
        if (rg.needs_update())
          return 1;
      end
      foreach (blks[blk_]) begin
        uvm_reg_block blk =blk_;
        if (blk.needs_update())
          return 1;
      end
   endfunction: needs_update
   
   
   virtual task update(output uvm_status_e  status, input  uvm_path_e    path = UVM_DEFAULT_PATH, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      status = UVM_IS_OK;
   
      if (!needs_update()) begin
        `uvm_info("RegModel", $sformatf("%s:%0d - RegModel block %s does not need updating", fname, lineno, this.get_name()), UVM_HIGH);
         return;
      end
      
      `uvm_info("RegModel", $sformatf("%s:%0d - Updating model block %s with %s path", fname, lineno, this.get_name(), path.name ), UVM_HIGH);
   
      foreach (regs[rg_]) begin
         uvm_reg rg = rg_;
         if (rg.needs_update()) begin
            rg.update(status, path, null, parent, prior, extension);
            if (status != UVM_IS_OK && status != UVM_HAS_X) begin;
              `uvm_error("RegModel", $sformatf("Register \"%s\" could not be updated", rg.get_full_name()));
              return;
            end
         end
      end
   
      foreach (blks[blk_]) begin
        uvm_reg_block blk = blk_;
        blk.update(status,path,parent,prior,extension,fname,lineno);
      end
   endtask: update
   
   
   
   virtual task mirror(output uvm_status_e       status, input  uvm_check_e        check = UVM_NO_CHECK, input  uvm_path_e         path = UVM_DEFAULT_PATH, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_status_e final_status = UVM_IS_OK;
   
      foreach (regs[rg_]) begin 
         uvm_reg rg = rg_;
         rg.mirror(status, check, path, null,
                   parent, prior, extension, fname, lineno);
         if (status != UVM_IS_OK && status != UVM_HAS_X) begin;
            final_status = status;
         end
      end
   
      foreach (blks[blk_]) begin
         uvm_reg_block blk = blk_;
   
         blk.mirror(status, check, path, parent, prior, extension, fname, lineno);
         if (status != UVM_IS_OK && status != UVM_HAS_X) begin;
            final_status = status;
         end
      end
      
   endtask: mirror
   
   
   
   virtual task write_reg_by_name(output uvm_status_e   status, input  string              name, input  uvm_reg_data_t      data, input  uvm_path_e     path = UVM_DEFAULT_PATH, input  uvm_reg_map      map = null, input  uvm_sequence_base   parent = null, input  int                 prior = -1, input  uvm_object          extension = null, input  string              fname = "", input  int                 lineno = 0);
      uvm_reg rg;
      this.fname = fname;
      this.lineno = lineno;
   
      status = UVM_NOT_OK;
      rg = this.get_reg_by_name(name);
      if (rg != null)
        rg.write(status, data, path, map, parent, prior, extension);
   
   endtask: write_reg_by_name
   
   
   
   virtual task read_reg_by_name(output uvm_status_e  status, input  string             name, output uvm_reg_data_t     data, input  uvm_path_e    path = UVM_DEFAULT_PATH, input  uvm_reg_map     map = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_reg rg;
      this.fname = fname;
      this.lineno = lineno;
   
      status = UVM_NOT_OK;
      rg = this.get_reg_by_name(name);
      if (rg != null)
        rg.read(status, data, path, map, parent, prior, extension);
   endtask: read_reg_by_name
   
   
   
   virtual task write_mem_by_name(output uvm_status_e  status, input  string             name, input  uvm_reg_addr_t     offset, input  uvm_reg_data_t     data, input  uvm_path_e    path = UVM_DEFAULT_PATH, input  uvm_reg_map     map = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_mem mem;
      this.fname = fname;
      this.lineno = lineno;
   
      status = UVM_NOT_OK;
      mem = get_mem_by_name(name);
      if (mem != null)
        mem.write(status, offset, data, path, map, parent, prior, extension);
   endtask: write_mem_by_name
   
   
   
   virtual task read_mem_by_name(output uvm_status_e  status, input  string             name, input  uvm_reg_addr_t     offset, output uvm_reg_data_t     data, input  uvm_path_e    path = UVM_DEFAULT_PATH, input  uvm_reg_map     map = null, input  uvm_sequence_base  parent = null, input  int                prior = -1, input  uvm_object         extension = null, input  string             fname = "", input  int                lineno = 0);
      uvm_mem mem;
      this.fname = fname;
      this.lineno = lineno;
   
      status = UVM_NOT_OK;
      mem = get_mem_by_name(name);
      if (mem != null)
        mem.read(status, offset, data, path, map, parent, prior, extension);
   endtask: read_mem_by_name
   
   virtual task readmemh(string filename);
   endtask: readmemh
   
   
   virtual task writememh(string filename);
   endtask: writememh
   
   
   virtual function uvm_reg_map create_map(string name, uvm_reg_addr_t base_addr, int unsigned n_bytes, uvm_endianness_e endian, bit byte_addressing=1);
   
      uvm_reg_map  map;
   
      if (this.locked) begin
         `uvm_error("RegModel", "Cannot add map to locked model");
         return null;
      end
   
      map = uvm_reg_map::type_id::create(name,,this.get_full_name());
      map.configure(this,base_addr,n_bytes,endian,byte_addressing);
   
      this.maps[map] = 1;
      if (maps.num() == 1)
        default_map = map;
   
      return map;
   endfunction
   
   
   function void add_map(uvm_reg_map map);
   
      if (this.locked) begin
         `uvm_error("RegModel", "Cannot add map to locked model");
         return;
      end
   
      if (this.maps.exists(map)) begin
         `uvm_error("RegModel", {"Map '",map.get_name(),
                    "' already exists in '",get_full_name(),"'"})
         return;
      end
   
      this.maps[map] = 1;
      if (maps.num() == 1)
        default_map = map;
   
   endfunction: add_map
   
   
   virtual function uvm_reg_map get_map_by_name(string name);
      uvm_reg_map maps[$];
   
      this.get_maps(maps);
   
      foreach (maps[i])
        if (maps[i].get_name() == name)
          return maps[i];
   
      foreach (maps[i]) begin
         uvm_reg_map submaps[$];
         maps[i].get_submaps(submaps, UVM_HIER);
   
         foreach (submaps[j])
            if (submaps[j].get_name() == name)
               return submaps[j];
      end
         
   
      `uvm_warning("RegModel", {"Map with name '",name,"' does not exist in block"})
      return null;
   endfunction
   
   
   
   function void set_default_map(uvm_reg_map map);
     if (!maps.exists(map))
      `uvm_warning("RegModel", {"Map '",map.get_full_name(),"' does not exist in block"})
     default_map = map;
   endfunction
   
   
   
   function uvm_reg_map get_default_map();
     return default_map;
   endfunction
   
   
   
   virtual function uvm_path_e get_default_path();
   
      if (this.default_path != UVM_DEFAULT_PATH)
         return this.default_path;
   
      if (this.parent != null)
         return this.parent.get_default_path();
   
      return UVM_FRONTDOOR;
   
   endfunction
   
   
   
   local function void Xinit_address_mapsX();
      foreach (maps[map_]) begin
         uvm_reg_map map = map_;
         map.Xinit_address_mapX();
      end
   endfunction
   
   
   function void set_backdoor(uvm_reg_backdoor bkdr, string               fname = "", int                  lineno = 0);
      bkdr.fname = fname;
      bkdr.lineno = lineno;
      if (this.backdoor != null &&
          this.backdoor.has_update_threads()) begin
         `uvm_warning("RegModel", "Previous register backdoor still has update threads running. Backdoors with active mirroring should only be set before simulation starts.");
      end
      this.backdoor = bkdr;
   endfunction: set_backdoor
   
   
   
   function uvm_reg_backdoor get_backdoor(bit inherited = 1);
      if (backdoor == null && inherited) begin
        uvm_reg_block blk = get_parent();
        while (blk != null) begin
          uvm_reg_backdoor bkdr = blk.get_backdoor();
          if (bkdr != null)
            return bkdr;
          blk = blk.get_parent();
        end
      end
      return this.backdoor;
   endfunction: get_backdoor
   
   
   function void clear_hdl_path(string kind = "RTL");
   
     if (kind == "ALL") begin
       hdl_paths_pool = new("hdl_paths");
       return;
     end
   
     if (kind == "")
       kind = get_default_hdl_path();
   
     if (!hdl_paths_pool.exists(kind)) begin
       `uvm_warning("RegModel",{"Unknown HDL Abstraction '",kind,"'"})
       return;
     end
   
     hdl_paths_pool.delete(kind);
   endfunction
   
   
   function void add_hdl_path(string path, string kind = "RTL");
   
     uvm_queue #(string) paths;
   
     paths = hdl_paths_pool.get(kind);
   
     paths.push_back(path);
   
   endfunction
   
   
   function bit  has_hdl_path(string kind = "");
     if (kind == "") begin
       kind = get_default_hdl_path();
     end
     return hdl_paths_pool.exists(kind);
   endfunction
   
   
   function void get_hdl_path(ref string paths[$], input string kind = "");
   
     uvm_queue #(string) hdl_paths;
   
     if (kind == "")
       kind = get_default_hdl_path();
   
     if (!has_hdl_path(kind)) begin
       `uvm_error("RegModel",{"Block does not have hdl path defined for abstraction '",kind,"'"})
       return;
     end
   
     hdl_paths = hdl_paths_pool.get(kind);
   
     for (int i=0; i<hdl_paths.size();i++)
       paths.push_back(hdl_paths.get(i));
   
   endfunction
   
   
   
   function void get_full_hdl_path(ref string paths[$], input string kind = "", string separator = ".");
   
      if (kind == "")
         kind = get_default_hdl_path();
   
      paths.delete();
      if (is_hdl_path_root(kind)) begin
         if (root_hdl_paths[kind] != "")
            paths.push_back(root_hdl_paths[kind]);
         return;
      end
   
      if (!has_hdl_path(kind)) begin
         `uvm_error("RegModel",{"Block does not have hdl path defined for abstraction '",kind,"'"})
         return;
      end
      
      begin
         uvm_queue #(string) hdl_paths = hdl_paths_pool.get(kind);
         string parent_paths[$];
   
         if (parent != null)
            parent.get_full_hdl_path(parent_paths, kind, separator);
   
         for (int i=0; i<hdl_paths.size();i++) begin
            string hdl_path = hdl_paths.get(i);
   
            if (parent_paths.size() == 0) begin
               if (hdl_path != "")
                  paths.push_back(hdl_path);
   
               continue;
            end
            
            foreach (parent_paths[j])  begin
               if (hdl_path == "")
                  paths.push_back(parent_paths[j]);
               else
                  paths.push_back({ parent_paths[j], separator, hdl_path });
            end
         end
      end
     
   endfunction
   
   
   
   function string get_default_hdl_path();
     if (default_hdl_path == "" && parent != null)
       return parent.get_default_hdl_path();
     return default_hdl_path;
   endfunction
   
   
   
   function void set_default_hdl_path(string kind);
   
     if (kind == "") begin
       if (parent == null) begin
         `uvm_error("RegModel",{"Block has no parent. ", "Must specify a valid HDL abstraction (kind)"})
       end
       kind = parent.get_default_hdl_path();
     end
   
     default_hdl_path = kind;
   endfunction
   
   
   
   function void set_hdl_path_root (string path, string kind = "RTL");
     if (kind == "")
       kind = get_default_hdl_path();
   
     root_hdl_paths[kind] = path;
   endfunction
   
   
   
   function bit  is_hdl_path_root (string kind = "");
     if (kind == "")
       kind = get_default_hdl_path();
   
     return root_hdl_paths.exists(kind);
   endfunction
   
   virtual function void do_print (uvm_printer printer);
     super.do_print(printer);
   
     foreach(blks[i]) begin
        uvm_reg_block b = i;
        uvm_object obj = b;
        printer.print_object(obj.get_name(), obj);
     end
      
     foreach(regs[i]) begin
        uvm_reg r = i;
        uvm_object obj = r;
        printer.print_object(obj.get_name(), obj);
     end
   
     foreach(vregs[i]) begin
        uvm_vreg r = i;
        uvm_object obj = r;
        printer.print_object(obj.get_name(), obj);
     end
   
     foreach(mems[i]) begin
        uvm_mem m = i;
        uvm_object obj = m;
        printer.print_object(obj.get_name(), obj);
     end
   
     foreach(maps[i]) begin
        uvm_reg_map m = i;
        uvm_object obj = m;
        printer.print_object(obj.get_name(), obj);
     end
     
   endfunction
   
   virtual function uvm_object clone();
     `uvm_fatal("RegModel","RegModel blocks cannot be cloned")
     return null;
   endfunction
   
   virtual function void do_copy(uvm_object rhs);
     `uvm_fatal("RegModel","RegModel blocks cannot be copied")
   endfunction
   
   virtual function bit do_compare (uvm_object  rhs, uvm_comparer comparer);
     `uvm_warning("RegModel","RegModel blocks cannot be compared")
     return 0;
   endfunction
   
   virtual function void do_pack (uvm_packer packer);
     `uvm_warning("RegModel","RegModel blocks cannot be packed")
   endfunction
   
   virtual function void do_unpack (uvm_packer packer);
     `uvm_warning("RegModel","RegModel blocks cannot be unpacked")
   endfunction
   
   virtual function string convert2string();
      string image;
      string maps[];
      string blk_maps[];
      bit         single_map;
      uvm_endianness_e endian;
      string prefix = "  ";
   
   `ifdef TODO
      single_map = 1;
      if (map == "") begin
         this.get_maps(maps);
         if (maps.size() > 1) single_map = 0;
      end
   
      if (single_map) begin
         $sformat(image, "%sBlock %s", prefix, this.get_full_name());
   
         if (map != "")
           $sformat(image, "%s.%s", image, map);
   
         endian = this.get_endian(map);
   
         $sformat(image, "%s -- %0d bytes (%s)", image, this.get_n_bytes(map), endian.name());
   
         foreach (blks[i]) begin
            string img;
            img = blks[i].convert2string({prefix, "   "}, blk_maps[i]);
            image = {image, "\n", img};
         end
   
      end
      else begin
         $sformat(image, "%Block %s", prefix, this.get_full_name());
         foreach (maps[i]) begin
            string img;
            endian = this.get_endian(maps[i]);
            $sformat(img, "%s   Map \"%s\" -- %0d bytes (%s)", prefix, maps[i], this.get_n_bytes(maps[i]), endian.name());
            image = {image, "\n", img};
   
            this.get_blocks(blks, blk_maps, maps[i]);
            foreach (blks[j]) begin
               img = blks[j].convert2string({prefix, "      "}, blk_maps[j]);
               image = {image, "\n", img};
            end
   
            this.get_subsys(sys, blk_maps, maps[i]);
            foreach (sys[j]) begin
               img = sys[j].convert2string({prefix, "      "}, blk_maps[j]);
               image = {image, "\n", img};
            end
         end
      end
   `endif
      return image;
   endfunction: convert2string


endclass:uvm_reg_block


class uvm_reg_hw_reset_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   `uvm_object_utils(uvm_reg_hw_reset_seq)

   function new(string name="uvm_reg_hw_reset_seq");
     super.new(name);
   endfunction

   virtual task body();
      if (model == null) begin
         `uvm_error("uvm_reg_hw_reset_seq", "Not block or system specified to run sequence on");
         return;
      end
      uvm_report_info("STARTING_SEQ",{"\n\nStarting ",get_name()," sequence...\n"},UVM_LOW);
      
      this.reset_blk(model);
      model.reset();

      do_block(model);
   endtask: body

   protected virtual task do_block(uvm_reg_block blk);
      uvm_reg_map maps[$];
      uvm_reg_map sub_maps[$];

      if (uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_REG_HW_RESET_TEST", 0) != null ) begin
            return;
      end

      
      blk.get_maps(maps);

      foreach (maps[d]) begin
        uvm_reg regs[$];
        maps[d].get_submaps(sub_maps);
        if(sub_maps.size() !=0) begin 
          continue;
        end


        regs.delete();
        maps[d].get_registers(regs);

        foreach (regs[i]) begin

          uvm_status_e status;

          if (uvm_resource_db#(bit)::get_by_name({"REG::",regs[i].get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",regs[i].get_full_name()}, "NO_REG_HW_RESET_TEST", 0) != null )
              continue;

          `uvm_info(get_type_name(), $sformatf("Verifying reset value of register %s in map \"%s\"...", regs[i].get_full_name(), maps[d].get_full_name()), UVM_LOW);
            
          regs[i].mirror(status, UVM_CHECK, UVM_FRONTDOOR, maps[d], this);

          if (status != UVM_IS_OK) begin
             `uvm_error(get_type_name(), $sformatf("Status was %s when reading reset value of register \"%s\" through map \"%s\".", status.name(), regs[i].get_full_name(), maps[d].get_full_name()));
          end
        end
      end

      begin
         uvm_reg_block blks[$];
         
         blk.get_blocks(blks);
         foreach (blks[i]) begin
            do_block(blks[i]);
         end
      end

   endtask:do_block


   virtual task reset_blk(uvm_reg_block blk);
   endtask

endclass: uvm_reg_hw_reset_seq



class uvm_reg_single_bit_bash_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   uvm_reg rg;

   `uvm_object_utils(uvm_reg_single_bit_bash_seq)

   function new(string name="uvm_reg_single_bit_bash_seq");
     super.new(name);
   endfunction

   virtual task body();
      uvm_reg_field fields[$];
      string mode[`UVM_REG_DATA_WIDTH];
      uvm_reg_map maps[$];
      uvm_reg_data_t  dc_mask;
      uvm_reg_data_t  reset_val;
      int n_bits;
      string field_access;
         
      if (rg == null) begin
         `uvm_error("uvm_reg_bit_bash_seq", "No register specified to run sequence on");
         return;
      end

      if (uvm_resource_db#(bit)::get_by_name({"REG::",rg.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",rg.get_full_name()}, "NO_REG_BIT_BASH_TEST", 0) != null )
            return;
      
      n_bits = rg.get_n_bytes() * 8;
         
      rg.get_fields(fields);
         
      rg.get_maps(maps);
         
      foreach (maps[j]) begin
         uvm_status_e status;
         uvm_reg_data_t  val, exp, v;
         int next_lsb;
         
         next_lsb = 0;
         dc_mask  = 0;
         foreach (fields[k]) begin
            int lsb, w, dc;

            field_access = fields[k].get_access(maps[j]);
            dc = (fields[k].get_compare() == UVM_NO_CHECK);
            lsb = fields[k].get_lsb_pos();
            w   = fields[k].get_n_bits();
            case (field_access)
             "WO", "WOC", "WOS", "WO1", "NOACCESS": dc = 1;
            endcase
            while (next_lsb < lsb) mode[next_lsb++] = "RO";
            
            repeat (w) begin
               mode[next_lsb] = field_access;
               dc_mask[next_lsb] = dc;
               next_lsb++;
            end
         end
         while (next_lsb < `UVM_REG_DATA_WIDTH)
            mode[next_lsb++] = "RO";
         
         `uvm_info("uvm_reg_bit_bash_seq", $sformatf("Verifying bits in register %s in map \"%s\"...", rg.get_full_name(), maps[j].get_full_name()),UVM_LOW);
         
         for (int k = 0; k < n_bits; k++) begin
            if (dc_mask[k]) continue;

            bash_kth_bit(rg, k, mode[k], maps[j], dc_mask);
         end
            
      end
   endtask: body


   task bash_kth_bit(uvm_reg         rg, int             k, string          mode, uvm_reg_map     map, uvm_reg_data_t  dc_mask);
      uvm_status_e status;
      uvm_reg_data_t  val, exp, v;
      bit bit_val;

      `uvm_info("uvm_reg_bit_bash_seq", $sformatf("...Bashing %s bit #%0d", mode, k),UVM_HIGH);
      
      repeat (2) begin
         val = rg.get();
         v   = val;
         exp = val;
         val[k] = ~val[k];
         bit_val = val[k];
         
         rg.write(status, val, UVM_FRONTDOOR, map, this);
         if (status != UVM_IS_OK) begin
            `uvm_error("uvm_reg_bit_bash_seq", $sformatf("Status was %s when writing to register \"%s\" through map \"%s\".", status.name(), rg.get_full_name(), map.get_full_name()));
         end
         
         exp = rg.get() & ~dc_mask;
         rg.read(status, val, UVM_FRONTDOOR, map, this);
         if (status != UVM_IS_OK) begin
            `uvm_error("uvm_reg_bit_bash_seq", $sformatf("Status was %s when reading register \"%s\" through map \"%s\".", status.name(), rg.get_full_name(), map.get_full_name()));
         end

         val &= ~dc_mask;
         if (val !== exp) begin
            `uvm_error("uvm_reg_bit_bash_seq", $sformatf("Writing a %b in bit #%0d of register \"%s\" with initial value 'h%h yielded 'h%h instead of 'h%h", bit_val, k, rg.get_full_name(), v, val, exp));
         end
      end
   endtask: bash_kth_bit

endclass: uvm_reg_single_bit_bash_seq



class uvm_reg_bit_bash_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   protected uvm_reg_single_bit_bash_seq reg_seq;
   
   `uvm_object_utils(uvm_reg_bit_bash_seq)

   function new(string name="uvm_reg_bit_bash_seq");
     super.new(name);
   endfunction


   virtual task body();
      
      if (model == null) begin
         `uvm_error("uvm_reg_bit_bash_seq", "No register model specified to run sequence on");
         return;
      end

      uvm_report_info("STARTING_SEQ",{"\n\nStarting ",get_name()," sequence...\n"},UVM_LOW);

      reg_seq = uvm_reg_single_bit_bash_seq::type_id::create("reg_single_bit_bash_seq");

      this.reset_blk(model);
      model.reset();

      do_block(model);
   endtask


   protected virtual task do_block(uvm_reg_block blk);
      uvm_reg regs[$];

      if (uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_REG_BIT_BASH_TEST", 0) != null )
         return;

      blk.get_registers(regs, UVM_NO_HIER);
      foreach (regs[i]) begin
         if (uvm_resource_db#(bit)::get_by_name({"REG::",regs[i].get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",regs[i].get_full_name()}, "NO_REG_BIT_BASH_TEST", 0) != null )
            continue;
         
         reg_seq.rg = regs[i];
         reg_seq.start(null,this);
      end

      begin
         uvm_reg_block blks[$];
         
         blk.get_blocks(blks);
         foreach (blks[i]) begin
            do_block(blks[i]);
         end
      end
   endtask: do_block


   virtual task reset_blk(uvm_reg_block blk);
   endtask

endclass: uvm_reg_bit_bash_seq


class uvm_mem_single_walk_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   `uvm_object_utils(uvm_mem_single_walk_seq)
   uvm_mem mem;

   function new(string name="uvm_mem_walk_seq");
     super.new(name);
   endfunction

   virtual task body();
      uvm_reg_map maps[$];
      int n_bits;

      if (mem == null) begin
         `uvm_error("uvm_mem_walk_seq", "No memory specified to run sequence on");
         return;
      end

      if (uvm_resource_db#(bit)::get_by_name({"REG::",mem.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mem.get_full_name()}, "NO_MEM_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mem.get_full_name()}, "NO_MEM_WALK_TEST", 0) != null )
         return;

      n_bits = mem.get_n_bits();

      mem.get_maps(maps);
      
      foreach (maps[j]) begin
         uvm_status_e status;
         uvm_reg_data_t  val, exp, v;
         
         if (mem.get_access(maps[j]) != "RW") continue;

         `uvm_info("uvm_mem_walk_seq", $sformatf("Walking memory %s in map \"%s\"...", mem.get_full_name(), maps[j].get_full_name()), UVM_LOW);
         
         for (int k = 0; k < mem.get_size(); k++) begin

            mem.write(status, k, ~k, UVM_FRONTDOOR, maps[j], this);

            if (status != UVM_IS_OK) begin
               `uvm_error("uvm_mem_walk_seq", $sformatf("Status was %s when writing \"%s[%0d]\" through map \"%s\".", status.name(), mem.get_full_name(), k, maps[j].get_full_name()));
            end
            
            if (k > 0) begin
               mem.read(status, k-1, val, UVM_FRONTDOOR, maps[j], this);
               if (status != UVM_IS_OK) begin
                  `uvm_error("uvm_mem_walk_seq", $sformatf("Status was %s when reading \"%s[%0d]\" through map \"%s\".", status.name(), mem.get_full_name(), k, maps[j].get_full_name()));
               end
               else begin
                  exp = ~(k-1) & ((1'b1<<n_bits)-1);
                  if (val !== exp) begin
                     `uvm_error("uvm_mem_walk_seq", $sformatf("\"%s[%0d-1]\" read back as 'h%h instead of 'h%h.", mem.get_full_name(), k, val, exp));
                     
                  end
               end
               
               mem.write(status, k-1, k-1, UVM_FRONTDOOR, maps[j], this);
               if (status != UVM_IS_OK) begin
                  `uvm_error("uvm_mem_walk_seq", $sformatf("Status was %s when writing \"%s[%0d-1]\" through map \"%s\".", status.name(), mem.get_full_name(), k, maps[j].get_full_name()));
               end
            end
            
            if (k == mem.get_size() - 1) begin
               mem.read(status, k, val, UVM_FRONTDOOR, maps[j], this);
               if (status != UVM_IS_OK) begin
                  `uvm_error("uvm_mem_walk_seq", $sformatf("Status was %s when reading \"%s[%0d]\" through map \"%s\".", status.name(), mem.get_full_name(), k, maps[j].get_full_name()));
               end
               else begin
                  exp = ~(k) & ((1'b1<<n_bits)-1);
                  if (val !== exp) begin
                     `uvm_error("uvm_mem_walk_seq", $sformatf("\"%s[%0d]\" read back as 'h%h instead of 'h%h.", mem.get_full_name(), k, val, exp));
                     
                  end
               end
            end
         end
      end
   endtask: body

endclass: uvm_mem_single_walk_seq


class uvm_mem_walk_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   protected uvm_mem_single_walk_seq mem_seq;

   `uvm_object_utils(uvm_mem_walk_seq)

   function new(string name="uvm_mem_walk_seq");
     super.new(name);
   endfunction

   virtual task body();

      if (model == null) begin
         `uvm_error("uvm_mem_walk_seq", "No register model specified to run sequence on");
         return;
      end

      uvm_report_info("STARTING_SEQ",{"\n\nStarting ",get_name()," sequence...\n"},UVM_LOW);

      mem_seq = uvm_mem_single_walk_seq::type_id::create("single_mem_walk_seq");

      this.reset_blk(model);
      model.reset();

      do_block(model);
   endtask: body


   protected virtual task do_block(uvm_reg_block blk);
      uvm_mem mems[$];
      
      if (uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_MEM_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_MEM_ACCESS_TEST", 0) != null )
         return;
      
      blk.get_memories(mems, UVM_NO_HIER);
      foreach (mems[i]) begin
         if (uvm_resource_db#(bit)::get_by_name({"REG::",mems[i].get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mems[i].get_full_name()}, "NO_MEM_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mems[i].get_full_name()}, "NO_MEM_WALK_TEST", 0) != null )
           continue;
         
         mem_seq.mem = mems[i];
         mem_seq.start(null, this);
      end

      begin
         uvm_reg_block blks[$];
         
         blk.get_blocks(blks);
         foreach (blks[i]) begin
            do_block(blks[i]);
         end
      end
   endtask: do_block


   virtual task reset_blk(uvm_reg_block blk);
   endtask

endclass: uvm_mem_walk_seq

class uvm_mem_single_access_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   uvm_mem mem;

   `uvm_object_utils(uvm_mem_single_access_seq)

   function new(string name="uam_mem_single_access_seq");
     super.new(name);
   endfunction

   virtual task body();
      string mode;
      uvm_reg_map maps[$];
      int n_bits;

      if (mem == null) begin
         `uvm_error("uvm_mem_access_seq", "No register specified to run sequence on");
         return;
      end

      if (uvm_resource_db#(bit)::get_by_name({"REG::",mem.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mem.get_full_name()}, "NO_MEM_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mem.get_full_name()}, "NO_MEM_ACCESS_TEST", 0) != null)
         return;

      if (mem.get_backdoor() == null && !mem.has_hdl_path()) begin
         `uvm_error("uvm_mem_access_seq", {"Memory '",mem.get_full_name(), "' does not have a backdoor mechanism available"})
         return;
      end

      n_bits = mem.get_n_bits();
      
      mem.get_maps(maps);

      foreach (maps[j]) begin
         uvm_status_e status;
         uvm_reg_data_t  val, exp, v;
         
         `uvm_info("uvm_mem_access_seq", {"Verifying access of memory '", mem.get_full_name(),"' in map '", maps[j].get_full_name(), "' ..."}, UVM_LOW)

         mode = mem.get_access(maps[j]);
         
         for (int k = 0; k < mem.get_size(); k++) begin
            val = $random & uvm_reg_data_t'((1'b1<<n_bits)-1);
            if (n_bits > 32)
              val = uvm_reg_data_t'(val << 32) | $random;
            if (mode == "RO") begin
               mem.peek(status, k, exp);
               if (status != UVM_IS_OK) begin
                  `uvm_error("uvm_mem_access_seq", $sformatf("Status was %s when reading \"%s[%0d]\" through backdoor.", status.name(), mem.get_full_name(), k))
               end
            end
            else exp = val;
            
            mem.write(status, k, val, UVM_FRONTDOOR, maps[j], this);
            if (status != UVM_IS_OK) begin
               `uvm_error("uvm_mem_access_seq", $sformatf("Status was %s when writing \"%s[%0d]\" through map \"%s\".", status.name(), mem.get_full_name(), k, maps[j].get_full_name()))
            end
            #1;
            
            val = 'x;
            mem.peek(status, k, val);
            if (status != UVM_IS_OK) begin
               `uvm_error("uvm_mem_access_seq", $sformatf("Status was %s when reading \"%s[%0d]\" through backdoor.", status.name(), mem.get_full_name(), k))
            end
            else begin
               if (val !== exp) begin
                  `uvm_error("uvm_mem_access_seq", $sformatf("Backdoor \"%s[%0d]\" read back as 'h%h instead of 'h%h.", mem.get_full_name(), k, val, exp))
               end
            end
            
            exp = ~exp & ((1'b1<<n_bits)-1);
            mem.poke(status, k, exp);
            if (status != UVM_IS_OK) begin
               `uvm_error("uvm_mem_access_seq", $sformatf("Status was %s when writing \"%s[%0d-1]\" through backdoor.", status.name(), mem.get_full_name(), k))
            end
            
            mem.read(status, k, val, UVM_FRONTDOOR, maps[j], this);
            if (status != UVM_IS_OK) begin
               `uvm_error("uvm_mem_access_seq", $sformatf("Status was %s when reading \"%s[%0d]\" through map \"%s\".", status.name(), mem.get_full_name(), k, maps[j].get_full_name()))
            end
            else begin
               if (mode == "WO") begin
                  if (val !== '0) begin
                     `uvm_error("uvm_mem_access_seq", $sformatf("Front door \"%s[%0d]\" read back as 'h%h instead of 'h%h.", mem.get_full_name(), k, val, 0))
                  end
               end
               else begin
                  if (val !== exp) begin
                     `uvm_error("uvm_mem_access_seq", $sformatf("Front door \"%s[%0d]\" read back as 'h%h instead of 'h%h.", mem.get_full_name(), k, val, exp))
                  end
               end
            end
         end
      end
   endtask: body
endclass: uvm_mem_single_access_seq

class uvm_mem_access_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   protected uvm_mem_single_access_seq mem_seq;

   `uvm_object_utils(uvm_mem_access_seq)

   function new(string name="uvm_mem_access_seq");
     super.new(name);
   endfunction

   virtual task body();

      if (model == null) begin
         `uvm_error("uvm_mem_access_seq", "No register model specified to run sequence on");
         return;
      end

      uvm_report_info("STARTING_SEQ",{"\n\nStarting ",get_name()," sequence...\n"},UVM_LOW);
      
      mem_seq = uvm_mem_single_access_seq::type_id::create("single_mem_access_seq");

      this.reset_blk(model);
      model.reset();

      do_block(model);
   endtask: body


   protected virtual task do_block(uvm_reg_block blk);
      uvm_mem mems[$];
      
      if (uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_MEM_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_MEM_ACCESS_TEST", 0) != null )
         return;
      
      blk.get_memories(mems, UVM_NO_HIER);
      foreach (mems[i]) begin
         if (uvm_resource_db#(bit)::get_by_name({"REG::",mems[i].get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mems[i].get_full_name()}, "NO_MEM_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mems[i].get_full_name()}, "NO_MEM_ACCESS_TEST", 0) != null )
           continue;
         
         if (mems[i].get_backdoor() == null &&
             !mems[i].has_hdl_path()) begin
            `uvm_warning("uvm_mem_access_seq", $sformatf("Memory \"%s\" does not have a backdoor mechanism available", mems[i].get_full_name()));
            continue;
         end
         
         mem_seq.mem = mems[i];
         mem_seq.start(null, this);
      end

      begin
         uvm_reg_block blks[$];
         
         blk.get_blocks(blks);
         foreach (blks[i]) begin
            do_block(blks[i]);
         end
      end
   endtask: do_block


   virtual task reset_blk(uvm_reg_block blk);
   endtask


endclass: uvm_mem_access_seq



typedef class uvm_mem_access_seq;

class uvm_reg_single_access_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   uvm_reg rg;

   `uvm_object_utils(uvm_reg_single_access_seq)

   function new(string name="uvm_reg_single_access_seq");
     super.new(name);
   endfunction

   virtual task body();
      uvm_reg_map maps[$];

      if (rg == null) begin
         `uvm_error("uvm_reg_access_seq", "No register specified to run sequence on")
         return;
      end

      if (uvm_resource_db#(bit)::get_by_name({"REG::",rg.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",rg.get_full_name()}, "NO_REG_ACCESS_TEST", 0) != null )
            return;

      if (rg.get_backdoor() == null && !rg.has_hdl_path()) begin
         `uvm_error("uvm_reg_access_seq", {"Register '",rg.get_full_name(), "' does not have a backdoor mechanism available"})
         return;
      end

      rg.get_maps(maps);

      begin
         uvm_reg_field fields[$];

         rg.get_fields(fields);
         foreach (maps[k]) begin
	        int ro;
	       	ro=0;
	     	foreach (fields[j]) begin    
               if (fields[j].get_access(maps[k]) == "RO") begin
                  ro++;
               end
               if (!fields[j].is_known_access(maps[k])) begin
                  `uvm_warning("uvm_reg_access_seq", {"Register '",rg.get_full_name(), "' has field with unknown access type '", fields[j].get_access(maps[k]),"', skipping"})
                  return;
               end
	     	end
	     	if(ro==fields.size()) begin
	     		`uvm_warning("uvm_reg_access_seq", {"Register '", rg.get_full_name(),"' has only RO fields in map ",maps[k].get_full_name(),", skipping"})
                return;
	     	end	
         end
      end
      
      foreach (maps[j]) begin
         uvm_status_e status;
         uvm_reg_data_t  v, exp;
         
         `uvm_info("uvm_reg_access_seq", {"Verifying access of register '", rg.get_full_name(),"' in map '", maps[j].get_full_name(), "' ..."}, UVM_LOW)
         
         v = rg.get();
         
         rg.write(status, ~v, UVM_FRONTDOOR, maps[j], this);

         if (status != UVM_IS_OK) begin
            `uvm_error("uvm_reg_access_seq", {"Status was '",status.name(), "' when writing '",rg.get_full_name(), "' through map '",maps[j].get_full_name(),"'"})
         end
         #1;
         
         rg.mirror(status, UVM_CHECK, UVM_BACKDOOR, uvm_reg_map::backdoor(), this);
         if (status != UVM_IS_OK) begin
            `uvm_error("uvm_reg_access_seq", {"Status was '",status.name(), "' when reading reset value of register '", rg.get_full_name(), "' through backdoor"})
         end
         
         rg.write(status, v, UVM_BACKDOOR, maps[j], this);
         if (status != UVM_IS_OK) begin
            `uvm_error("uvm_reg_access_seq", {"Status was '",status.name(), "' when writing '",rg.get_full_name(), "' through backdoor"})
         end
         
         rg.mirror(status, UVM_CHECK, UVM_FRONTDOOR, maps[j], this);
         if (status != UVM_IS_OK) begin
            `uvm_error("uvm_reg_access_seq", {"Status was '",status.name(), "' when reading reset value of register '", rg.get_full_name(), "' through map '", maps[j].get_full_name(),"'"})
         end
      end
   endtask: body
endclass: uvm_reg_single_access_seq

class uvm_reg_access_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   protected uvm_reg_single_access_seq reg_seq;
   
   `uvm_object_utils(uvm_reg_access_seq)

   function new(string name="uvm_reg_access_seq");
     super.new(name);
   endfunction

   virtual task body();

      if (model == null) begin
         `uvm_error("uvm_reg_access_seq", "No register model specified to run sequence on")
         return;
      end

      uvm_report_info("STARTING_SEQ",{"\n\nStarting ",get_name()," sequence...\n"},UVM_LOW);
      
      reg_seq = uvm_reg_single_access_seq::type_id::create("single_reg_access_seq");

      this.reset_blk(model);
      model.reset();

      do_block(model);
   endtask: body


   protected virtual task do_block(uvm_reg_block blk);
      uvm_reg regs[$];
      
      if (uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_REG_ACCESS_TEST", 0) != null )
         return;

      blk.get_registers(regs, UVM_NO_HIER);
      foreach (regs[i]) begin
         if (uvm_resource_db#(bit)::get_by_name({"REG::",regs[i].get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",regs[i].get_full_name()}, "NO_REG_ACCESS_TEST", 0) != null )
              continue;
         
         if (regs[i].get_backdoor() == null && !regs[i].has_hdl_path()) begin
            `uvm_warning("uvm_reg_access_seq", {"Register '",regs[i].get_full_name(), "' does not have a backdoor mechanism available"})
            continue;
         end
         
         reg_seq.rg = regs[i];
         reg_seq.start(null,this);
      end

      begin
         uvm_reg_block blks[$];
         
         blk.get_blocks(blks);
         foreach (blks[i]) begin
            do_block(blks[i]);
         end
      end
   endtask: do_block


   virtual task reset_blk(uvm_reg_block blk);
   endtask

endclass: uvm_reg_access_seq

class uvm_reg_mem_access_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   `uvm_object_utils(uvm_reg_mem_access_seq)

   function new(string name="uvm_reg_mem_access_seq");
     super.new(name);
   endfunction

   virtual task body();

      if (model == null) begin
         `uvm_error("uvm_reg_mem_access_seq", "Register model handle is null")
         return;
      end

      uvm_report_info("STARTING_SEQ",
            {"\n\nStarting ",get_name()," sequence...\n"},UVM_LOW);
      
      if (uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_TESTS", 0) == null) begin
        if (uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_ACCESS_TEST", 0) == null) begin
           uvm_reg_access_seq sub_seq = new("reg_access_seq");
           this.reset_blk(model);
           model.reset();
           sub_seq.model = model;
           sub_seq.start(null,this);
        end
        if (uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_MEM_ACCESS_TEST", 0) == null) begin
           uvm_mem_access_seq sub_seq = new("mem_access_seq");
           this.reset_blk(model);
           model.reset();
           sub_seq.model = model;
           sub_seq.start(null,this);
        end
      end

   endtask: body


   virtual task reset_blk(uvm_reg_block blk);
   endtask

endclass: uvm_reg_mem_access_seq

class uvm_reg_shared_access_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   uvm_reg rg;

   `uvm_object_utils(uvm_reg_shared_access_seq)

   function new(string name="uvm_reg_shared_access_seq");
     super.new(name);
   endfunction

   virtual task body();
      uvm_reg_data_t  other_mask;
      uvm_reg_data_t  wo_mask[$];
      uvm_reg_field fields[$];
      uvm_reg_map maps[$];

      if (rg == null) begin
         `uvm_error("uvm_reg_shared_access_seq", "No register specified to run sequence on");
         return;
      end

      if (uvm_resource_db#(bit)::get_by_name({"REG::",rg.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",rg.get_full_name()}, "NO_REG_SHARED_ACCESS_TEST", 0) != null )
        return;

      if (rg.get_n_maps() < 2) return;
      rg.get_maps(maps);

      rg.get_fields(fields);

      other_mask = 0;
      foreach (fields[k]) begin
         int lsb, w;
         
         lsb = fields[k].get_lsb_pos();
         w   = fields[k].get_n_bits();
         
         if (!fields[k].is_known_access(maps[0])) begin
            repeat (w) begin
               other_mask[lsb++] = 1'b1;
            end
         end
      end
      
      foreach (maps[j]) begin
         uvm_reg_data_t  wo;
         wo = 0;
         foreach (fields[k]) begin
            int lsb, w;
            
            lsb = fields[k].get_lsb_pos();
            w   = fields[k].get_n_bits();
            
            if (fields[k].get_access(maps[j]) == "WO") begin
               repeat (w) begin
                  wo[lsb++] = 1'b1;
               end
            end
         end
         wo_mask[j] = wo;
      end
      
      foreach (maps[j]) begin
         uvm_status_e status;
         uvm_reg_data_t  prev, v;
         
         prev = rg.get();
         
         v = ({$random, $random} & ~other_mask) | (prev & other_mask);
         
         `uvm_info("uvm_reg_shared_access_seq", $sformatf("Writing register %s via map \"%s\"...", rg.get_full_name(), maps[j].get_full_name), UVM_LOW);
         
         `uvm_info("uvm_reg_shared_access_seq", $sformatf("Writing 'h%h over 'h%h", v, prev),UVM_DEBUG);
         
         rg.write(status, v, UVM_FRONTDOOR, maps[j], this);
         if (status != UVM_IS_OK) begin
            `uvm_error("uvm_reg_shared_access_seq", $sformatf("Status was %s when writing register \"%s\" through map \"%s\".", status.name(), rg.get_full_name(), maps[j].get_full_name()));
         end
         
         foreach (maps[k]) begin
            uvm_reg_data_t  actual, exp;
            
            `uvm_info("uvm_reg_shared_access_seq", $sformatf("Reading register %s via map \"%s\"...", rg.get_full_name(), maps[k].get_full_name()), UVM_LOW);
            
            exp = rg.get() & ~wo_mask[k];
            
            rg.read(status, actual, UVM_FRONTDOOR, maps[k], this);
            if (status != UVM_IS_OK) begin
               `uvm_error("uvm_reg_shared_access_seq", $sformatf("Status was %s when reading register \"%s\" through map \"%s\".", status.name(), rg.get_full_name(), maps[k].get_full_name()));
            end
            
            `uvm_info("uvm_reg_shared_access_seq", $sformatf("Read 'h%h, expecting 'h%h", actual, exp),UVM_DEBUG);
            
            if (actual !== exp) begin
               `uvm_error("uvm_reg_shared_access_seq", $sformatf("Register \"%s\" through map \"%s\" is 'h%h instead of 'h%h after writing 'h%h via map \"%s\" over 'h%h.", rg.get_full_name(), maps[k].get_full_name(), actual, exp, v, maps[j].get_full_name(), prev));
            end
         end
      end
   endtask: body
endclass: uvm_reg_shared_access_seq

class uvm_mem_shared_access_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   uvm_mem mem;

   `uvm_object_utils(uvm_mem_shared_access_seq)

   function new(string name="uvm_mem_shared_access_seq");
     super.new(name);
   endfunction

   virtual task body();
      int read_from;
      uvm_reg_map maps[$];

      if (mem == null) begin
         `uvm_error("uvm_mem_shared_access_seq", "No memory specified to run sequence on");
         return;
      end

      if (uvm_resource_db#(bit)::get_by_name({"REG::",mem.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mem.get_full_name()}, "NO_MEM_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mem.get_full_name()}, "NO_REG_SHARED_ACCESS_TEST", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mem.get_full_name()}, "NO_MEM_SHARED_ACCESS_TEST", 0) != null )
            return;

      if (mem.get_n_maps() < 2) return;
      mem.get_maps(maps);

      read_from = -1;
      if (mem.get_backdoor() == null) begin
         foreach (maps[j]) begin
            string right;
            right = mem.get_access(maps[j]);
            if (right == "RW" ||
                right == "RO") begin
               read_from = j;
               break;
            end
         end
         if (read_from < 0) begin
            `uvm_warning("uvm_mem_shared_access_seq", $sformatf("Memory \"%s\" cannot be read from any maps or backdoor. Shared access not verified.", mem.get_full_name()));
            return;
         end
      end
      
      foreach (maps[j]) begin
         
         `uvm_info("uvm_mem_shared_access_seq", $sformatf("Writing shared memory \"%s\" via map \"%s\".", mem.get_full_name(), maps[j].get_full_name()), UVM_LOW);
         
         for (int offset = 0; offset < mem.get_size(); offset++) begin
            uvm_status_e status;
            uvm_reg_data_t  prev, v;
            
            if (mem.get_backdoor() != null) begin
               mem.peek(status, offset, prev);
               if (status != UVM_IS_OK) begin
                  `uvm_error("uvm_mem_shared_access_seq", $sformatf("Status was %s when reading initial value of \"%s\"[%0d] through backdoor.", status.name(), mem.get_full_name(), offset));
               end
            end
            else begin
               mem.read(status, offset, prev, UVM_FRONTDOOR, maps[read_from], this);
               if (status != UVM_IS_OK) begin
                  `uvm_error("uvm_mem_shared_access_seq", $sformatf("Status was %s when reading initial value of \"%s\"[%0d] through map \"%s\".", status.name(), mem.get_full_name(), offset, maps[read_from].get_full_name()));
               end
            end
            
            
            v = {$random, $random};
            
            mem.write(status, offset, v, UVM_FRONTDOOR, maps[j], this);
            if (status != UVM_IS_OK) begin
               `uvm_error("uvm_mem_shared_access_seq", $sformatf("Status was %s when writing \"%s\"[%0d] through map \"%s\".", status.name(), mem.get_full_name(), offset, maps[j].get_full_name()));
            end
            
            foreach (maps[k]) begin
               uvm_reg_data_t  actual, exp;
               
               mem.read(status, offset, actual, UVM_FRONTDOOR, maps[k], this);
               if (status != UVM_IS_OK) begin
                  `uvm_error("uvm_mem_shared_access_seq", $sformatf("Status was %s when reading %s[%0d] through map \"%s\".", status.name(), mem.get_full_name(), offset, maps[k].get_full_name()));
               end
               
               exp = v;
               if (mem.get_access(maps[j]) == "RO") begin
                  exp = prev;
               end
               if (mem.get_access(maps[k]) == "WO") begin
                  exp = 0;
               end
               exp &= (1 << mem.get_n_bits()) - 1;
               if (actual !== exp) begin
                  `uvm_error("uvm_mem_shared_access_seq", $sformatf("%s[%0d] through map \"%s\" is 'h%h instead of 'h%h after writing 'h%h via map \"%s\" over 'h%h.", mem.get_full_name(), offset, maps[k].get_full_name(), actual, exp, v, maps[j].get_full_name(), prev));
               end
            end
         end
      end
   endtask: body
endclass: uvm_mem_shared_access_seq

class uvm_reg_mem_shared_access_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   protected uvm_reg_shared_access_seq reg_seq;
   protected uvm_mem_shared_access_seq mem_seq;
   
   `uvm_object_utils(uvm_reg_mem_shared_access_seq)

   function new(string name="uvm_reg_mem_shared_access_seq");
     super.new(name);
   endfunction

   virtual task body();

      if (model == null) begin
         `uvm_error("uvm_reg_mem_shared_access_seq", "No register model specified to run sequence on");
         return;
      end
      
      uvm_report_info("STARTING_SEQ",{"\n\nStarting ",get_name()," sequence...\n"},UVM_LOW);

      reg_seq = uvm_reg_shared_access_seq::type_id::create("reg_shared_access_seq");
      mem_seq = uvm_mem_shared_access_seq::type_id::create("reg_shared_access_seq");

      this.reset_blk(model);
      model.reset();

      do_block(model);
   endtask: body

   protected virtual task do_block(uvm_reg_block blk);
      uvm_reg regs[$];
      uvm_mem mems[$];
      
      if (uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_MEM_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_REG_SHARED_ACCESS_TEST", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",blk.get_full_name()}, "NO_MEM_SHARED_ACCESS_TEST", 0) != null )
        return;

      this.reset_blk(model);
      model.reset();

      blk.get_registers(regs, UVM_NO_HIER);
      foreach (regs[i]) begin
         if (uvm_resource_db#(bit)::get_by_name({"REG::",regs[i].get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",regs[i].get_full_name()}, "NO_REG_SHARED_ACCESS_TEST", 0) != null )
           continue;
         reg_seq.rg = regs[i];
         reg_seq.start(this.get_sequencer(), this);
      end

      blk.get_memories(mems, UVM_NO_HIER);
      foreach (mems[i]) begin
         if (uvm_resource_db#(bit)::get_by_name({"REG::",mems[i].get_full_name()}, "NO_REG_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mems[i].get_full_name()}, "NO_MEM_TESTS", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mems[i].get_full_name()}, "NO_REG_SHARED_ACCESS_TEST", 0) != null || uvm_resource_db#(bit)::get_by_name({"REG::",mems[i].get_full_name()}, "NO_MEM_SHARED_ACCESS_TEST", 0) != null )
            continue;
         mem_seq.mem = mems[i];
         mem_seq.start(this.get_sequencer(), this);
      end

      begin
         uvm_reg_block blks[$];
         
         blk.get_blocks(blks);
         foreach (blks[i]) begin
            do_block(blks[i]);
         end
      end
   endtask: do_block


   virtual task reset_blk(uvm_reg_block blk);
   endtask


endclass: uvm_reg_mem_shared_access_seq


class uvm_reg_mem_built_in_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));

   `uvm_object_utils(uvm_reg_mem_built_in_seq)

   function new(string name="uvm_reg_mem_built_in_seq");
     super.new(name);
   endfunction

   bit [63:0] tests = UVM_DO_ALL_REG_MEM_TESTS;
   
   virtual task body();

      if (model == null) begin
         `uvm_error("uvm_reg_mem_built_in_seq", "Not block or system specified to run sequence on");
         return;
      end

      uvm_report_info("START_SEQ",{"\n\nStarting ",get_name()," sequence...\n"},UVM_LOW);
      
      if (tests & UVM_DO_REG_HW_RESET && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_TESTS", 0) == null && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_HW_RESET_TEST", 0) == null ) begin
        uvm_reg_hw_reset_seq seq = uvm_reg_hw_reset_seq::type_id::create("reg_hw_reset_seq");
        seq.model = model;
        seq.start(null,this);
        `uvm_info("FINISH_SEQ",{"Finished ",seq.get_name()," sequence."},UVM_LOW)
      end

      if (tests & UVM_DO_REG_BIT_BASH && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_TESTS", 0) == null && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_BIT_BASH_TEST", 0) == null ) begin
        uvm_reg_bit_bash_seq seq = uvm_reg_bit_bash_seq::type_id::create("reg_bit_bash_seq");
        seq.model = model;
        seq.start(null,this);
        `uvm_info("FINISH_SEQ",{"Finished ",seq.get_name()," sequence."},UVM_LOW)
      end

      if (tests & UVM_DO_REG_ACCESS && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_TESTS", 0) == null && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_ACCESS_TEST", 0) == null ) begin
        uvm_reg_access_seq seq = uvm_reg_access_seq::type_id::create("reg_access_seq");
        seq.model = model;
        seq.start(null,this);
        `uvm_info("FINISH_SEQ",{"Finished ",seq.get_name()," sequence."},UVM_LOW)
      end

      if (tests & UVM_DO_MEM_ACCESS && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_TESTS", 0) == null && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_MEM_TESTS", 0) == null && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_MEM_ACCESS_TEST", 0) == null ) begin
        uvm_mem_access_seq seq = uvm_mem_access_seq::type_id::create("mem_access_seq");
        seq.model = model;
        seq.start(null,this);
        `uvm_info("FINISH_SEQ",{"Finished ",seq.get_name()," sequence."},UVM_LOW)
      end

      if (tests & UVM_DO_SHARED_ACCESS && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_TESTS", 0) == null && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_SHARED_ACCESS_TEST", 0) == null ) begin
        uvm_reg_mem_shared_access_seq seq = uvm_reg_mem_shared_access_seq::type_id::create("shared_access_seq");
        seq.model = model;
        seq.start(null,this);
        `uvm_info("FINISH_SEQ",{"Finished ",seq.get_name()," sequence."},UVM_LOW)
      end

      if (tests & UVM_DO_MEM_WALK && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_REG_TESTS", 0) == null && uvm_resource_db#(bit)::get_by_name({"REG::",model.get_full_name()}, "NO_MEM_WALK_TEST", 0) == null ) begin
        uvm_mem_walk_seq seq = uvm_mem_walk_seq::type_id::create("mem_walk_seq");
        seq.model = model;
        seq.start(null,this);
        `uvm_info("FINISH_SEQ",{"Finished ",seq.get_name()," sequence."},UVM_LOW)
      end

   endtask: body

endclass: uvm_reg_mem_built_in_seq


class uvm_reg_mem_hdl_paths_seq extends uvm_reg_sequence #(uvm_sequence #(uvm_reg_item));
    string abstractions[$];
    
    `uvm_object_utils_begin(uvm_reg_mem_hdl_paths_seq)
        `uvm_field_queue_string(abstractions, UVM_DEFAULT)
    `uvm_object_utils_end
    
    function new(string name="uvm_reg_mem_hdl_paths_seq");
        super.new(name);
    endfunction

    virtual task body();

        if (model == null) begin
            uvm_report_error("uvm_reg_mem_hdl_paths_seq", "Register model handle is null");
            return;
        end

       `uvm_info("uvm_reg_mem_hdl_paths_seq", {"checking HDL paths for all registers/memories in ", model.get_full_name()}, UVM_LOW);

       if (abstractions.size() == 0)
          do_block(model, "");
       else begin
          foreach (abstractions[i])
             do_block(model, abstractions[i]);
       end

        `uvm_info("uvm_reg_mem_hdl_paths_seq", "HDL path validation completed ",UVM_LOW);
        
    endtask: body


    virtual task reset_blk(uvm_reg_block blk);
    endtask


    protected virtual function void do_block(uvm_reg_block blk, string        kind);
        uvm_reg       regs[$];
        uvm_mem       mems[$];

       `uvm_info("uvm_reg_mem_hdl_paths_seq", {"Validating HDL paths in ", blk.get_full_name(), " for ", (kind == "") ? "default" : kind, " design abstraction"}, UVM_MEDIUM) 

       blk.get_registers(regs, UVM_NO_HIER);
       foreach (regs[i]) 
          check_reg(regs[i], kind);
       
       blk.get_memories(mems, UVM_NO_HIER);
       foreach (mems[i]) 
          check_mem(mems[i], kind);
    
       begin
          uvm_reg_block blks[$];
          
          blk.get_blocks(blks);
          foreach (blks[i]) begin
             do_block(blks[i], kind);
          end
       end
    endfunction: do_block
    

    protected virtual function void check_reg(uvm_reg r, string kind);
        uvm_hdl_path_concat paths[$];

	if(!r.has_hdl_path(kind))
		return;

        r.get_full_hdl_path(paths, kind);
        if (paths.size() == 0) return;

        foreach(paths[p]) begin
            uvm_hdl_path_concat path=paths[p];
            foreach (path.slices[j]) begin
                string p_ = path.slices[j].path;
                uvm_reg_data_t d;
                if (!uvm_hdl_read(p_,d))
                    `uvm_error("uvm_reg_mem_hdl_paths_seq", $sformatf("HDL path \"%s\" for register \"%s\" is not readable", p_, r.get_full_name()));
                if (!uvm_hdl_check_path(p_))
                    `uvm_error("uvm_reg_mem_hdl_paths_seq", $sformatf("HDL path \"%s\" for register \"%s\" is not accessible", p_, r.get_full_name()));
            end
        end
    endfunction
 

    protected virtual function void check_mem(uvm_mem m, string kind);
        uvm_hdl_path_concat paths[$];

	if(!m.has_hdl_path(kind))
		return;

        m.get_full_hdl_path(paths, kind);
        if (paths.size() == 0) return;

        foreach(paths[p]) begin
            uvm_hdl_path_concat path=paths[p];
            foreach (path.slices[j]) 
            begin
                string p_ = path.slices[j].path;
                if(!uvm_hdl_check_path(p_))
                    `uvm_error("uvm_reg_mem_hdl_paths_seq", $sformatf("HDL path \"%s\" for memory \"%s\" is not accessible", p_, m.get_full_name()));
            end
        end
    endfunction

endclass: uvm_reg_mem_hdl_paths_seq

`endif 

endpackage

`endif
